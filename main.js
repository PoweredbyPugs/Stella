/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StellaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types/index.ts
var DEFAULT_SETTINGS = {
  provider: "anthropic",
  openaiApiKey: "",
  anthropicApiKey: "",
  googleApiKey: "",
  ollamaBaseUrl: "http://localhost:11434",
  lmStudioBaseUrl: "http://localhost:1234",
  customApiUrl: "",
  customApiKey: "",
  model: "",
  maxTokens: 4e3,
  temperature: 0.7,
  conversations: [],
  currentConversationId: null,
  systemPromptsPath: "",
  mentalModelsPath: "",
  backgroundImage: "",
  backgroundMode: "centered",
  backgroundOpacity: 0.5,
  loadingGif: "",
  autoHideHeader: false,
  quickAddCommands: [
    {
      id: "seed",
      name: "Seed",
      description: "Create a seed note from selected text"
    }
  ],
  showTokenCount: false,
  mcpEnabled: false,
  mcpServers: [],
  mcpAutoDiscovery: true
};

// src/services/fetch.ts
var FetchManager = class {
  static async enhancedFetch(url, options = {}) {
    const headers = new Headers(options.headers);
    headers.set("Accept-Encoding", "gzip, deflate, br");
    if (!headers.has("Content-Type") && options.method === "POST") {
      headers.set("Content-Type", "application/json");
    }
    headers.set("User-Agent", "Stella-Obsidian-Plugin/1.0");
    const enhancedOptions = {
      ...options,
      headers
    };
    return await fetch(url, enhancedOptions);
  }
};

// src/services/cache.ts
var CacheManager = class {
  // 1 hour in milliseconds
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.DEFAULT_TTL = 36e5;
    this.loadFromLocalStorage();
    setInterval(() => this.cleanExpiredEntries(), 3e5);
  }
  set(key, data, ttlMs = this.DEFAULT_TTL) {
    const item = {
      data: JSON.parse(JSON.stringify(data)),
      // Deep clone to avoid references
      timestamp: Date.now(),
      ttl: ttlMs
    };
    this.cache.set(key, item);
    try {
      if (this.getDataSize(data) < 1e5) {
        localStorage.setItem(`stella_cache_${key}`, JSON.stringify(item));
      }
    } catch (error) {
      console.warn("Failed to persist cache item to localStorage:", error);
    }
  }
  get(key) {
    const item = this.cache.get(key);
    if (!item)
      return null;
    const now = Date.now();
    if (now - item.timestamp > item.ttl) {
      this.delete(key);
      return null;
    }
    return item.data;
  }
  delete(key) {
    this.cache.delete(key);
    localStorage.removeItem(`stella_cache_${key}`);
  }
  has(key) {
    const item = this.cache.get(key);
    if (!item)
      return false;
    const now = Date.now();
    if (now - item.timestamp > item.ttl) {
      this.delete(key);
      return false;
    }
    return true;
  }
  clear() {
    this.cache.clear();
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith("stella_cache_")) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach((key) => localStorage.removeItem(key));
  }
  loadFromLocalStorage() {
    try {
      const now = Date.now();
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith("stella_cache_")) {
          const rawData = localStorage.getItem(key);
          if (rawData) {
            const item = JSON.parse(rawData);
            const cacheKey = key.replace("stella_cache_", "");
            if (now - item.timestamp <= item.ttl) {
              this.cache.set(cacheKey, item);
            } else {
              localStorage.removeItem(key);
            }
          }
        }
      }
    } catch (error) {
      console.warn("Failed to load cache from localStorage:", error);
    }
  }
  cleanExpiredEntries() {
    const now = Date.now();
    const expiredKeys = [];
    this.cache.forEach((item, key) => {
      if (now - item.timestamp > item.ttl) {
        expiredKeys.push(key);
      }
    });
    expiredKeys.forEach((key) => this.delete(key));
  }
  getDataSize(data) {
    return new Blob([JSON.stringify(data)]).size;
  }
  // Cache key generators for common use cases
  static modelListKey(provider) {
    return `models_${provider}`;
  }
  static conversationMetaKey() {
    return "conversation_metadata";
  }
  static systemPromptsKey() {
    return "system_prompts_list";
  }
  static apiResponseKey(provider, modelName) {
    return `api_response_${provider}_${modelName}`;
  }
  // Cache invalidation methods
  invalidateProviderCache(provider) {
    const modelKey = CacheManager.modelListKey(provider);
    this.delete(modelKey);
  }
  invalidateAllModels() {
    const providers2 = ["openai", "anthropic", "google", "ollama", "lmstudio"];
    providers2.forEach((provider) => this.invalidateProviderCache(provider));
  }
  invalidateConversationData() {
    this.delete(CacheManager.conversationMetaKey());
  }
  // Get cache statistics
  getCacheStats() {
    let totalSize = 0;
    const providers2 = /* @__PURE__ */ new Set();
    this.cache.forEach((item, key) => {
      totalSize += this.getDataSize(item.data);
      if (key.startsWith("models_")) {
        providers2.add(key.replace("models_", ""));
      }
    });
    return {
      totalItems: this.cache.size,
      totalSize,
      providers: Array.from(providers2)
    };
  }
};

// src/services/logger.ts
var AsyncLogger = class {
  // Force flush at 100 messages
  constructor() {
    this.logQueue = [];
    this.isProcessing = false;
    this.flushInterval = null;
    this.FLUSH_INTERVAL = 1e3;
    // Flush every 1 second
    this.MAX_QUEUE_SIZE = 100;
    this.startPeriodicFlush();
  }
  startPeriodicFlush() {
    this.flushInterval = setInterval(() => {
      this.flushLogs();
    }, this.FLUSH_INTERVAL);
  }
  log(message, data) {
    this.addToQueue("log", message, data);
  }
  warn(message, data) {
    this.addToQueue("warn", message, data);
  }
  error(message, data) {
    this.addToQueue("error", message, data);
  }
  addToQueue(level, message, data) {
    this.logQueue.push({
      level,
      message,
      timestamp: Date.now(),
      data
    });
    if (this.logQueue.length >= this.MAX_QUEUE_SIZE) {
      this.flushLogs();
    }
  }
  async flushLogs() {
    if (this.isProcessing || this.logQueue.length === 0)
      return;
    this.isProcessing = true;
    const logsToFlush = [...this.logQueue];
    this.logQueue = [];
    setTimeout(() => {
      try {
        logsToFlush.forEach((log) => {
          const timestamp = new Date(log.timestamp).toISOString();
          const logMessage = `[${timestamp}] ${log.message}`;
          switch (log.level) {
            case "error":
              console.error(logMessage, log.data || "");
              break;
            case "warn":
              console.warn(logMessage, log.data || "");
              break;
            default:
              console.log(logMessage, log.data || "");
              break;
          }
        });
      } catch (error) {
        console.error("AsyncLogger flush failed:", error);
      } finally {
        this.isProcessing = false;
      }
    }, 0);
  }
  destroy() {
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
    }
    this.flushLogs();
  }
};

// src/services/mcp/client.ts
var MCPClientManager = class {
  constructor(logger) {
    this.servers = /* @__PURE__ */ new Map();
    this.connections = /* @__PURE__ */ new Map();
    this.tools = /* @__PURE__ */ new Map();
    this.resources = /* @__PURE__ */ new Map();
    this.prompts = /* @__PURE__ */ new Map();
    this.messageId = 0;
    this.pendingRequests = /* @__PURE__ */ new Map();
    this.logger = logger;
  }
  // Getters for accessing private properties
  getServers() {
    return this.servers;
  }
  getTools() {
    return this.tools;
  }
  getPrompts() {
    return this.prompts;
  }
  getResources() {
    return this.resources;
  }
  // Public methods to force refresh tools and prompts
  async refreshServerTools(serverId) {
    const server = this.servers.get(serverId);
    console.log(`MCP Debug - refreshServerTools called for ${serverId}, server exists: ${!!server}, connected: ${server == null ? void 0 : server.connected}`);
    if (server && server.connected) {
      console.log(`MCP Debug - Discovering tools for server ${serverId}...`);
      await this.discoverTools(serverId);
      const tools = this.tools.get(serverId) || [];
      console.log(`MCP Debug - After discovery, server ${serverId} has ${tools.length} tools:`, tools.map((t) => t.name));
    }
  }
  async refreshServerPrompts(serverId) {
    const server = this.servers.get(serverId);
    console.log(`MCP Debug - refreshServerPrompts called for ${serverId}, server exists: ${!!server}, connected: ${server == null ? void 0 : server.connected}`);
    if (server && server.connected) {
      console.log(`MCP Debug - Discovering prompts for server ${serverId}...`);
      await this.discoverPrompts(serverId);
      const prompts = this.prompts.get(serverId) || [];
      console.log(`MCP Debug - After discovery, server ${serverId} has ${prompts.length} prompts:`, prompts.map((p) => p.name));
    }
  }
  // Server Management
  async addServer(server) {
    this.logger.log(`Adding MCP server: ${server.name}`);
    this.servers.set(server.id, server);
    return this.connectToServer(server.id);
  }
  async removeServer(serverId) {
    this.logger.log(`Removing MCP server: ${serverId}`);
    await this.disconnectFromServer(serverId);
    this.servers.delete(serverId);
    this.tools.delete(serverId);
    this.resources.delete(serverId);
    this.prompts.delete(serverId);
  }
  async connectToServer(serverId) {
    const server = this.servers.get(serverId);
    if (!server) {
      this.logger.error(`Server not found: ${serverId}`);
      return false;
    }
    try {
      if (server.transport === "http") {
        return await this.connectHTTP(server);
      } else if (server.transport === "stdio") {
        return await this.connectStdio(server);
      }
    } catch (error) {
      this.logger.error(`Failed to connect to server ${serverId}:`, error);
      server.connected = false;
      return false;
    }
    return false;
  }
  async connectHTTP(server) {
    if (!server.endpoint) {
      this.logger.error(`HTTP server ${server.id} missing endpoint`);
      return false;
    }
    try {
      const ws = new WebSocket(server.endpoint);
      ws.onopen = () => {
        this.logger.log(`Connected to MCP server: ${server.name}`);
        server.connected = true;
        this.initializeServerCapabilities(server.id);
      };
      ws.onmessage = (event) => {
        this.handleMessage(server.id, JSON.parse(event.data));
      };
      ws.onclose = () => {
        this.logger.log(`Disconnected from MCP server: ${server.name}`);
        server.connected = false;
      };
      ws.onerror = (error) => {
        this.logger.error(`WebSocket error for server ${server.name}:`, error);
        server.connected = false;
      };
      this.connections.set(server.id, ws);
      return true;
    } catch (error) {
      this.logger.error(`HTTP connection failed for server ${server.id}:`, error);
      return false;
    }
  }
  /**
   * Fix command for Windows compatibility
   */
  fixWindowsCommand(command) {
    if (process.platform !== "win32") {
      return command;
    }
    const windowsCommands = ["npm", "npx", "yarn", "pnpm", "node"];
    const baseCommand = command.split(" ")[0];
    if (windowsCommands.includes(baseCommand) && !baseCommand.endsWith(".cmd")) {
      return command.replace(baseCommand, `${baseCommand}.cmd`);
    }
    return command;
  }
  async connectStdio(server) {
    if (!server.command) {
      this.logger.error(`STDIO server ${server.id} missing command`);
      return false;
    }
    try {
      const { spawn } = require("child_process");
      const args = server.args || [];
      const env = {
        ...process.env,
        ...server.env || {}
      };
      const command = this.fixWindowsCommand(server.command);
      this.logger.log(`Starting STDIO MCP server: ${command} ${args.join(" ")}`);
      const spawnOptions = {
        stdio: ["pipe", "pipe", "pipe"],
        env
      };
      if (process.platform === "win32" && command.endsWith(".cmd")) {
        spawnOptions.shell = true;
      }
      const childProcess = spawn(command, args, spawnOptions);
      childProcess.on("error", (error) => {
        this.logger.error(`STDIO server ${server.name} process error:`, error);
        server.connected = false;
      });
      childProcess.on("exit", (code, signal) => {
        this.logger.log(`STDIO server ${server.name} exited with code ${code}, signal ${signal}`);
        server.connected = false;
      });
      childProcess.stderr.on("data", (data) => {
        this.logger.warn(`STDIO server ${server.name} stderr: ${data.toString()}`);
      });
      let buffer = "";
      childProcess.stdout.on("data", (data) => {
        buffer += data.toString();
        let lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.trim()) {
            try {
              const message = JSON.parse(line.trim());
              this.handleMessage(server.id, message);
            } catch (error) {
              this.logger.error(`Failed to parse JSON from ${server.name}:`, error);
              this.logger.error(`Raw line: ${line}`);
            }
          }
        }
      });
      this.connections.set(server.id, childProcess);
      server.connected = true;
      this.logger.log(`Connected to STDIO MCP server: ${server.name}`);
      await this.initializeServerCapabilities(server.id);
      return true;
    } catch (error) {
      this.logger.error(`STDIO connection failed for server ${server.id}:`, error);
      return false;
    }
  }
  async disconnectFromServer(serverId) {
    const connection = this.connections.get(serverId);
    if (connection) {
      if (connection instanceof WebSocket) {
        connection.close();
      } else if (connection && connection.kill) {
        connection.kill("SIGTERM");
      }
      this.connections.delete(serverId);
    }
    const server = this.servers.get(serverId);
    if (server) {
      server.connected = false;
    }
  }
  // Protocol Message Handling
  async sendMessage(serverId, message) {
    try {
      console.log(`MCP sendMessage: Sending to server ${serverId}:`, message);
      const connection = this.connections.get(serverId);
      if (!connection) {
        throw new Error(`No connection to server: ${serverId}`);
      }
      if (message.method) {
        message.id = ++this.messageId;
        console.log(`MCP sendMessage: Added message ID: ${message.id}`);
      }
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          if (this.pendingRequests && this.pendingRequests.has(message.id)) {
            this.pendingRequests.delete(message.id);
          }
          reject(new Error("MCP request timeout"));
        }, 3e4);
        const responseHandler = (response) => {
          try {
            console.log(`MCP sendMessage: Got response for message ${message.id}:`, response);
            clearTimeout(timeout);
            if (this.pendingRequests && this.pendingRequests.has(message.id)) {
              this.pendingRequests.delete(message.id);
            }
            if (response && response.error) {
              reject(new Error(`MCP Error: ${response.error.message}`));
            } else {
              resolve(response ? response.result : null);
            }
          } catch (handlerError) {
            console.error("MCP sendMessage: Error in response handler:", handlerError);
            reject(handlerError);
          }
        };
        if (!this.pendingRequests) {
          this.pendingRequests = /* @__PURE__ */ new Map();
        }
        this.pendingRequests.set(message.id, responseHandler);
        if (connection instanceof WebSocket) {
          connection.send(JSON.stringify(message));
        } else if (connection && connection.stdin) {
          connection.stdin.write(JSON.stringify(message) + "\n");
        }
      });
    } catch (sendError) {
      console.error("MCP sendMessage: Error in sendMessage:", sendError);
      throw sendError;
    }
  }
  handleMessage(serverId, message) {
    try {
      this.logger.log(`Received MCP message from ${serverId}:`, message);
      if (!message) {
        console.warn(`Received null/undefined message from server ${serverId}`);
        return;
      }
      if (message.method) {
        this.handleServerRequest(serverId, message);
      } else if (message.result !== void 0 || message.error !== void 0) {
        this.handleServerResponse(serverId, message);
      } else {
        console.log(`Unknown message type from server ${serverId}:`, message);
      }
    } catch (error) {
      console.error(`Error handling message from server ${serverId}:`, error, message);
    }
  }
  handleServerRequest(serverId, message) {
    this.logger.log(`Server ${serverId} sent request: ${message.method}`);
  }
  handleServerResponse(serverId, message) {
    try {
      const messageId = message == null ? void 0 : message.id;
      this.logger.log(`Server ${serverId} sent response to request ${messageId || "unknown"}`);
      if (messageId && this.pendingRequests && this.pendingRequests.has(messageId)) {
        const responseHandler = this.pendingRequests.get(messageId);
        if (responseHandler && typeof responseHandler === "function") {
          responseHandler(message);
        }
        this.pendingRequests.delete(messageId);
      } else {
        console.log(`No pending request handler found for message ID: ${messageId}`);
      }
    } catch (error) {
      console.error(`Error handling server response from ${serverId}:`, error, message);
    }
  }
  // Server Initialization
  async initializeServerCapabilities(serverId) {
    try {
      await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "initialize",
        params: {
          protocolVersion: "2024-11-05",
          capabilities: {
            roots: { listChanged: true },
            sampling: {}
          },
          clientInfo: {
            name: "stella-obsidian-plugin",
            version: "1.0.0"
          }
        }
      });
      await this.discoverTools(serverId);
      await this.discoverResources(serverId);
      await this.discoverPrompts(serverId);
    } catch (error) {
      this.logger.error(`Failed to initialize server ${serverId}:`, error);
    }
  }
  // Tool Discovery and Execution
  async discoverTools(serverId) {
    try {
      console.log(`MCP Debug - Discovering tools for server ${serverId}`);
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "tools/list"
      });
      console.log(`MCP Debug - Tools/list result for ${serverId}:`, result);
      if (result == null ? void 0 : result.tools) {
        const tools = result.tools.map((tool) => ({
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema,
          serverId
        }));
        console.log(`MCP Debug - Mapped ${tools.length} tools for server ${serverId}:`, tools.map((t) => t.name));
        this.tools.set(serverId, tools);
        this.logger.log(`Discovered ${tools.length} tools for server ${serverId}`);
      }
    } catch (error) {
      this.logger.error(`Failed to discover tools for server ${serverId}:`, error);
    }
  }
  async executeTool(serverId, toolName, arguments_) {
    try {
      console.log(`MCP executeTool: Starting execution of ${toolName} on server ${serverId}`);
      console.log(`MCP executeTool: Arguments:`, arguments_);
      const safeArguments = arguments_ || {};
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "tools/call",
        params: {
          name: toolName,
          arguments: safeArguments
        }
      });
      console.log(`MCP executeTool: Got result for ${toolName}:`, result);
      this.logger.log(`Executed tool ${toolName} on server ${serverId}`);
      return result;
    } catch (error) {
      console.error(`MCP executeTool: Failed to execute tool ${toolName} on server ${serverId}:`, error);
      this.logger.error(`Failed to execute tool ${toolName} on server ${serverId}:`, error);
      throw error;
    }
  }
  // Resource Discovery and Access
  async discoverResources(serverId) {
    try {
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "resources/list"
      });
      if (result == null ? void 0 : result.resources) {
        const resources = result.resources.map((resource) => ({
          uri: resource.uri,
          name: resource.name,
          description: resource.description,
          mimeType: resource.mimeType,
          serverId
        }));
        this.resources.set(serverId, resources);
        this.logger.log(`Discovered ${resources.length} resources for server ${serverId}`);
      }
    } catch (error) {
      this.logger.error(`Failed to discover resources for server ${serverId}:`, error);
    }
  }
  async getResource(serverId, uri) {
    try {
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "resources/read",
        params: { uri }
      });
      this.logger.log(`Retrieved resource ${uri} from server ${serverId}`);
      return result;
    } catch (error) {
      this.logger.error(`Failed to get resource ${uri} from server ${serverId}:`, error);
      throw error;
    }
  }
  // Prompt Discovery and Usage
  async discoverPrompts(serverId) {
    try {
      console.log(`MCP Debug - Discovering prompts for server ${serverId}`);
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "prompts/list"
      });
      console.log(`MCP Debug - Prompts/list result for ${serverId}:`, result);
      if (result == null ? void 0 : result.prompts) {
        const prompts = result.prompts.map((prompt) => ({
          name: prompt.name,
          description: prompt.description,
          arguments: prompt.arguments,
          serverId
        }));
        console.log(`MCP Debug - Mapped ${prompts.length} prompts for server ${serverId}:`, prompts.map((p) => p.name));
        this.prompts.set(serverId, prompts);
        this.logger.log(`Discovered ${prompts.length} prompts for server ${serverId}`);
      }
    } catch (error) {
      this.logger.error(`Failed to discover prompts for server ${serverId}:`, error);
    }
  }
  async getPrompt(serverId, promptName, arguments_) {
    try {
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "prompts/get",
        params: {
          name: promptName,
          arguments: arguments_
        }
      });
      this.logger.log(`Retrieved prompt ${promptName} from server ${serverId}`);
      return result;
    } catch (error) {
      this.logger.error(`Failed to get prompt ${promptName} from server ${serverId}:`, error);
      throw error;
    }
  }
  // Public API for UI
  getConnectedServers() {
    return Array.from(this.servers.values()).filter((server) => server.connected);
  }
  getAllTools() {
    const allTools = [];
    for (const tools of this.tools.values()) {
      allTools.push(...tools);
    }
    return allTools;
  }
  getAllResources() {
    const allResources = [];
    for (const resources of this.resources.values()) {
      allResources.push(...resources);
    }
    return allResources;
  }
  getAllPrompts() {
    const allPrompts = [];
    for (const prompts of this.prompts.values()) {
      allPrompts.push(...prompts);
    }
    return allPrompts;
  }
  destroy() {
    this.logger.log("Destroying MCP Client Manager");
    for (const serverId of this.servers.keys()) {
      this.disconnectFromServer(serverId);
    }
    this.servers.clear();
    this.connections.clear();
    this.tools.clear();
    this.resources.clear();
    this.prompts.clear();
    this.pendingRequests.clear();
  }
};

// src/views/modals/base.ts
var import_obsidian = require("obsidian");
var StellaModal = class extends import_obsidian.Modal {
  constructor(app, config) {
    super(app);
    this.config = config;
  }
  onOpen() {
    this.titleEl.setText(this.config.title);
    this.modalEl.style.width = this.config.width || "400px";
    this.modalEl.style.height = this.config.height || "60vh";
    this.modalEl.style.minWidth = this.config.width || "400px";
    this.contentEl.empty();
    this.buildContent();
  }
  // Helper to create a two-panel layout (list + preview)
  createTwoPanelLayout() {
    const mainContainer = this.contentEl.createDiv({ cls: "stella-modal-container" });
    const leftPanel = mainContainer.createDiv({ cls: "stella-modal-left-panel" });
    const rightPanel = mainContainer.createDiv({ cls: "stella-modal-right-panel" });
    const previewContainer = rightPanel.createDiv({ cls: "stella-preview-container" });
    const previewContent = previewContainer.createDiv({ cls: "stella-preview-content" });
    return { mainContainer, leftPanel, rightPanel, previewContainer, previewContent };
  }
  // Helper to fix list container height
  fixListHeight(listEl, headerEl) {
    setTimeout(() => {
      const modalHeight = this.modalEl.clientHeight;
      const titleHeight = this.titleEl.offsetHeight;
      const headerHeight = (headerEl == null ? void 0 : headerEl.offsetHeight) || 0;
      const padding = 40;
      const availableHeight = modalHeight - titleHeight - headerHeight - padding;
      listEl.style.height = `${availableHeight}px`;
      listEl.style.maxHeight = `${availableHeight}px`;
      listEl.style.overflow = "auto";
    }, 50);
  }
  // Helper to setup keyboard navigation
  setupKeyboardNavigation(items, onSelect, options) {
    let selectedIndex = 0;
    const updateSelection = (newIndex) => {
      var _a, _b, _c;
      if (newIndex < 0 || newIndex >= items.length)
        return;
      (_a = items[selectedIndex]) == null ? void 0 : _a.classList.remove("selected");
      selectedIndex = newIndex;
      (_b = items[selectedIndex]) == null ? void 0 : _b.classList.add("selected");
      (_c = items[selectedIndex]) == null ? void 0 : _c.scrollIntoView({ block: "nearest" });
    };
    if (items.length > 0) {
      items[0].classList.add("selected");
    }
    this.modalEl.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          updateSelection(selectedIndex + 1);
          break;
        case "ArrowUp":
          e.preventDefault();
          updateSelection(selectedIndex - 1);
          break;
        case "ArrowRight":
          if (options == null ? void 0 : options.onPreview) {
            e.preventDefault();
            options.onPreview(selectedIndex);
          }
          break;
        case "Enter":
          e.preventDefault();
          onSelect(selectedIndex);
          break;
        case "Escape":
          e.preventDefault();
          if (options == null ? void 0 : options.onEscape) {
            options.onEscape();
          } else {
            this.close();
          }
          break;
      }
    });
  }
};

// src/views/modals/file-selector.ts
var FileSelectorModal = class extends StellaModal {
  constructor(app, config, callbacks) {
    super(app, { title: config.title });
    this.files = [];
    this.selectedIndex = 0;
    this.previewVisible = false;
    this.directoryPath = config.directoryPath;
    this.fileExtension = config.fileExtension || ".md";
    this.callbacks = callbacks;
    this.emptyMessage = config.emptyMessage || `No ${this.fileExtension} files found.`;
    this.notFoundMessage = config.notFoundMessage || "Directory not found.";
    this.previewHint = config.previewHint || "Select a file and press \u2192 to preview";
  }
  buildContent() {
    if (!this.directoryPath) {
      this.contentEl.createEl("p", {
        text: "Directory path not configured. Please check settings."
      });
      return;
    }
    try {
      const fs = require("fs");
      const path = require("path");
      if (!fs.existsSync(this.directoryPath)) {
        this.contentEl.createEl("p", {
          text: `${this.notFoundMessage}: ${this.directoryPath}`
        });
        return;
      }
      this.files = fs.readdirSync(this.directoryPath).filter((file) => file.endsWith(this.fileExtension)).sort();
      if (this.files.length === 0) {
        this.contentEl.createEl("p", { text: this.emptyMessage });
        return;
      }
      this.buildFileList();
    } catch (error) {
      this.contentEl.createEl("p", {
        text: `Error reading directory: ${error}`
      });
    }
  }
  buildFileList() {
    const fs = require("fs");
    const path = require("path");
    const { leftPanel, previewContent } = this.createTwoPanelLayout();
    previewContent.textContent = this.previewHint;
    const fileList = leftPanel.createDiv({ cls: "stella-system-prompts-list" });
    const items = [];
    this.files.forEach((filename, index) => {
      const fileItem = fileList.createDiv({ cls: "stella-system-prompt-item" });
      items.push(fileItem);
      const titleEl = fileItem.createDiv({ cls: "stella-system-prompt-title" });
      titleEl.textContent = filename.replace(this.fileExtension, "");
      fileItem.addEventListener("click", () => {
        this.selectFile(index);
      });
      fileItem.addEventListener("dblclick", () => {
        this.confirmSelection(index);
      });
    });
    this.fixListHeight(fileList);
    this.setupKeyboardNavigation(
      items,
      (index) => this.confirmSelection(index),
      {
        onPreview: (index) => this.showPreview(index, previewContent),
        onEscape: () => {
          if (this.previewVisible) {
            this.hidePreview(previewContent);
          } else {
            this.close();
          }
        }
      }
    );
  }
  selectFile(index) {
    var _a, _b;
    const items = this.contentEl.querySelectorAll(".stella-system-prompt-item");
    (_a = items[this.selectedIndex]) == null ? void 0 : _a.classList.remove("selected");
    this.selectedIndex = index;
    (_b = items[this.selectedIndex]) == null ? void 0 : _b.classList.add("selected");
  }
  async confirmSelection(index) {
    var _a, _b;
    const path = require("path");
    const filename = this.files[index];
    const filePath = path.join(this.directoryPath, filename);
    await this.callbacks.onSelect(filePath, filename);
    this.close();
    (_b = (_a = this.callbacks).onClose) == null ? void 0 : _b.call(_a);
  }
  showPreview(index, previewContent) {
    const fs = require("fs");
    const path = require("path");
    try {
      const filename = this.files[index];
      const filePath = path.join(this.directoryPath, filename);
      const content = fs.readFileSync(filePath, "utf-8");
      previewContent.empty();
      previewContent.createEl("h4", { text: filename.replace(this.fileExtension, "") });
      previewContent.createEl("pre", {
        cls: "stella-preview-text",
        text: content.substring(0, 1e3) + (content.length > 1e3 ? "..." : "")
      });
      this.previewVisible = true;
      this.modalEl.style.width = "700px";
    } catch (error) {
      previewContent.textContent = `Error loading preview: ${error}`;
    }
  }
  hidePreview(previewContent) {
    previewContent.textContent = this.previewHint;
    this.previewVisible = false;
    this.modalEl.style.width = "400px";
  }
};
function createSystemPromptModal(app, directoryPath, callbacks) {
  return new FileSelectorModal(app, {
    title: "Select System Prompt",
    directoryPath,
    fileExtension: ".md",
    emptyMessage: "No .md files found in SystemPrompts directory.",
    notFoundMessage: "System prompts directory not found",
    previewHint: "Select a system prompt and press \u2192 to preview"
  }, callbacks);
}
function createMentalModelModal(app, directoryPath, callbacks) {
  return new FileSelectorModal(app, {
    title: "Select Mental Model",
    directoryPath,
    fileExtension: ".md",
    emptyMessage: "No .md files found in MentalModels directory.",
    notFoundMessage: "Mental models directory not found",
    previewHint: "Select a mental model and press \u2192 to preview"
  }, callbacks);
}

// src/views/modals/note-selector.ts
var import_obsidian2 = require("obsidian");
var NoteSelectorModal = class extends StellaModal {
  constructor(app, callbacks) {
    super(app, { title: "Add Note Context" });
    this.files = [];
    this.filteredFiles = [];
    this.selectedIndex = 0;
    this.previewVisible = false;
    this.notesContainer = null;
    this.leftPanel = null;
    this.rightPanel = null;
    this.previewContent = null;
    this.searchInput = null;
    this.callbacks = callbacks;
  }
  buildContent() {
    this.searchInput = this.contentEl.createEl("input", {
      type: "text",
      placeholder: "Search notes...",
      cls: "stella-note-search"
    });
    const mainContainer = this.contentEl.createDiv({ cls: "stella-modal-container" });
    this.leftPanel = mainContainer.createDiv({ cls: "stella-modal-left-panel" });
    this.rightPanel = mainContainer.createDiv({ cls: "stella-modal-right-panel" });
    const previewContainer = this.rightPanel.createDiv({ cls: "stella-preview-container" });
    this.previewContent = previewContainer.createDiv({ cls: "stella-preview-content" });
    this.previewContent.textContent = "Select a note and press \u2192 to preview";
    this.notesContainer = this.leftPanel.createDiv({ cls: "stella-notes-container" });
    this.files = this.app.vault.getMarkdownFiles();
    this.filteredFiles = this.files;
    this.renderFiles();
    this.hidePreview();
    this.searchInput.addEventListener("input", (e) => {
      const query = e.target.value.toLowerCase();
      if (query === "") {
        this.filteredFiles = this.files;
      } else {
        this.filteredFiles = this.files.filter(
          (file) => file.basename.toLowerCase().includes(query) || file.path.toLowerCase().includes(query)
        );
      }
      this.selectedIndex = 0;
      this.renderFiles();
    });
    this.modalEl.addEventListener("keydown", (e) => this.handleKeydown(e));
    setTimeout(() => {
      var _a;
      return (_a = this.searchInput) == null ? void 0 : _a.focus();
    }, 50);
  }
  renderFiles() {
    if (!this.notesContainer)
      return;
    this.notesContainer.empty();
    if (this.selectedIndex >= this.filteredFiles.length) {
      this.selectedIndex = Math.max(0, this.filteredFiles.length - 1);
    }
    this.filteredFiles.slice(0, 50).forEach((file, index) => {
      const noteItem = this.notesContainer.createDiv({ cls: "stella-note-item" });
      const titleEl = noteItem.createDiv({ cls: "stella-note-title" });
      titleEl.textContent = file.basename;
      const pathEl = noteItem.createDiv({ cls: "stella-note-path" });
      pathEl.textContent = file.path;
      noteItem.addEventListener("click", () => {
        this.selectedIndex = index;
        this.updateSelection();
      });
      noteItem.addEventListener("dblclick", () => {
        this.confirmSelection();
      });
      if (index === this.selectedIndex) {
        noteItem.classList.add("selected");
      }
    });
    this.fixNotesHeight();
  }
  updateSelection() {
    var _a;
    const items = (_a = this.notesContainer) == null ? void 0 : _a.querySelectorAll(".stella-note-item");
    items == null ? void 0 : items.forEach((item, i) => {
      item.classList.toggle("selected", i === this.selectedIndex);
    });
  }
  async confirmSelection() {
    var _a, _b;
    const file = this.filteredFiles[this.selectedIndex];
    if (!file)
      return;
    try {
      const content = await this.app.vault.read(file);
      this.callbacks.onSelect(file.basename, content);
      this.close();
      (_b = (_a = this.callbacks).onClose) == null ? void 0 : _b.call(_a);
    } catch (error) {
      console.error("Error reading file:", error);
    }
  }
  async showPreview() {
    const file = this.filteredFiles[this.selectedIndex];
    if (!file || !this.previewContent || !this.leftPanel || !this.rightPanel)
      return;
    try {
      const content = await this.app.vault.read(file);
      this.previewContent.empty();
      await import_obsidian2.MarkdownRenderer.render(
        this.app,
        content.substring(0, 2e3) + (content.length > 2e3 ? "\n\n..." : ""),
        this.previewContent,
        file.path,
        this
      );
      this.rightPanel.style.display = "block";
      this.previewVisible = true;
      this.modalEl.style.width = "60vw";
      this.modalEl.style.maxWidth = "980px";
      this.leftPanel.style.width = "50%";
      this.rightPanel.style.width = "50%";
      this.fixNotesHeight();
    } catch (error) {
      this.previewContent.textContent = `Error loading preview: ${error.message}`;
    }
  }
  hidePreview() {
    if (!this.leftPanel || !this.rightPanel || !this.previewContent)
      return;
    this.rightPanel.style.display = "none";
    this.leftPanel.style.width = "100%";
    this.previewVisible = false;
    this.modalEl.style.width = "400px";
    this.modalEl.style.maxWidth = "none";
    this.previewContent.textContent = "Select a note and press \u2192 to preview";
    this.fixNotesHeight();
  }
  fixNotesHeight() {
    if (!this.notesContainer || !this.searchInput)
      return;
    setTimeout(() => {
      const modalHeight = this.modalEl.clientHeight;
      const searchInputHeight = this.searchInput.offsetHeight + 16;
      const titleHeight = this.titleEl.offsetHeight;
      const padding = 40;
      const availableHeight = modalHeight - titleHeight - searchInputHeight - padding;
      this.notesContainer.style.height = `${availableHeight}px`;
      this.notesContainer.style.maxHeight = `${availableHeight}px`;
      this.notesContainer.style.overflow = "auto";
    }, 50);
  }
  handleKeydown(e) {
    if (e.target === this.searchInput && e.key !== "ArrowDown" && e.key !== "ArrowUp" && e.key !== "Enter" && e.key !== "Escape") {
      return;
    }
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        if (this.selectedIndex < Math.min(this.filteredFiles.length - 1, 49)) {
          this.selectedIndex++;
          this.updateSelection();
          this.scrollToSelected();
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (this.selectedIndex > 0) {
          this.selectedIndex--;
          this.updateSelection();
          this.scrollToSelected();
        }
        break;
      case "ArrowRight":
        e.preventDefault();
        this.showPreview();
        break;
      case "ArrowLeft":
        e.preventDefault();
        if (this.previewVisible) {
          this.hidePreview();
        }
        break;
      case "Enter":
        e.preventDefault();
        this.confirmSelection();
        break;
      case "Escape":
        e.preventDefault();
        if (this.previewVisible) {
          this.hidePreview();
        } else {
          this.close();
        }
        break;
    }
  }
  scrollToSelected() {
    var _a, _b;
    const items = (_a = this.notesContainer) == null ? void 0 : _a.querySelectorAll(".stella-note-item");
    (_b = items == null ? void 0 : items[this.selectedIndex]) == null ? void 0 : _b.scrollIntoView({ block: "nearest" });
  }
};

// src/views/modals/conversation-history.ts
var ConversationHistoryModal = class extends StellaModal {
  constructor(app, config, callbacks) {
    super(app, { title: "Conversations" });
    this.ITEMS_PER_PAGE = 20;
    this.currentPage = 0;
    this.selectedIndex = 0;
    this.previewVisible = false;
    this.leftPanel = null;
    this.rightPanel = null;
    this.previewContent = null;
    this.conversationsContainer = null;
    this.headerContainer = null;
    this.conversations = config.conversations;
    this.currentConversationId = config.currentConversationId;
    this.callbacks = callbacks;
  }
  buildContent() {
    if (this.conversations.length === 0) {
      this.contentEl.createEl("p", {
        text: "No conversations yet. Start chatting to create your first conversation."
      });
      return;
    }
    const { leftPanel, rightPanel, previewContent } = this.createTwoPanelLayout();
    this.leftPanel = leftPanel;
    this.rightPanel = rightPanel;
    this.previewContent = previewContent;
    previewContent.textContent = "Select a conversation and press \u2192 to preview";
    const totalPages = Math.ceil(this.conversations.length / this.ITEMS_PER_PAGE);
    this.headerContainer = leftPanel.createDiv({ cls: "stella-pagination-header" });
    if (totalPages > 1) {
      this.renderPaginationHeader();
    }
    this.conversationsContainer = leftPanel.createDiv({ cls: "stella-conversations-container" });
    this.renderConversationPage();
    this.hidePreview();
    this.modalEl.addEventListener("keydown", (e) => this.handleKeydown(e));
  }
  renderPaginationHeader() {
    if (!this.headerContainer)
      return;
    this.headerContainer.empty();
    const totalPages = Math.ceil(this.conversations.length / this.ITEMS_PER_PAGE);
    this.headerContainer.createDiv({
      cls: "stella-page-info",
      text: `Page ${this.currentPage + 1} of ${totalPages} (${this.conversations.length} conversations)`
    });
    const paginationControls = this.headerContainer.createDiv({ cls: "stella-pagination-controls" });
    const prevBtn = paginationControls.createEl("button", {
      cls: "stella-pagination-btn",
      text: "\u2190 Prev"
    });
    prevBtn.disabled = this.currentPage === 0;
    prevBtn.addEventListener("click", () => this.prevPage());
    const nextBtn = paginationControls.createEl("button", {
      cls: "stella-pagination-btn",
      text: "Next \u2192"
    });
    nextBtn.disabled = this.currentPage === totalPages - 1;
    nextBtn.addEventListener("click", () => this.nextPage());
  }
  renderConversationPage() {
    if (!this.conversationsContainer)
      return;
    this.conversationsContainer.empty();
    const startIndex = this.currentPage * this.ITEMS_PER_PAGE;
    const endIndex = Math.min(startIndex + this.ITEMS_PER_PAGE, this.conversations.length);
    const pageConversations = this.conversations.slice(startIndex, endIndex);
    pageConversations.forEach((conversation, relativeIndex) => {
      const convEl = this.conversationsContainer.createDiv({ cls: "stella-conversation-item" });
      if (conversation.id === this.currentConversationId) {
        convEl.classList.add("stella-conversation-current");
      }
      if (relativeIndex === this.selectedIndex) {
        convEl.classList.add("selected");
      }
      const titleEl = convEl.createDiv({ cls: "stella-conversation-title" });
      titleEl.textContent = conversation.title;
      const metaEl = convEl.createDiv({ cls: "stella-conversation-meta" });
      const messageCount = conversation.messages.length;
      const lastUpdate = new Date(conversation.updatedAt).toLocaleDateString();
      metaEl.textContent = `${messageCount} messages \u2022 Last updated ${lastUpdate}`;
      const deleteBtn = convEl.createEl("div", {
        cls: "stella-conversation-delete",
        attr: { title: "Delete conversation" }
      });
      deleteBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3,6 5,6 21,6"></polyline><path d="M8,6V4c0-1,1-2,2-2h4c1,0,2-1,2-2v2M10,11v6M14,11v6"></path><path d="M5,6l1,14c0,1,1,2,2,2h8c1,0,2-1,2-2l1-14"></path></svg>';
      deleteBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.callbacks.onDelete(conversation.id);
        this.conversations = this.conversations.filter((c) => c.id !== conversation.id);
        if (this.selectedIndex >= pageConversations.length - 1) {
          this.selectedIndex = Math.max(0, this.selectedIndex - 1);
        }
        this.renderConversationPage();
        this.renderPaginationHeader();
      });
      convEl.addEventListener("click", (e) => {
        if (!e.target.closest(".stella-conversation-delete")) {
          this.callbacks.onSelect(conversation.id);
          this.close();
        }
      });
    });
    this.fixConversationsHeight();
  }
  prevPage() {
    if (this.currentPage > 0) {
      this.currentPage--;
      this.selectedIndex = 0;
      this.renderConversationPage();
      this.renderPaginationHeader();
    }
  }
  nextPage() {
    const totalPages = Math.ceil(this.conversations.length / this.ITEMS_PER_PAGE);
    if (this.currentPage < totalPages - 1) {
      this.currentPage++;
      this.selectedIndex = 0;
      this.renderConversationPage();
      this.renderPaginationHeader();
    }
  }
  showPreview() {
    const startIndex = this.currentPage * this.ITEMS_PER_PAGE;
    const conversation = this.conversations[startIndex + this.selectedIndex];
    if (!conversation || !this.previewContent || !this.leftPanel || !this.rightPanel)
      return;
    this.previewContent.empty();
    const summaryDiv = this.previewContent.createDiv({ cls: "stella-conversation-summary" });
    const infoDiv = summaryDiv.createDiv({ cls: "stella-conversation-info" });
    infoDiv.innerHTML = `
            <div><strong>Messages:</strong> ${conversation.messages.length}</div>
            <div><strong>Created:</strong> ${new Date(conversation.createdAt).toLocaleString()}</div>
            <div><strong>Updated:</strong> ${new Date(conversation.updatedAt).toLocaleString()}</div>
        `;
    if (conversation.systemPrompt) {
      const sysPromptDiv = summaryDiv.createDiv({ cls: "stella-system-prompt-preview" });
      sysPromptDiv.createEl("h4", { text: "System Prompt:" });
      const promptContent = sysPromptDiv.createDiv({ cls: "stella-prompt-content" });
      promptContent.textContent = conversation.systemPrompt.substring(0, 200) + (conversation.systemPrompt.length > 200 ? "..." : "");
    }
    if (conversation.messages.length > 0) {
      const messagesDiv = summaryDiv.createDiv({ cls: "stella-messages-preview" });
      messagesDiv.createEl("h4", { text: "Messages Preview:" });
      conversation.messages.slice(0, 4).forEach((msg) => {
        const msgDiv = messagesDiv.createDiv({
          cls: `stella-preview-message stella-preview-${msg.role}`
        });
        const roleSpan = msgDiv.createEl("span", { cls: "stella-preview-role" });
        roleSpan.textContent = msg.role === "user" ? "\u{1F464}" : "\u{1F916}";
        const contentDiv = msgDiv.createDiv({ cls: "stella-preview-content" });
        contentDiv.textContent = msg.content.length > 150 ? msg.content.substring(0, 150) + "..." : msg.content;
      });
      if (conversation.messages.length > 4) {
        const moreDiv = messagesDiv.createDiv({ cls: "stella-preview-more" });
        moreDiv.textContent = `... and ${conversation.messages.length - 4} more messages`;
      }
    }
    this.rightPanel.style.display = "block";
    this.previewVisible = true;
    this.modalEl.style.width = "60vw";
    this.modalEl.style.maxWidth = "980px";
    this.leftPanel.style.width = "50%";
    this.rightPanel.style.width = "50%";
    this.fixConversationsHeight();
  }
  hidePreview() {
    if (!this.leftPanel || !this.rightPanel)
      return;
    this.rightPanel.style.display = "none";
    this.leftPanel.style.width = "100%";
    this.previewVisible = false;
    this.modalEl.style.width = "400px";
    this.modalEl.style.maxWidth = "none";
    this.fixConversationsHeight();
  }
  fixConversationsHeight() {
    if (!this.conversationsContainer || !this.headerContainer)
      return;
    setTimeout(() => {
      var _a;
      const modalHeight = this.modalEl.clientHeight;
      const titleHeight = this.titleEl.offsetHeight;
      const headerHeight = ((_a = this.headerContainer) == null ? void 0 : _a.offsetHeight) || 0;
      const padding = 40;
      const availableHeight = modalHeight - titleHeight - headerHeight - padding;
      this.conversationsContainer.style.height = `${availableHeight}px`;
      this.conversationsContainer.style.maxHeight = `${availableHeight}px`;
      this.conversationsContainer.style.overflow = "auto";
    }, 50);
  }
  updateSelection() {
    var _a;
    const items = (_a = this.conversationsContainer) == null ? void 0 : _a.querySelectorAll(".stella-conversation-item");
    items == null ? void 0 : items.forEach((item, i) => {
      item.classList.toggle("selected", i === this.selectedIndex);
    });
  }
  handleKeydown(e) {
    const startIndex = this.currentPage * this.ITEMS_PER_PAGE;
    const pageSize = Math.min(this.ITEMS_PER_PAGE, this.conversations.length - startIndex);
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        if (this.selectedIndex < pageSize - 1) {
          this.selectedIndex++;
          this.updateSelection();
          this.scrollToSelected();
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (this.selectedIndex > 0) {
          this.selectedIndex--;
          this.updateSelection();
          this.scrollToSelected();
        }
        break;
      case "ArrowRight":
        e.preventDefault();
        this.showPreview();
        break;
      case "ArrowLeft":
        e.preventDefault();
        if (this.previewVisible) {
          this.hidePreview();
        }
        break;
      case "Enter":
        e.preventDefault();
        const conversation = this.conversations[startIndex + this.selectedIndex];
        if (conversation) {
          this.callbacks.onSelect(conversation.id);
          this.close();
        }
        break;
      case "Escape":
        e.preventDefault();
        if (this.previewVisible) {
          this.hidePreview();
        } else {
          this.close();
        }
        break;
      case "PageDown":
        e.preventDefault();
        this.nextPage();
        break;
      case "PageUp":
        e.preventDefault();
        this.prevPage();
        break;
    }
  }
  scrollToSelected() {
    var _a, _b;
    const items = (_a = this.conversationsContainer) == null ? void 0 : _a.querySelectorAll(".stella-conversation-item");
    (_b = items == null ? void 0 : items[this.selectedIndex]) == null ? void 0 : _b.scrollIntoView({ block: "nearest" });
  }
};

// src/views/modals/suggest-modals.ts
var import_obsidian3 = require("obsidian");
var FolderSuggestModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app, folders, onChoose) {
    super(app);
    this.folders = folders.filter((f) => f instanceof import_obsidian3.TFolder);
    this.onChoose = onChoose;
    this.setPlaceholder("Type to search folders...");
  }
  getItems() {
    return this.folders;
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
};
var FileSuggestModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app, files, onChoose) {
    super(app);
    this.files = files;
    this.onChoose = onChoose;
    this.setPlaceholder("Type to search files...");
  }
  getItems() {
    return this.files;
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
};

// src/providers/types.ts
function buildMessagesArray(chatHistory, currentMessage, systemMessage) {
  const messages = [];
  if (systemMessage) {
    messages.push({ role: "system", content: systemMessage });
  }
  chatHistory.forEach((msg) => {
    messages.push({
      role: msg.role,
      content: msg.content
    });
  });
  messages.push({ role: "user", content: currentMessage });
  return messages;
}

// src/providers/openai.ts
var OpenAIProvider = class {
  constructor() {
    this.name = "openai";
  }
  isConfigured(settings) {
    return !!settings.openaiApiKey;
  }
  async call(context) {
    const { settings, messages } = context;
    if (!settings.openaiApiKey) {
      throw new Error("Please set your OpenAI API key in settings");
    }
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: settings.model,
        messages,
        max_tokens: settings.maxTokens,
        temperature: settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  async stream(context, callbacks) {
    var _a, _b, _c;
    const { settings, messages } = context;
    if (!settings.openaiApiKey) {
      throw new Error("Please set your OpenAI API key in settings");
    }
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: settings.model,
        messages,
        max_tokens: settings.maxTokens,
        temperature: settings.temperature,
        stream: true
      })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`OpenAI API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6).trim();
            if (data === "[DONE]") {
              await callbacks.onComplete();
              return;
            }
            try {
              const parsed = JSON.parse(data);
              const content = (_c = (_b = (_a = parsed.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content;
              if (content) {
                callbacks.onContent(content);
              }
            } catch (e) {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    await callbacks.onComplete();
  }
};

// src/providers/anthropic.ts
var AnthropicProvider = class {
  constructor() {
    this.name = "anthropic";
  }
  isConfigured(settings) {
    return !!settings.anthropicApiKey;
  }
  // Anthropic doesn't include system in messages array - filter it out
  filterSystemMessages(messages) {
    return messages.filter((m) => m.role !== "system");
  }
  async call(context) {
    const { settings, messages, systemMessage } = context;
    if (!settings.anthropicApiKey) {
      throw new Error("Please set your Anthropic API key in settings");
    }
    const requestBody = {
      model: settings.model,
      max_tokens: settings.maxTokens,
      temperature: settings.temperature,
      messages: this.filterSystemMessages(messages)
    };
    if (systemMessage) {
      requestBody.system = systemMessage;
    }
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": settings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      throw new Error(`Anthropic API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.content[0].text;
  }
  async stream(context, callbacks) {
    var _a;
    const { settings, messages, systemMessage } = context;
    if (!settings.anthropicApiKey) {
      throw new Error("Please set your Anthropic API key in settings");
    }
    const requestBody = {
      model: settings.model,
      max_tokens: settings.maxTokens,
      temperature: settings.temperature,
      messages: this.filterSystemMessages(messages),
      stream: true
    };
    if (systemMessage) {
      requestBody.system = systemMessage;
    }
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": settings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Anthropic API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6).trim();
            if (data === "[DONE]") {
              await callbacks.onComplete();
              return;
            }
            try {
              const parsed = JSON.parse(data);
              if (parsed.type === "content_block_delta") {
                const content = (_a = parsed.delta) == null ? void 0 : _a.text;
                if (content) {
                  callbacks.onContent(content);
                }
              }
            } catch (e) {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    await callbacks.onComplete();
  }
};

// src/providers/google.ts
var GoogleProvider = class {
  constructor() {
    this.name = "google";
  }
  isConfigured(settings) {
    return !!settings.googleApiKey;
  }
  // Convert standard messages to Google format
  toGoogleContents(messages) {
    const contents = [];
    for (const msg of messages) {
      if (msg.role === "system")
        continue;
      contents.push({
        role: msg.role === "assistant" ? "model" : "user",
        parts: [{ text: msg.content }]
      });
    }
    return contents;
  }
  // Build function declarations from MCP servers
  buildFunctionDeclarations(mcpContext) {
    const functionDeclarations = [];
    for (const server of mcpContext.servers) {
      for (const tool of server.tools) {
        let cleanedSchema = tool.inputSchema || {
          type: "object",
          properties: {},
          required: []
        };
        if (cleanedSchema && typeof cleanedSchema === "object") {
          const { $schema, additionalProperties, ...googleCompatibleSchema } = cleanedSchema;
          cleanedSchema = googleCompatibleSchema;
        }
        functionDeclarations.push({
          name: `${server.name}_${tool.name}`,
          description: tool.description || `Execute ${tool.name} from ${server.name}`,
          parameters: cleanedSchema
        });
      }
    }
    return functionDeclarations;
  }
  async call(context) {
    return this.callWithMCP(context, { servers: [], executeTool: async () => null });
  }
  async callWithMCP(context, mcpContext, retryCount = 0) {
    var _a, _b, _c;
    const { settings, messages, systemMessage } = context;
    if (!settings.googleApiKey) {
      throw new Error("Please set your Google API key in settings");
    }
    const contents = this.toGoogleContents(messages);
    const requestBody = {
      contents,
      generationConfig: {
        temperature: settings.temperature,
        maxOutputTokens: settings.maxTokens
      }
    };
    if (systemMessage) {
      requestBody.systemInstruction = { parts: [{ text: systemMessage }] };
    }
    const functionDeclarations = this.buildFunctionDeclarations(mcpContext);
    if (functionDeclarations.length > 0) {
      requestBody.tools = [{ functionDeclarations }];
    }
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/${settings.model}:generateContent?key=${settings.googleApiKey}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody)
      }
    );
    if (!response.ok) {
      const errorText = await response.text();
      if (response.status === 503 && retryCount < 2) {
        await new Promise((resolve) => setTimeout(resolve, 1e3 * (retryCount + 1)));
        return this.callWithMCP(context, mcpContext, retryCount + 1);
      }
      throw new Error(`Google API error (${response.status}): ${response.statusText}. ${errorText}`);
    }
    const data = await response.json();
    const candidate = (_a = data == null ? void 0 : data.candidates) == null ? void 0 : _a[0];
    if (!candidate) {
      throw new Error("No candidate in Google API response");
    }
    const functionCall = (_c = (_b = candidate.content) == null ? void 0 : _b.parts) == null ? void 0 : _c.find((part) => part.functionCall);
    if ((functionCall == null ? void 0 : functionCall.functionCall) && mcpContext.executeTool) {
      const { name, args } = functionCall.functionCall;
      if (!name) {
        throw new Error("Function call missing name");
      }
      try {
        const result = await mcpContext.executeTool(name, args || {});
        const followUpContents = [...contents, {
          role: "function",
          parts: [{
            functionResponse: { name, response: result }
          }]
        }];
        const followUpResponse = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/${settings.model}:generateContent?key=${settings.googleApiKey}`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...requestBody, contents: followUpContents })
          }
        );
        if (followUpResponse.ok) {
          const followUpData = await followUpResponse.json();
          return followUpData.candidates[0].content.parts[0].text;
        }
      } catch (error) {
        return `Error executing tool ${name}: ${error.message}`;
      }
    }
    return candidate.content.parts[0].text;
  }
  async stream(context, callbacks) {
    return this.streamWithMCP(context, callbacks, { servers: [], executeTool: async () => null });
  }
  async streamWithMCP(context, callbacks, mcpContext) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const { settings, messages, systemMessage } = context;
    if (!settings.googleApiKey) {
      throw new Error("Please set your Google API key in settings");
    }
    const contents = this.toGoogleContents(messages);
    const requestBody = {
      contents,
      generationConfig: {
        temperature: settings.temperature,
        maxOutputTokens: settings.maxTokens
      }
    };
    if (systemMessage) {
      requestBody.systemInstruction = { parts: [{ text: systemMessage }] };
    }
    const functionDeclarations = this.buildFunctionDeclarations(mcpContext);
    if (functionDeclarations.length > 0) {
      requestBody.tools = [{ functionDeclarations }];
    }
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/${settings.model}:streamGenerateContent?key=${settings.googleApiKey}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody)
      }
    );
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Google API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.trim() === "")
            continue;
          try {
            let jsonLine = line.trim();
            if (jsonLine.startsWith("data: ")) {
              jsonLine = jsonLine.slice(6).trim();
            }
            if (jsonLine === "[" || jsonLine === "]" || jsonLine === "")
              continue;
            if (jsonLine.endsWith(","))
              jsonLine = jsonLine.slice(0, -1);
            const parsed = JSON.parse(jsonLine);
            const candidates = Array.isArray(parsed) ? parsed : [parsed];
            for (const item of candidates) {
              const functionCall = (_e = (_d = (_c = (_b = (_a = item.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.functionCall;
              if (functionCall && mcpContext.executeTool) {
                const { name, args } = functionCall;
                if (name) {
                  try {
                    await mcpContext.executeTool(name, args || {});
                  } catch (error) {
                    console.error("MCP tool execution error:", error);
                  }
                }
              }
              const content = (_j = (_i = (_h = (_g = (_f = item.candidates) == null ? void 0 : _f[0]) == null ? void 0 : _g.content) == null ? void 0 : _h.parts) == null ? void 0 : _i[0]) == null ? void 0 : _j.text;
              if (content) {
                callbacks.onContent(content);
              }
            }
          } catch (e) {
          }
        }
      }
      if (buffer.trim()) {
        try {
          const parsed = JSON.parse(buffer);
          const content = (_o = (_n = (_m = (_l = (_k = parsed.candidates) == null ? void 0 : _k[0]) == null ? void 0 : _l.content) == null ? void 0 : _m.parts) == null ? void 0 : _n[0]) == null ? void 0 : _o.text;
          if (content) {
            callbacks.onContent(content);
          }
        } catch (e) {
        }
      }
    } finally {
      reader.releaseLock();
    }
    await callbacks.onComplete();
  }
};

// src/providers/ollama.ts
var OllamaProvider = class {
  constructor() {
    this.name = "ollama";
  }
  isConfigured(settings) {
    return !!settings.ollamaBaseUrl;
  }
  // Ollama uses a different prompt format
  buildPrompt(messages, systemMessage) {
    let prompt = "";
    if (systemMessage) {
      prompt += systemMessage + "\n\n";
    }
    for (const msg of messages) {
      if (msg.role === "system")
        continue;
      const role = msg.role === "user" ? "User" : "Assistant";
      prompt += `${role}: ${msg.content}
`;
    }
    prompt += "Assistant:";
    return prompt;
  }
  async call(context) {
    const { settings, messages, systemMessage } = context;
    const prompt = this.buildPrompt(messages, systemMessage);
    const response = await fetch(`${settings.ollamaBaseUrl}/api/generate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: settings.model,
        prompt,
        stream: false,
        options: {
          temperature: settings.temperature,
          num_predict: settings.maxTokens
        }
      })
    });
    if (!response.ok) {
      throw new Error(`Ollama API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.response;
  }
  async stream(context, callbacks) {
    const response = await this.call(context);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      callbacks.onContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await callbacks.onComplete();
  }
};

// src/providers/lmstudio.ts
var LMStudioProvider = class {
  constructor() {
    this.name = "lmstudio";
  }
  isConfigured(settings) {
    return !!settings.lmStudioBaseUrl;
  }
  async call(context) {
    const { settings, messages } = context;
    const response = await fetch(`${settings.lmStudioBaseUrl}/v1/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: settings.model,
        messages,
        max_tokens: settings.maxTokens,
        temperature: settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`LM Studio API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  async stream(context, callbacks) {
    const response = await this.call(context);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      callbacks.onContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await callbacks.onComplete();
  }
};

// src/providers/custom.ts
var CustomAPIProvider = class {
  constructor() {
    this.name = "custom";
  }
  isConfigured(settings) {
    return !!settings.customApiUrl;
  }
  async call(context) {
    const { settings, messages } = context;
    if (!settings.customApiUrl) {
      throw new Error("Please set your custom API URL in settings");
    }
    const headers = {
      "Content-Type": "application/json"
    };
    if (settings.customApiKey) {
      headers["Authorization"] = `Bearer ${settings.customApiKey}`;
    }
    const response = await fetch(settings.customApiUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({
        model: settings.model,
        messages,
        max_tokens: settings.maxTokens,
        temperature: settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`Custom API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  async stream(context, callbacks) {
    const response = await this.call(context);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      callbacks.onContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await callbacks.onComplete();
  }
};

// src/providers/index.ts
var providers = {
  openai: new OpenAIProvider(),
  anthropic: new AnthropicProvider(),
  google: new GoogleProvider(),
  ollama: new OllamaProvider(),
  lmstudio: new LMStudioProvider(),
  custom: new CustomAPIProvider()
};
function getProvider(name) {
  return providers[name];
}

// main.ts
var StellaPlugin = class extends import_obsidian4.Plugin {
  get cache() {
    return this.cacheManager;
  }
  get mcp() {
    return this.mcpManager;
  }
  get mcpClientManager() {
    return this.mcpManager;
  }
  // MCP Server Initialization
  async initializeMCPServers() {
    this.logger.log("Initializing MCP servers...");
    for (const serverConfig of this.settings.mcpServers) {
      try {
        const success = await this.mcpManager.addServer(serverConfig);
        if (success) {
          this.logger.log(`Successfully connected to MCP server: ${serverConfig.name}`);
        } else {
          this.logger.warn(`Failed to connect to MCP server: ${serverConfig.name}`);
        }
      } catch (error) {
        this.logger.error(`Error connecting to MCP server ${serverConfig.name}:`, error);
      }
    }
    const connectedCount = this.mcpManager.getConnectedServers().length;
    this.logger.log(`MCP initialization complete. Connected to ${connectedCount} server(s).`);
  }
  async onload() {
    this.logger = new AsyncLogger();
    this.cacheManager = new CacheManager();
    this.mcpManager = new MCPClientManager(this.logger);
    this.logger.log("Stella plugin loading...");
    await this.loadSettings();
    if (this.settings.mcpEnabled) {
      this.initializeMCPServers().catch((error) => {
        this.logger.error("Failed to initialize MCP servers:", error);
      });
    }
    this.registerView(
      CHAT_VIEW_TYPE,
      (leaf) => new StellaChatView(leaf, this)
    );
    this.addRibbonIcon("message-circle", "Open Stella Chat", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-stella-chat",
      name: "Open Stella Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new StellaSettingTab(this.app, this));
    setTimeout(() => {
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateModelInfo) {
          chatView.updateModelInfo(chatView.modelInfoContainer);
        }
      });
    }, 1e3);
  }
  async onunload() {
    this.logger.log("Stella plugin unloading...");
    this.logger.destroy();
    this.app.workspace.detachLeavesOfType(CHAT_VIEW_TYPE);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (typeof this.settings.backgroundImage === "undefined") {
      this.settings.backgroundImage = "";
      this.settings.backgroundMode = "centered";
      this.settings.backgroundOpacity = 0.5;
    }
    if (!this.settings.conversations) {
      this.settings.conversations = [];
    }
    this.logger.log(`Loaded settings - Conversations count: ${this.settings.conversations.length}`);
  }
  async saveSettings() {
    if (!this.settings.conversations) {
      this.logger.warn("Conversations array is missing, preserving existing data");
      const existingData = await this.loadData();
      if (existingData && existingData.conversations) {
        this.settings.conversations = existingData.conversations;
      } else {
        this.settings.conversations = [];
      }
    }
    this.logger.log(`Saving settings - Conversations count: ${this.settings.conversations.length}`);
    await this.saveData(this.settings);
    this.cacheManager.invalidateConversationData();
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(CHAT_VIEW_TYPE);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: CHAT_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE)[0]
    );
  }
};
var CHAT_VIEW_TYPE = "stella-mcp-chat-view";
var StellaChatView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.conversations = [];
    this.currentConversationId = null;
    this.chatHistory = [];
    this.currentSystemPrompt = null;
    this.currentSystemPromptFilename = null;
    this.currentMentalModel = null;
    this.currentMentalModelFilename = null;
    // Message pagination state
    this.messagePageSize = 50;
    // Show 50 messages at a time
    this.currentMessagePage = 0;
    this.totalMessagePages = 0;
    this.isLoadingMoreMessages = false;
    this.contextNotes = [];
    // MCP context state
    this.activeMCPServers = [];
    // Available commands list (keep this updated when adding new commands)
    this.availableCommands = [
      { command: "/help", description: "Show all available commands" },
      { command: "/sys", description: "Load system prompt from file" },
      { command: "/sysclear", description: "Clear current system prompt" },
      { command: "/model", description: "Load mental model from file" },
      { command: "/modelclear", description: "Clear current mental model" },
      { command: "/mcp", description: "Connect to MCP server" },
      { command: "/mcpclear", description: "Clear MCP connections" },
      { command: "/clear", description: "Clear all context and start new conversation" },
      { command: "/new", description: "Start new conversation" },
      { command: "/del", description: "Delete current conversation" },
      { command: "/history", description: "Show conversation history" },
      { command: "/name", description: "Rename current conversation" },
      { command: "/settings", description: "Open plugin settings" },
      { command: "/hide", description: "Toggle header visibility" }
    ];
    this.plugin = plugin;
    this.logger = new AsyncLogger();
  }
  getViewType() {
    return CHAT_VIEW_TYPE;
  }
  getDisplayText() {
    return "Stella";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("stella-mcp-chat-container");
    this.buildChatUI(container);
    this.loadConversations();
    this.updateHeaderVisibility();
    this.updateBackgroundImage();
  }
  buildChatUI(container) {
    this.chatContainer = container;
    const header = container.createEl("div", { cls: "stella-chat-header" });
    this.headerContainer = header;
    const leftControls = header.createEl("div", { cls: "stella-header-left" });
    this.conversationNameInput = leftControls.createEl("input", {
      cls: "stella-conversation-name",
      type: "text",
      value: "Current Chat"
    });
    this.conversationNameInput.addEventListener("blur", () => {
      this.saveConversationName();
    });
    this.conversationNameInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        this.conversationNameInput.blur();
      }
    });
    const rightControls = header.createEl("div", { cls: "stella-header-right" });
    this.modelInfoContainer = rightControls.createEl("span", { cls: "stella-model-info" });
    this.updateModelInfo(this.modelInfoContainer);
    const newChatBtn = rightControls.createEl("button", {
      cls: "stella-action-btn",
      attr: { "aria-label": "New chat" }
    });
    newChatBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
    newChatBtn.addEventListener("click", () => {
      this.startNewConversation();
    });
    const historyBtn = rightControls.createEl("button", {
      cls: "stella-action-btn",
      attr: { "aria-label": "Chat history" }
    });
    historyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12,6 12,12 16,14"></polyline></svg>';
    historyBtn.addEventListener("click", () => {
      try {
        this.showChatHistory();
      } catch (error) {
        this.logger.error("Error showing chat history:", error);
        console.log("Chat history feature will be implemented in a future update.");
      }
    });
    const settingsBtn = rightControls.createEl("button", {
      cls: "stella-action-btn",
      attr: { "aria-label": "Settings" }
    });
    settingsBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>';
    settingsBtn.addEventListener("click", () => {
      this.openSettings();
    });
    this.messagesContainer = container.createEl("div", { cls: "stella-messages-container" });
    this.contextIndicator = container.createEl("div", {
      cls: "stella-context-indicator"
    });
    this.updateContextIndicator();
    this.inputContainer = container.createEl("div", { cls: "stella-input-container" });
    this.chatInput = this.inputContainer.createEl("textarea", {
      cls: "stella-chat-input"
    });
    this.systemPromptIndicator = this.inputContainer.createEl("div", {
      cls: "stella-system-prompt-indicator",
      attr: { "title": "System prompt loaded - use /sysclear to remove" }
    });
    this.updateSystemPromptIndicator();
    this.mentalModelIndicator = this.inputContainer.createEl("div", {
      cls: "stella-mental-model-indicator",
      attr: { "title": "Mental model loaded - use /modelclear to remove" }
    });
    this.updateMentalModelIndicator();
    this.mcpIndicator = this.inputContainer.createEl("div", {
      cls: "stella-mcp-indicator"
    });
    this.noteIndicator = this.inputContainer.createEl("div", {
      cls: "stella-note-indicator"
    });
    this.updateMCPIndicator();
    this.chatInput.addEventListener("keydown", (e) => {
      if (e.key === "@") {
        e.preventDefault();
        this.showNoteSelector();
        return;
      }
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        const message = this.chatInput.value.trim();
        console.log("Enter pressed with message:", message);
        if (message === "/sys") {
          this.showSystemPromptSelector();
          this.chatInput.value = "";
          return;
        }
        if (message === "/sysclear") {
          this.unloadSystemPrompt();
          this.chatInput.value = "";
          return;
        }
        if (message === "/model") {
          this.showMentalModelSelector();
          this.chatInput.value = "";
          return;
        }
        if (message === "/modelclear") {
          this.unloadMentalModel();
          this.chatInput.value = "";
          return;
        }
        if (message === "/mcp") {
          this.showMCPSelector();
          this.chatInput.value = "";
          return;
        }
        if (message === "/new") {
          this.startNewConversation();
          this.chatInput.value = "";
          return;
        }
        if (message === "/del") {
          this.deleteCurrentConversationAndStartNew();
          this.chatInput.value = "";
          return;
        }
        if (message === "/history") {
          this.showChatHistory();
          this.chatInput.value = "";
          return;
        }
        if (message === "/settings") {
          this.openPluginSettings();
          this.chatInput.value = "";
          return;
        }
        if (message === "/name") {
          this.showNameInput();
          this.chatInput.value = "";
          return;
        }
        if (message === "/hide") {
          this.toggleHeader();
          this.chatInput.value = "";
          return;
        }
        if (message === "/help") {
          this.showHelpMessage();
          this.chatInput.value = "";
          return;
        }
        this.sendMessage();
      }
    });
    this.updateBackgroundImage();
  }
  async sendMessage() {
    const message = this.chatInput.value.trim();
    if (!message)
      return;
    if (message === "/sys") {
      this.showSystemPromptSelector();
      this.chatInput.value = "";
      return;
    }
    if (message === "/sysclear") {
      this.unloadSystemPrompt();
      this.chatInput.value = "";
      return;
    }
    if (message === "/model") {
      this.showMentalModelSelector();
      this.chatInput.value = "";
      return;
    }
    if (message === "/modelclear") {
      this.unloadMentalModel();
      this.chatInput.value = "";
      return;
    }
    if (message === "/mcp") {
      this.showMCPSelector();
      this.chatInput.value = "";
      return;
    }
    if (message === "/mcpclear") {
      this.clearMCPContext();
      this.chatInput.value = "";
      return;
    }
    if (message === "/clear") {
      this.clearAllContext();
      this.chatInput.value = "";
      return;
    }
    if (message.startsWith("/")) {
      this.logger.warn(`Unknown slash command detected: ${message}`);
      const commandList = this.availableCommands.map((cmd) => cmd.command).join(", ");
      this.addMessage(`Unknown command: ${message}. Available commands: ${commandList}`, "error");
      this.chatInput.value = "";
      return;
    }
    const userMessageEl = this.addMessage(message, "user");
    this.chatInput.value = "";
    await this.detectAndActivateMCP(message);
    const loadingOverlay = this.messagesContainer.createDiv("stella-cat-loading-overlay");
    setTimeout(() => {
      loadingOverlay.classList.add("stella-cat-loading-visible");
    }, 100);
    setTimeout(() => {
      loadingOverlay.scrollIntoView({ behavior: "smooth", block: "center" });
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }, 200);
    const catTimerGroup = loadingOverlay.createDiv("stella-cat-timer-group");
    const catSprite = catTimerGroup.createEl("img", {
      cls: "stella-cat-sprite",
      attr: {
        alt: "Bulbasaur loading animation"
      }
    });
    this.loadGifAsDataUrl(catSprite);
    const timerText = catTimerGroup.createDiv("stella-countdown-timer");
    let tokenCounter = null;
    let mcpStatus = null;
    if (this.plugin.settings.showTokenCount) {
      tokenCounter = loadingOverlay.createDiv("stella-token-counter-floating");
      tokenCounter.textContent = "Estimating tokens...";
    }
    if (this.activeMCPServers && this.activeMCPServers.length > 0) {
      mcpStatus = loadingOverlay.createDiv("stella-mcp-status-floating");
      mcpStatus.textContent = "";
      mcpStatus.style.display = "none";
      mcpStatus.style.position = "absolute";
      mcpStatus.style.right = "40px";
      mcpStatus.style.top = tokenCounter ? "60px" : "80px";
      mcpStatus.style.fontSize = "12px";
      mcpStatus.style.color = "var(--text-muted)";
      mcpStatus.style.backgroundColor = "var(--background-secondary)";
      mcpStatus.style.padding = "4px 8px";
      mcpStatus.style.borderRadius = "12px";
      mcpStatus.style.border = "1px solid var(--background-modifier-border)";
      mcpStatus.style.zIndex = "1001";
    }
    const estimatedTokens = this.estimateTokens(message + this.buildSystemMessage());
    let elapsedSeconds = 0;
    timerText.textContent = `${elapsedSeconds}s`;
    setTimeout(() => {
      loadingOverlay.classList.add("stella-cat-loading-visible");
    }, 50);
    let displayedTokens = Math.floor(estimatedTokens * 0.3);
    const loadingInterval = setInterval(() => {
      elapsedSeconds++;
      timerText.textContent = `${elapsedSeconds}s`;
      if (tokenCounter) {
        const increment = Math.max(1, Math.floor(estimatedTokens / (elapsedSeconds + 10)));
        displayedTokens = Math.min(displayedTokens + increment, estimatedTokens);
        tokenCounter.textContent = `${displayedTokens} tokens`;
      }
    }, 1e3);
    try {
      const response = await this.callLLM(message);
      clearInterval(loadingInterval);
      this.hideLoadingAnimation(loadingOverlay);
      const responseTokens = this.estimateTokens(response);
      const totalTokens = estimatedTokens + responseTokens;
      if (tokenCounter) {
        tokenCounter.textContent = `${totalTokens} tokens`;
      }
      setTimeout(() => {
        const responseEl = this.addMessage(response, "assistant");
        if (this.plugin.settings.showTokenCount) {
          const responseContentEl = responseEl.querySelector(".stella-message-content");
          const finalTokenCounter = responseContentEl.createDiv("stella-token-counter stella-token-final");
          finalTokenCounter.textContent = `${totalTokens} tokens`;
        }
      }, 300);
    } catch (error) {
      clearInterval(loadingInterval);
      this.hideLoadingAnimation(loadingOverlay);
      this.addMessage(`Error: ${error.message}`, "error");
    }
  }
  hideLoadingAnimation(loadingOverlay) {
    loadingOverlay.classList.add("stella-cat-loading-hiding");
    setTimeout(() => {
      loadingOverlay.remove();
    }, 300);
  }
  async loadGifAsDataUrl(imgElement) {
    const customGif = this.plugin.settings.loadingGif;
    if (customGif && customGif.trim() !== "") {
      try {
        const file = this.app.vault.getAbstractFileByPath(customGif);
        if (file) {
          const resourcePath = this.app.vault.getResourcePath(file);
          imgElement.src = resourcePath;
          return;
        }
        const adapter = this.app.vault.adapter;
        if ("readBinary" in adapter) {
          const data = await adapter.readBinary(customGif);
          const blob = new Blob([data], { type: "image/gif" });
          const reader = new FileReader();
          reader.onload = () => {
            imgElement.src = reader.result;
          };
          reader.readAsDataURL(blob);
          return;
        }
      } catch (customError) {
        console.warn("Failed to load custom GIF:", customError);
      }
    }
    try {
      const adapter = this.app.vault.adapter;
      if (adapter.getBasePath) {
        const basePath = adapter.getBasePath();
        const path = require("path");
        const fs = require("fs");
        const gifPath = path.join(basePath, ".obsidian", "plugins", "Stella", "bulbasaur.gif");
        if (fs.existsSync(gifPath)) {
          const data = fs.readFileSync(gifPath);
          const base64 = data.toString("base64");
          imgElement.src = `data:image/gif;base64,${base64}`;
          return;
        }
      }
    } catch (error) {
      console.warn("Failed to load default GIF from plugin directory:", error);
    }
    this.createCSSLoadingAnimation(imgElement);
  }
  createCSSLoadingAnimation(imgElement) {
    imgElement.style.width = "64px";
    imgElement.style.height = "64px";
    imgElement.style.background = "linear-gradient(135deg, var(--interactive-accent) 0%, var(--interactive-accent-hover) 100%)";
    imgElement.style.borderRadius = "50%";
    imgElement.style.animation = "stella-pulse 1.5s ease-in-out infinite";
    if (!document.getElementById("stella-loading-keyframes")) {
      const style = document.createElement("style");
      style.id = "stella-loading-keyframes";
      style.textContent = `
                @keyframes stella-pulse {
                    0%, 100% { transform: scale(1); opacity: 1; }
                    50% { transform: scale(1.1); opacity: 0.7; }
                }
            `;
      document.head.appendChild(style);
    }
  }
  addMessage(content, type, isTemp = false) {
    if (!isTemp) {
      this.chatHistory.push({
        role: type === "user" ? "user" : "assistant",
        content,
        timestamp: Date.now()
      });
      if (this.currentConversationId) {
        this.saveCurrentConversation();
      }
    }
    return this.addMessageToUI(content, type, isTemp);
  }
  addMessageToUI(content, type, isTemp = false) {
    const messageEl = this.messagesContainer.createEl("div", {
      cls: `stella-message stella-message-${type}`
    });
    if (isTemp) {
      messageEl.addClass("stella-message-temp");
    }
    const contentEl = messageEl.createEl("div", { cls: "stella-message-content" });
    if (type === "assistant" && !isTemp) {
      this.renderMarkdown(contentEl, content);
    } else {
      this.renderTextWithWikiLinks(contentEl, content);
    }
    this.setupContextMenu(contentEl);
    return messageEl;
  }
  // Simple token estimation (roughly 4 characters per token)
  estimateTokens(text) {
    return Math.ceil(text.length / 4);
  }
  setupContextMenu(contentEl) {
    contentEl.addEventListener("contextmenu", (e) => {
      const selection = window.getSelection();
      const selectedText = selection == null ? void 0 : selection.toString().trim();
      if (selectedText) {
        e.preventDefault();
        this.showQuickAddContextMenu(e, selectedText);
      }
    });
  }
  showQuickAddContextMenu(event, selectedText) {
    const menu = new import_obsidian4.Menu();
    this.plugin.settings.quickAddCommands.forEach((command) => {
      menu.addItem(
        (item) => item.setTitle(command.name).setIcon("plus-circle").onClick(() => {
          this.executeQuickAddCommand(command.id, selectedText);
        })
      );
    });
    if (this.plugin.settings.quickAddCommands.length === 0) {
      menu.addItem(
        (item) => item.setTitle("No QuickAdd commands configured").setDisabled(true)
      );
    }
    menu.showAtMouseEvent(event);
  }
  async executeQuickAddCommand(commandId, selectedText) {
    var _a;
    try {
      const plugins = this.app.plugins;
      const quickAddPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["quickadd"];
      if (!quickAddPlugin) {
        new import_obsidian4.Notice("QuickAdd plugin is not installed or enabled");
        return;
      }
      window.stellaSelectedText = selectedText;
      const commands = this.app.commands;
      if (!commands) {
        new import_obsidian4.Notice("Commands system not available");
        return;
      }
      const allCommands = commands.listCommands();
      console.log("Available QuickAdd commands:", allCommands.filter((cmd) => cmd.id.includes("quickadd")));
      const possibleCommandIds = [
        `quickadd:choice:${commandId}`,
        `quickadd:${commandId}`,
        commandId,
        `QuickAdd: ${commandId}`,
        // Case variations
        commandId.toLowerCase(),
        commandId.toUpperCase()
      ];
      let commandExecuted = false;
      for (const cmdId of possibleCommandIds) {
        try {
          const foundCommand = allCommands.find(
            (cmd) => {
              var _a2;
              return cmd.id === cmdId || cmd.id.toLowerCase() === cmdId.toLowerCase() || ((_a2 = cmd.name) == null ? void 0 : _a2.toLowerCase().includes(commandId.toLowerCase()));
            }
          );
          if (foundCommand) {
            console.log(`Found QuickAdd command: ${foundCommand.id} (${foundCommand.name})`);
            commands.executeCommandById(foundCommand.id);
            new import_obsidian4.Notice(`Executed QuickAdd command: ${foundCommand.name}`);
            commandExecuted = true;
            break;
          }
        } catch (error) {
          console.log(`Failed to execute command ID: ${cmdId}`, error);
        }
      }
      if (!commandExecuted) {
        const quickAddCommands = allCommands.filter((cmd) => cmd.id.includes("quickadd"));
        console.log("Available QuickAdd commands:", quickAddCommands.map((cmd) => ({ id: cmd.id, name: cmd.name })));
        if (quickAddCommands.length > 0) {
          new import_obsidian4.Notice(`QuickAdd command '${commandId}' not found. Available commands: ${quickAddCommands.map((cmd) => cmd.name).join(", ")}`);
        } else {
          new import_obsidian4.Notice("No QuickAdd commands found. Make sure QuickAdd is properly configured.");
        }
      }
    } catch (error) {
      new import_obsidian4.Notice("Failed to execute QuickAdd command");
      console.error("QuickAdd execution error:", error);
    }
  }
  async renderMarkdown(container, content) {
    try {
      await import_obsidian4.MarkdownRenderer.renderMarkdown(content, container, "", this);
    } catch (error) {
      console.error("Error rendering markdown:", error);
      container.textContent = content;
    }
    this.processAllWikiLinks(container, content);
  }
  preprocessWikiLinks(content) {
    const wikiLinkRegex = /\[\[([^\]]+?)(?:\|([^\]]+?))?\]\]/g;
    let processedContent = content;
    processedContent = processedContent.replace(wikiLinkRegex, (match, noteName, displayText) => {
      const placeholder = `__WIKILINK__${noteName}__${displayText || noteName}__ENDWIKILINK__`;
      return placeholder;
    });
    return processedContent;
  }
  enhanceWikiLinks(container) {
    this.processWikiLinkPlaceholders(container);
    const wikiLinks = container.querySelectorAll("a.internal-link");
    wikiLinks.forEach((link) => {
      const href = link.getAttribute("href");
      if (!href)
        return;
      const noteName = decodeURIComponent(href);
      const file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
      const exists = file !== null;
      link.classList.add("stella-wiki-link");
      if (!exists) {
        link.classList.add("stella-wiki-link-missing");
      }
      link.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.ctrlKey || e.metaKey) {
          if (exists) {
            this.app.workspace.openLinkText(noteName, "");
          }
        } else {
          if (exists) {
            this.addNoteToContext(file);
          } else {
            this.addMessage(`Note "${noteName}" not found in vault`, "error");
          }
        }
      });
      const existingTitle = link.getAttribute("title") || "";
      link.setAttribute(
        "title",
        exists ? `${existingTitle ? existingTitle + " | " : ""}Click to add to context, Ctrl+Click to open` : `Note "${noteName}" not found`
      );
    });
  }
  processWikiLinkPlaceholders(container) {
    const placeholderRegex = /__WIKILINK__([^_]+?)__([^_]+?)__ENDWIKILINK__/g;
    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT
    );
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      if (node.textContent && node.textContent.includes("__WIKILINK__")) {
        textNodes.push(node);
      }
    }
    textNodes.forEach((textNode) => {
      var _a;
      const content = textNode.textContent || "";
      if (placeholderRegex.test(content)) {
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        placeholderRegex.lastIndex = 0;
        while ((match = placeholderRegex.exec(content)) !== null) {
          if (match.index > lastIndex) {
            const textBefore = content.slice(lastIndex, match.index);
            fragment.appendChild(document.createTextNode(textBefore));
          }
          const noteName = match[1];
          const displayText = match[2];
          const linkWrapper = document.createElement("span");
          this.createWikiLinkElement(linkWrapper, noteName, displayText);
          fragment.appendChild(linkWrapper.firstChild);
          lastIndex = match.index + match[0].length;
        }
        if (lastIndex < content.length) {
          const textAfter = content.slice(lastIndex);
          fragment.appendChild(document.createTextNode(textAfter));
        }
        (_a = textNode.parentNode) == null ? void 0 : _a.replaceChild(fragment, textNode);
      }
    });
  }
  processAllWikiLinks(container, originalContent) {
    this.enhanceExistingWikiLinks(container);
    this.processUnprocessedWikiLinks(container, originalContent);
  }
  enhanceExistingWikiLinks(container) {
    const existingLinks = container.querySelectorAll("a.internal-link");
    existingLinks.forEach((link) => {
      this.enhanceWikiLink(link);
    });
  }
  processUnprocessedWikiLinks(container, originalContent) {
    const wikiLinkRegex = /\[\[([^\]]+?)(?:\|([^\]]+?))?\]\]/g;
    const matches = Array.from(originalContent.matchAll(wikiLinkRegex));
    if (matches.length === 0)
      return;
    console.log("Found wiki links to process:", matches.map((m) => m[0]));
    const textNodes = [];
    this.collectTextNodes(container, textNodes);
    console.log("Found text nodes:", textNodes.length);
    textNodes.forEach((textNode, index) => {
      const content = textNode.textContent || "";
      if (content.includes("[[") && content.includes("]]")) {
        console.log(`Processing text node ${index}:`, content.substring(0, 100));
        this.replaceWikiLinksInTextNode(textNode, content);
      }
    });
  }
  collectTextNodes(node, textNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      textNodes.push(node);
    } else {
      for (let child of Array.from(node.childNodes)) {
        this.collectTextNodes(child, textNodes);
      }
    }
  }
  replaceWikiLinksInTextNode(textNode, content) {
    console.log("Replacing wiki links in text node:", content.substring(0, 100));
    const wikiLinkRegex = /\[\[([^\]]+?)(?:\|([^\]]+?))?\]\]/g;
    const fragment = document.createDocumentFragment();
    let lastIndex = 0;
    let match;
    let replacements = 0;
    wikiLinkRegex.lastIndex = 0;
    while ((match = wikiLinkRegex.exec(content)) !== null) {
      if (match.index > lastIndex) {
        const textBefore = content.slice(lastIndex, match.index);
        fragment.appendChild(document.createTextNode(textBefore));
      }
      const noteName = match[1].trim();
      const displayText = match[2] ? match[2].trim() : noteName;
      console.log(`Creating wiki link: ${noteName} -> ${displayText}`);
      const link = this.createWikiLink(noteName, displayText);
      fragment.appendChild(link);
      replacements++;
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < content.length) {
      const textAfter = content.slice(lastIndex);
      fragment.appendChild(document.createTextNode(textAfter));
    }
    console.log(`Made ${replacements} wiki link replacements`);
    if (replacements > 0 && textNode.parentNode) {
      textNode.parentNode.replaceChild(fragment, textNode);
    }
  }
  createWikiLink(noteName, displayText) {
    const file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
    const exists = file !== null;
    const link = document.createElement("a");
    link.textContent = displayText;
    link.className = "stella-wiki-link internal-link";
    if (!exists) {
      link.classList.add("stella-wiki-link-missing");
    }
    this.enhanceWikiLink(link, noteName, file);
    return link;
  }
  enhanceWikiLink(link, noteName, file) {
    if (!noteName) {
      const href = link.getAttribute("href");
      noteName = href ? decodeURIComponent(href) : link.textContent || "";
    }
    if (!file) {
      file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
    }
    const exists = file !== null;
    link.classList.add("stella-wiki-link");
    if (!exists) {
      link.classList.add("stella-wiki-link-missing");
    }
    link.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.ctrlKey || e.metaKey) {
        if (exists) {
          this.app.workspace.openLinkText(noteName, "");
        }
      } else {
        if (exists) {
          this.addNoteToContext(file);
        } else {
          this.addMessage(`Note "${noteName}" not found in vault`, "error");
        }
      }
    });
    link.setAttribute(
      "title",
      exists ? `Click to add to context, Ctrl+Click to open` : `Note "${noteName}" not found`
    );
  }
  renderTextWithWikiLinks(container, content) {
    container.textContent = content;
    this.processAllWikiLinks(container, content);
  }
  createWikiLinkElement(container, noteName, displayText) {
    const file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
    const exists = file !== null;
    const link = container.createEl("a", {
      text: displayText,
      cls: ["stella-wiki-link", "internal-link"]
    });
    if (!exists) {
      link.classList.add("stella-wiki-link-missing");
    }
    link.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.ctrlKey || e.metaKey) {
        if (exists) {
          this.app.workspace.openLinkText(noteName, "");
        }
      } else {
        if (exists) {
          this.addNoteToContext(file);
        } else {
          this.addMessage(`Note "${noteName}" not found in vault`, "error");
        }
      }
    });
    link.setAttribute(
      "title",
      exists ? `Click to add to context, Ctrl+Click to open` : `Note "${noteName}" not found`
    );
  }
  async addNoteToContext(file) {
    try {
      const content = await this.app.vault.read(file);
      const existing = this.contextNotes.find((note) => note.name === file.basename);
      if (existing) {
        this.addMessage(`"${file.basename}" is already in context`, "error");
        return;
      }
      this.contextNotes.push({
        name: file.basename,
        content
      });
      this.updateContextIndicator();
    } catch (error) {
      this.addMessage(`Error loading "${file.basename}": ${error.message}`, "error");
    }
  }
  async streamLLMResponse(message, contentEl) {
    const { provider } = this.plugin.settings;
    let accumulatedResponse = "";
    let streamingSucceeded = false;
    const updateContent = (text) => {
      accumulatedResponse += text;
      contentEl.textContent = accumulatedResponse;
    };
    const finalizeContent = async () => {
      const messageEl = contentEl.closest(".stella-message");
      if (messageEl) {
        messageEl.removeClass("stella-message-temp");
      }
      contentEl.innerHTML = "";
      await this.renderMarkdown(contentEl, accumulatedResponse);
      this.chatHistory.push({
        role: "assistant",
        content: accumulatedResponse,
        timestamp: Date.now()
      });
      if (this.currentConversationId) {
        this.saveCurrentConversation();
      }
      streamingSucceeded = true;
    };
    try {
      console.log(`Attempting streaming for provider: ${provider}`);
      await this.streamLLM(message, updateContent, finalizeContent);
    } catch (error) {
      console.error(`Streaming failed for ${provider}, falling back to regular API:`, error);
      if (!streamingSucceeded) {
        try {
          const response = await this.callLLM(message);
          const messageEl = contentEl.closest(".stella-message");
          if (messageEl) {
            messageEl.removeClass("stella-message-temp");
          }
          contentEl.innerHTML = "";
          await this.renderMarkdown(contentEl, response);
          this.chatHistory.push({
            role: "assistant",
            content: response,
            timestamp: Date.now()
          });
          if (this.currentConversationId) {
            this.saveCurrentConversation();
          }
          console.log(`Fallback API call succeeded for ${provider}`);
        } catch (fallbackError) {
          console.error(`Both streaming and fallback failed for ${provider}:`, fallbackError);
          throw fallbackError;
        }
      }
    }
  }
  // Build provider context from current view state
  buildProviderContext(message) {
    const systemMessage = this.buildSystemMessage();
    const messages = buildMessagesArray(
      this.chatHistory,
      message,
      systemMessage || null
    );
    return {
      settings: this.plugin.settings,
      messages,
      systemMessage: systemMessage || null
    };
  }
  async callLLM(message) {
    const { provider: providerName } = this.plugin.settings;
    const provider = getProvider(providerName);
    if (!provider) {
      throw new Error(`Unsupported provider: ${providerName}`);
    }
    if (!provider.isConfigured(this.plugin.settings)) {
      throw new Error(`Please configure ${providerName} in settings`);
    }
    const context = this.buildProviderContext(message);
    if (providerName === "google" && this.activeMCPServers && this.activeMCPServers.length > 0) {
      const mcpProvider = provider;
      if (mcpProvider.callWithMCP) {
        const mcpContext = this.buildMCPContext();
        return mcpProvider.callWithMCP(context, mcpContext);
      }
    }
    return provider.call(context);
  }
  // Build MCP context for providers that support tool calling
  buildMCPContext() {
    const servers = [];
    if (this.activeMCPServers && Array.isArray(this.activeMCPServers)) {
      for (const activeServer of this.activeMCPServers) {
        if (activeServer.tools && activeServer.tools.length > 0) {
          servers.push({
            name: activeServer.name,
            tools: activeServer.tools.map((tool) => ({
              name: tool.name,
              description: tool.description || "",
              inputSchema: tool.inputSchema || {}
            }))
          });
        }
      }
    }
    return {
      servers,
      executeTool: async (functionName, args) => {
        return this.executeMCPTool(functionName, args);
      }
    };
  }
  async streamLLM(message, updateContent, finalizeContent) {
    const { provider: providerName } = this.plugin.settings;
    const provider = getProvider(providerName);
    if (!provider) {
      throw new Error(`Unsupported provider: ${providerName}`);
    }
    if (!provider.isConfigured(this.plugin.settings)) {
      throw new Error(`Please configure ${providerName} in settings`);
    }
    const context = this.buildProviderContext(message);
    const callbacks = {
      onContent: updateContent,
      onComplete: finalizeContent
    };
    if (providerName === "google") {
      throw new Error("Google streaming temporarily disabled");
    }
    await provider.stream(context, callbacks);
  }
  async callOpenAI(message) {
    if (!this.plugin.settings.openaiApiKey) {
      throw new Error("Please set your OpenAI API key in settings");
    }
    const messages = [];
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      messages.push({ role: "system", content: this.buildSystemMessage() });
      console.log("OpenAI: Including system message in request");
    }
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        messages,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  async streamOpenAI(message, updateContent, finalizeContent) {
    var _a, _b, _c;
    if (!this.plugin.settings.openaiApiKey) {
      throw new Error("Please set your OpenAI API key in settings");
    }
    const messages = [];
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      messages.push({ role: "system", content: this.buildSystemMessage() });
    }
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        messages,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature,
        stream: true
      })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`OpenAI API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6).trim();
            if (data === "[DONE]") {
              await finalizeContent();
              return;
            }
            try {
              const parsed = JSON.parse(data);
              const content = (_c = (_b = (_a = parsed.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content;
              if (content) {
                updateContent(content);
              }
            } catch (e) {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    await finalizeContent();
  }
  async callAnthropic(message) {
    if (!this.plugin.settings.anthropicApiKey) {
      throw new Error("Please set your Anthropic API key in settings");
    }
    const messages = [];
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.plugin.settings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature,
        messages,
        ...(this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) && {
          system: this.buildSystemMessage()
        }
      })
    });
    if (!response.ok) {
      throw new Error(`Anthropic API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.content[0].text;
  }
  async streamAnthropic(message, updateContent, finalizeContent) {
    var _a;
    if (!this.plugin.settings.anthropicApiKey) {
      throw new Error("Please set your Anthropic API key in settings");
    }
    const messages = [];
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const requestBody = {
      model: this.plugin.settings.model,
      max_tokens: this.plugin.settings.maxTokens,
      temperature: this.plugin.settings.temperature,
      messages,
      stream: true
    };
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      requestBody.system = this.buildSystemMessage();
    }
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.plugin.settings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Anthropic API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6).trim();
            if (data === "[DONE]") {
              await finalizeContent();
              return;
            }
            try {
              const parsed = JSON.parse(data);
              if (parsed.type === "content_block_delta") {
                const content = (_a = parsed.delta) == null ? void 0 : _a.text;
                if (content) {
                  updateContent(content);
                }
              }
            } catch (e) {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    await finalizeContent();
  }
  async callGoogle(message, retryCount = 0) {
    var _a, _b, _c;
    if (!this.plugin.settings.googleApiKey) {
      throw new Error("Please set your Google API key in settings");
    }
    const contents = [];
    for (const msg of this.chatHistory) {
      contents.push({
        role: msg.role === "assistant" ? "model" : "user",
        parts: [{ text: msg.content }]
      });
    }
    contents.push({
      role: "user",
      parts: [{ text: message }]
    });
    if (this.currentSystemPrompt) {
      console.log("Google: Including system prompt in request");
    } else {
      console.log("Google: No system prompt to include");
    }
    const requestBody = {
      contents,
      systemInstruction: this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0 ? {
        parts: [{ text: this.buildSystemMessage() }]
      } : void 0,
      generationConfig: {
        temperature: this.plugin.settings.temperature,
        maxOutputTokens: this.plugin.settings.maxTokens
      }
    };
    if (this.activeMCPServers && this.activeMCPServers.length > 0) {
      const functionDeclarations = [];
      for (const server of this.activeMCPServers) {
        console.log(`Adding tools from MCP server (non-streaming): ${server.name}`, server);
        const tools = server.tools || [];
        for (const tool of tools) {
          let cleanedSchema = tool.inputSchema || {
            type: "object",
            properties: {},
            required: []
          };
          if (cleanedSchema && typeof cleanedSchema === "object") {
            const { $schema, additionalProperties, ...googleCompatibleSchema } = cleanedSchema;
            cleanedSchema = googleCompatibleSchema;
          }
          const functionDecl = {
            name: `${server.name}_${tool.name}`,
            description: tool.description || `Execute ${tool.name} from ${server.name}`,
            parameters: cleanedSchema
          };
          console.log(`Adding function declaration (non-streaming):`, functionDecl);
          functionDeclarations.push(functionDecl);
        }
      }
      if (functionDeclarations.length > 0) {
        requestBody.tools = [{
          functionDeclarations
        }];
        console.log(`Google API non-streaming request with ${functionDeclarations.length} MCP tools:`, requestBody.tools);
      }
    }
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.plugin.settings.model}:generateContent?key=${this.plugin.settings.googleApiKey}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error("Google API error details:", {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      if (response.status === 503 && retryCount < 2) {
        console.log(`Retrying Google API call (attempt ${retryCount + 1})...`);
        await new Promise((resolve) => setTimeout(resolve, 1e3 * (retryCount + 1)));
        return this.callGoogle(message, retryCount + 1);
      }
      throw new Error(`Google API error (${response.status}): ${response.statusText}. ${errorText || "Service temporarily unavailable"}`);
    }
    const data = await response.json();
    console.log("Google API non-streaming response:", data);
    const candidate = (_a = data == null ? void 0 : data.candidates) == null ? void 0 : _a[0];
    if (!candidate) {
      throw new Error("No candidate in Google API response");
    }
    const functionCall = (_c = (_b = candidate.content) == null ? void 0 : _b.parts) == null ? void 0 : _c.find((part) => part.functionCall);
    if (functionCall && functionCall.functionCall) {
      console.log("Found function call in non-streaming response:", functionCall.functionCall);
      try {
        const functionName = functionCall.functionCall.name;
        const functionArgs = functionCall.functionCall.args || {};
        if (!functionName) {
          throw new Error("Function call missing name");
        }
        const result = await this.executeMCPTool(functionName, functionArgs);
        console.log("MCP tool execution result (non-streaming):", result);
        const followUpContents = [...contents];
        followUpContents.push({
          role: "function",
          parts: [{
            functionResponse: {
              name: functionCall.functionCall.name,
              response: result
            }
          }]
        });
        const followUpResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.plugin.settings.model}:generateContent?key=${this.plugin.settings.googleApiKey}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            ...requestBody,
            contents: followUpContents
          })
        });
        if (followUpResponse.ok) {
          const followUpData = await followUpResponse.json();
          return followUpData.candidates[0].content.parts[0].text;
        }
      } catch (error) {
        console.error("MCP tool execution failed (non-streaming):", error);
        return `Error executing tool ${functionCall.functionCall.name}: ${error.message}`;
      }
    }
    return candidate.content.parts[0].text;
  }
  async streamGoogle(message, updateContent, finalizeContent) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    if (!this.plugin.settings.googleApiKey) {
      throw new Error("Please set your Google API key in settings");
    }
    console.log("Starting Google streaming...");
    const contents = [];
    let systemInstruction = null;
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      systemInstruction = { parts: [{ text: this.buildSystemMessage() }] };
      console.log("Google: Including system instruction");
    }
    this.chatHistory.forEach((msg) => {
      contents.push({
        role: msg.role === "user" ? "user" : "model",
        parts: [{ text: msg.content }]
      });
    });
    contents.push({
      role: "user",
      parts: [{ text: message }]
    });
    const requestBody = {
      contents,
      generationConfig: {
        temperature: this.plugin.settings.temperature,
        maxOutputTokens: this.plugin.settings.maxTokens
      }
    };
    if (this.activeMCPServers && this.activeMCPServers.length > 0) {
      const functionDeclarations = [];
      for (const server of this.activeMCPServers) {
        console.log(`Adding tools from MCP server: ${server.name}`, server);
        const tools = server.tools || [];
        for (const tool of tools) {
          let cleanedSchema = tool.inputSchema || {
            type: "object",
            properties: {},
            required: []
          };
          if (cleanedSchema && typeof cleanedSchema === "object") {
            const { $schema, additionalProperties, ...googleCompatibleSchema } = cleanedSchema;
            cleanedSchema = googleCompatibleSchema;
          }
          const functionDecl = {
            name: `${server.name}_${tool.name}`,
            description: tool.description || `Execute ${tool.name} from ${server.name}`,
            parameters: cleanedSchema
          };
          console.log(`Adding function declaration:`, functionDecl);
          functionDeclarations.push(functionDecl);
        }
      }
      if (functionDeclarations.length > 0) {
        requestBody.tools = [{
          functionDeclarations
        }];
        console.log(`Google API request with ${functionDeclarations.length} MCP tools:`, requestBody.tools);
      } else {
        console.log("No MCP tools available to add to Google function declarations");
      }
    } else {
      console.log("No active MCP servers for Google function calling");
    }
    if (systemInstruction) {
      requestBody.systemInstruction = systemInstruction;
    }
    console.log("Google request body:", requestBody);
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.plugin.settings.model}:streamGenerateContent?key=${this.plugin.settings.googleApiKey}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const error = await response.text();
      console.error("Google API error response:", error);
      throw new Error(`Google API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.trim() === "")
            continue;
          try {
            let jsonLine = line.trim();
            if (jsonLine.startsWith("data: ")) {
              jsonLine = jsonLine.slice(6).trim();
            }
            if (jsonLine === "[" || jsonLine === "]" || jsonLine === "") {
              continue;
            }
            if (jsonLine.endsWith(",")) {
              jsonLine = jsonLine.slice(0, -1);
            }
            const parsed = JSON.parse(jsonLine);
            console.log("Google streaming chunk:", parsed);
            const candidates = Array.isArray(parsed) ? parsed : [parsed];
            for (const item of candidates) {
              console.log("Processing Google streaming item:", item);
              const functionCall = (_e = (_d = (_c = (_b = (_a = item.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.functionCall;
              if (functionCall) {
                console.log("Found function call from Google:", functionCall);
                const mcpStatusEl = document.querySelector(".stella-mcp-status-floating");
                if (mcpStatusEl) {
                  mcpStatusEl.style.display = "block";
                  mcpStatusEl.textContent = `Executing: ${functionCall.name}`;
                }
                try {
                  const functionName = functionCall == null ? void 0 : functionCall.name;
                  const functionArgs = (functionCall == null ? void 0 : functionCall.args) || {};
                  if (!functionName) {
                    throw new Error("Function call missing name in streaming response");
                  }
                  console.log(`Executing MCP tool: ${functionName} with args:`, functionArgs);
                  const result = await this.executeMCPTool(functionName, functionArgs);
                  console.log("MCP tool execution result:", result);
                  contents.push({
                    role: "function",
                    parts: [{
                      functionResponse: {
                        name: functionCall.name,
                        response: result
                      }
                    }]
                  });
                  if (mcpStatusEl) {
                    mcpStatusEl.textContent = `Completed: ${functionCall.name}`;
                  }
                } catch (error) {
                  console.error("MCP tool execution error:", error);
                  if (mcpStatusEl) {
                    mcpStatusEl.textContent = `Error: ${functionCall.name}`;
                  }
                }
              }
              const content = (_j = (_i = (_h = (_g = (_f = item.candidates) == null ? void 0 : _f[0]) == null ? void 0 : _g.content) == null ? void 0 : _h.parts) == null ? void 0 : _i[0]) == null ? void 0 : _j.text;
              if (content) {
                updateContent(content);
              }
            }
          } catch (e) {
            console.log("Failed to parse Google streaming chunk:", line, e);
          }
        }
      }
      if (buffer.trim()) {
        try {
          const parsed = JSON.parse(buffer);
          const content = (_o = (_n = (_m = (_l = (_k = parsed.candidates) == null ? void 0 : _k[0]) == null ? void 0 : _l.content) == null ? void 0 : _m.parts) == null ? void 0 : _n[0]) == null ? void 0 : _o.text;
          if (content) {
            updateContent(content);
          }
        } catch (e) {
          console.log("Failed to parse final Google buffer:", buffer, e);
        }
      }
    } finally {
      reader.releaseLock();
    }
    await finalizeContent();
    console.log("Google streaming completed");
  }
  async callOllama(message) {
    let prompt = "";
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      prompt += this.buildSystemMessage() + "\n\n";
    }
    this.chatHistory.forEach((msg) => {
      const role = msg.role === "user" ? "User" : "Assistant";
      prompt += `${role}: ${msg.content}
`;
    });
    prompt += `User: ${message}
Assistant:`;
    const response = await fetch(`${this.plugin.settings.ollamaBaseUrl}/api/generate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        prompt,
        stream: false,
        options: {
          temperature: this.plugin.settings.temperature,
          num_predict: this.plugin.settings.maxTokens
        }
      })
    });
    if (!response.ok) {
      throw new Error(`Ollama API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.response;
  }
  async callLMStudio(message) {
    const messages = [];
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      messages.push({ role: "system", content: this.buildSystemMessage() });
    }
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const response = await fetch(`${this.plugin.settings.lmStudioBaseUrl}/v1/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        messages,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`LM Studio API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  async callCustomAPI(message) {
    if (!this.plugin.settings.customApiUrl) {
      throw new Error("Please set your custom API URL in settings");
    }
    const messages = [];
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      messages.push({ role: "system", content: this.buildSystemMessage() });
    }
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.plugin.settings.customApiKey) {
      headers["Authorization"] = `Bearer ${this.plugin.settings.customApiKey}`;
    }
    const response = await fetch(this.plugin.settings.customApiUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({
        model: this.plugin.settings.model,
        messages,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`Custom API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  // Streaming methods for providers without native streaming support
  async streamOllama(message, updateContent, finalizeContent) {
    const response = await this.callOllama(message);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      updateContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await finalizeContent();
  }
  async streamLMStudio(message, updateContent, finalizeContent) {
    const response = await this.callLMStudio(message);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      updateContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await finalizeContent();
  }
  async streamCustomAPI(message, updateContent, finalizeContent) {
    const response = await this.callCustomAPI(message);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      updateContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await finalizeContent();
  }
  // Fetch available models from each provider with caching
  async fetchAvailableModels() {
    const { provider } = this.plugin.settings;
    const cacheKey = CacheManager.modelListKey(provider);
    const cachedModels = this.plugin.cache.get(cacheKey);
    if (cachedModels) {
      this.logger.log(`Using cached models for ${provider}: ${cachedModels.length} models`);
      return cachedModels;
    }
    try {
      let models = [];
      switch (provider) {
        case "openai":
          models = await this.fetchOpenAIModels();
          break;
        case "anthropic":
          models = await this.fetchAnthropicModels();
          break;
        case "google":
          models = await this.fetchGoogleModels();
          break;
        case "ollama":
          models = await this.fetchOllamaModels();
          break;
        case "lmstudio":
          models = await this.fetchLMStudioModels();
          break;
        default:
          return [];
      }
      if (models.length > 0) {
        this.plugin.cache.set(cacheKey, models, 18e5);
        this.logger.log(`Cached ${models.length} models for ${provider}`);
      }
      return models;
    } catch (error) {
      this.logger.error(`Failed to fetch models for ${provider}:`, error);
      return [];
    }
  }
  async fetchOpenAIModels() {
    if (!this.plugin.settings.openaiApiKey)
      return [];
    const response = await FetchManager.enhancedFetch("https://api.openai.com/v1/models", {
      headers: {
        "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`
      }
    });
    if (!response.ok)
      return [];
    const data = await response.json();
    return data.data.filter((model) => model.id.includes("gpt")).map((model) => model.id).sort();
  }
  async fetchAnthropicModels() {
    if (!this.plugin.settings.anthropicApiKey)
      return [];
    try {
      const response = await FetchManager.enhancedFetch("https://api.anthropic.com/v1/models", {
        headers: {
          "x-api-key": this.plugin.settings.anthropicApiKey,
          "anthropic-version": "2023-06-01"
        }
      });
      if (!response.ok) {
        console.error("Anthropic API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("Anthropic API response:", data);
      if (!data.data)
        return [];
      return data.data.map((model) => model.id).sort();
    } catch (error) {
      console.error("Error fetching Anthropic models:", error);
      return [];
    }
  }
  async fetchGoogleModels() {
    if (!this.plugin.settings.googleApiKey)
      return [];
    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${this.plugin.settings.googleApiKey}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        console.error("Google API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("Google API response:", data);
      if (!data.models)
        return [];
      return data.models.filter((model) => {
        var _a;
        return (_a = model.supportedGenerationMethods) == null ? void 0 : _a.includes("generateContent");
      }).map((model) => {
        return model.name.replace("models/", "");
      }).sort();
    } catch (error) {
      console.error("Error fetching Google models:", error);
      return [];
    }
  }
  async fetchOllamaModels() {
    try {
      const response = await fetch(`${this.plugin.settings.ollamaBaseUrl}/api/tags`);
      if (!response.ok)
        return [];
      const data = await response.json();
      return data.models.map((model) => model.name);
    } catch (e) {
      return [];
    }
  }
  async fetchLMStudioModels() {
    try {
      const response = await fetch(`${this.plugin.settings.lmStudioBaseUrl}/v1/models`);
      if (!response.ok)
        return [];
      const data = await response.json();
      return data.data.map((model) => model.id);
    } catch (e) {
      return [];
    }
  }
  loadConversation(conversationId) {
    this.saveCurrentConversation();
    const conversation = this.plugin.settings.conversations.find((c) => c.id === conversationId);
    if (!conversation)
      return;
    this.currentConversationId = conversationId;
    this.plugin.settings.currentConversationId = conversationId;
    this.plugin.saveSettings();
    this.chatHistory = [...conversation.messages];
    this.conversationNameInput.value = conversation.title;
    this.currentSystemPrompt = conversation.systemPrompt || null;
    this.currentSystemPromptFilename = conversation.systemPromptFilename || null;
    this.currentMentalModel = conversation.mentalModel || null;
    this.currentMentalModelFilename = conversation.mentalModelFilename || null;
    this.messagesContainer.empty();
    this.initializeMessagePagination(conversation.messages);
    this.updateSystemPromptIndicator();
    this.updateMentalModelIndicator();
  }
  loadConversations() {
    this.cleanupEmptyConversations();
    const currentId = this.plugin.settings.currentConversationId;
    if (currentId) {
      const exists = this.plugin.settings.conversations.some((c) => c.id === currentId);
      if (exists) {
        this.loadConversation(currentId);
      } else {
        this.plugin.settings.currentConversationId = null;
        const now = new Date();
        const localDateStr = now.toLocaleDateString("en-CA");
        this.conversationNameInput.value = localDateStr;
      }
    } else {
      const now = new Date();
      const localDateStr = now.toLocaleDateString("en-CA");
      this.conversationNameInput.value = localDateStr;
    }
  }
  initializeMessagePagination(messages) {
    if (!messages || messages.length === 0)
      return;
    this.totalMessagePages = Math.ceil(messages.length / this.messagePageSize);
    this.currentMessagePage = messages.length > this.messagePageSize ? this.totalMessagePages - 1 : 0;
    this.renderMessagePage(messages);
    if (this.totalMessagePages > 1) {
      this.setupInfiniteScrolling(messages);
    }
  }
  renderMessagePage(allMessages) {
    const startIndex = this.currentMessagePage * this.messagePageSize;
    const endIndex = Math.min(startIndex + this.messagePageSize, allMessages.length);
    const pageMessages = allMessages.slice(startIndex, endIndex);
    if (this.currentMessagePage > 0 && !this.messagesContainer.querySelector(".stella-load-older-messages")) {
      const loadOlderBtn = this.messagesContainer.createDiv({
        cls: "stella-load-older-messages",
        text: `Load ${Math.min(this.messagePageSize, startIndex)} older messages...`
      });
      loadOlderBtn.addEventListener("click", () => {
        if (!this.isLoadingMoreMessages) {
          this.loadOlderMessages(allMessages);
        }
      });
    }
    pageMessages.forEach((msg) => {
      this.addMessageToUI(msg.content, msg.role);
    });
    if (this.currentMessagePage === this.totalMessagePages - 1) {
      setTimeout(() => {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      }, 100);
    }
  }
  async loadOlderMessages(allMessages) {
    if (this.isLoadingMoreMessages || this.currentMessagePage <= 0)
      return;
    this.isLoadingMoreMessages = true;
    const loadBtn = this.messagesContainer.querySelector(".stella-load-older-messages");
    if (loadBtn) {
      loadBtn.textContent = "Loading older messages...";
      loadBtn.classList.add("loading");
    }
    await new Promise((resolve) => setTimeout(resolve, 300));
    const scrollHeight = this.messagesContainer.scrollHeight;
    const scrollTop = this.messagesContainer.scrollTop;
    this.currentMessagePage--;
    const startIndex = this.currentMessagePage * this.messagePageSize;
    const endIndex = startIndex + this.messagePageSize;
    const olderMessages = allMessages.slice(startIndex, endIndex);
    if (loadBtn) {
      loadBtn.remove();
    }
    const tempContainer = document.createElement("div");
    olderMessages.forEach((msg) => {
      const messageEl = document.createElement("div");
      messageEl.className = `stella-message stella-message-${msg.role}`;
      const contentEl = document.createElement("div");
      contentEl.className = "stella-message-content";
      contentEl.textContent = msg.content;
      messageEl.appendChild(contentEl);
      tempContainer.appendChild(messageEl);
    });
    if (this.currentMessagePage > 0) {
      const newLoadBtn = document.createElement("div");
      newLoadBtn.className = "stella-load-older-messages";
      newLoadBtn.textContent = `Load ${Math.min(this.messagePageSize, startIndex)} older messages...`;
      newLoadBtn.addEventListener("click", () => {
        if (!this.isLoadingMoreMessages) {
          this.loadOlderMessages(allMessages);
        }
      });
      tempContainer.insertBefore(newLoadBtn, tempContainer.firstChild);
    }
    while (tempContainer.firstChild) {
      this.messagesContainer.insertBefore(tempContainer.firstChild, this.messagesContainer.firstChild);
    }
    const newScrollHeight = this.messagesContainer.scrollHeight;
    const scrollDiff = newScrollHeight - scrollHeight;
    this.messagesContainer.scrollTop = scrollTop + scrollDiff;
    this.isLoadingMoreMessages = false;
  }
  setupInfiniteScrolling(allMessages) {
    let scrollTimeout;
    this.messagesContainer.addEventListener("scroll", () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        const scrollTop = this.messagesContainer.scrollTop;
        if (scrollTop < 100 && this.currentMessagePage > 0 && !this.isLoadingMoreMessages) {
          this.loadOlderMessages(allMessages);
        }
      }, 150);
    });
  }
  switchConversation(conversationId) {
    if (conversationId === "new") {
      this.startNewConversation();
    }
  }
  async deleteCurrentConversationAndStartNew() {
    if (this.currentConversationId) {
      await this.deleteConversation(this.currentConversationId);
    } else {
      this.startNewConversation();
    }
  }
  startNewConversation() {
    if (this.currentConversationId) {
      this.cleanupIfEmpty(this.currentConversationId);
    }
    const now = new Date();
    const localDateStr = now.toLocaleDateString("en-CA");
    const dateTitle = localDateStr;
    const newConversation = {
      id: `conv_${Date.now()}`,
      title: dateTitle,
      messages: [],
      createdAt: now.getTime(),
      updatedAt: now.getTime()
    };
    this.plugin.settings.conversations.unshift(newConversation);
    this.plugin.settings.currentConversationId = newConversation.id;
    this.currentConversationId = newConversation.id;
    this.messagesContainer.empty();
    this.chatHistory = [];
    this.currentSystemPrompt = null;
    this.currentSystemPromptFilename = null;
    this.currentMentalModel = null;
    this.currentMentalModelFilename = null;
    this.conversationNameInput.value = dateTitle;
  }
  // Check if conversation title is a default date format (YYYY-MM-DD)
  isDefaultDateTitle(title) {
    return /^\d{4}-\d{2}-\d{2}$/.test(title);
  }
  // Check if a conversation is worth saving (has custom name or has messages)
  isWorthSaving(conversation) {
    const hasCustomName = !this.isDefaultDateTitle(conversation.title);
    const hasMessages = conversation.messages && conversation.messages.length > 0;
    return hasCustomName || hasMessages;
  }
  // Clean up a conversation if it's empty and unnamed
  cleanupIfEmpty(conversationId) {
    const conversation = this.plugin.settings.conversations.find((c) => c.id === conversationId);
    if (conversation && !this.isWorthSaving(conversation)) {
      this.plugin.settings.conversations = this.plugin.settings.conversations.filter((c) => c.id !== conversationId);
      console.log(`Cleaned up empty conversation: ${conversationId}`);
    }
  }
  // Clean up all empty/unnamed conversations (call periodically)
  cleanupEmptyConversations() {
    const before = this.plugin.settings.conversations.length;
    this.plugin.settings.conversations = this.plugin.settings.conversations.filter((c) => this.isWorthSaving(c));
    const removed = before - this.plugin.settings.conversations.length;
    if (removed > 0) {
      console.log(`Cleaned up ${removed} empty/unnamed conversations`);
      this.plugin.saveSettings();
    }
  }
  saveConversationName() {
    if (!this.currentConversationId)
      return;
    const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
    if (conversation) {
      conversation.title = this.conversationNameInput.value;
      conversation.updatedAt = Date.now();
      this.plugin.saveSettings();
      console.log(`Conversation named: ${conversation.title}`);
    }
  }
  saveCurrentConversation() {
    if (!this.currentConversationId)
      return;
    const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
    if (conversation) {
      conversation.messages = [...this.chatHistory];
      conversation.updatedAt = Date.now();
      if (this.isWorthSaving(conversation)) {
        this.plugin.saveSettings();
        this.updateConversationMetadataCache();
      }
    }
  }
  updateConversationMetadataCache() {
    const metadata = this.plugin.settings.conversations.map((conv) => ({
      id: conv.id,
      title: conv.title,
      messageCount: conv.messages.length,
      createdAt: conv.createdAt,
      updatedAt: conv.updatedAt,
      hasSystemPrompt: !!conv.systemPrompt,
      hasMentalModel: !!conv.mentalModel
    }));
    this.plugin.cache.set(CacheManager.conversationMetaKey(), metadata, 3e5);
    this.logger.log(`Updated conversation metadata cache: ${metadata.length} conversations`);
  }
  async deleteConversation(conversationId) {
    this.plugin.settings.conversations = this.plugin.settings.conversations.filter(
      (conv) => conv.id !== conversationId
    );
    if (this.currentConversationId === conversationId) {
      this.startNewConversation();
    }
    await this.plugin.saveSettings();
    this.plugin.cache.invalidateConversationData();
  }
  showChatHistory() {
    this.saveCurrentConversation();
    const modal = new ConversationHistoryModal(
      this.app,
      {
        conversations: this.plugin.settings.conversations,
        currentConversationId: this.currentConversationId
      },
      {
        onSelect: (conversationId) => {
          this.loadConversation(conversationId);
        },
        onDelete: async (conversationId) => {
          await this.deleteConversation(conversationId);
        }
      }
    );
    modal.open();
  }
  async showSystemPromptSelector() {
    const resolvedPath = this.resolveVaultPath(this.plugin.settings.systemPromptsPath);
    if (!resolvedPath) {
      new import_obsidian4.Notice("System prompts directory not configured. Please set it in plugin settings.");
      return;
    }
    const modal = createSystemPromptModal(
      this.app,
      resolvedPath,
      {
        onSelect: async (filePath, _filename) => {
          await this.loadSystemPrompt(filePath);
        },
        onClose: () => {
          setTimeout(() => this.chatInput.focus(), 100);
        }
      }
    );
    modal.open();
  }
  // Helper method to resolve vault-relative paths to absolute paths
  resolveVaultPath(inputPath) {
    if (!inputPath)
      return null;
    const isAbsolutePath = inputPath.startsWith("/") || /^[A-Za-z]:[\\/]/.test(inputPath);
    if (isAbsolutePath)
      return inputPath;
    const adapter = this.app.vault.adapter;
    let vaultPath = null;
    if (adapter.path) {
      vaultPath = adapter.path;
    } else if (adapter.basePath) {
      vaultPath = adapter.basePath;
    } else if (adapter.getBasePath) {
      vaultPath = adapter.getBasePath();
    }
    if (vaultPath && typeof vaultPath === "string") {
      const path = require("path");
      return path.join(vaultPath, inputPath);
    }
    const vaultName = this.app.vault.getName();
    if (vaultName) {
      const path = require("path");
      const process2 = require("process");
      return path.join(process2.cwd(), vaultName, inputPath);
    }
    return null;
  }
  async loadSystemPrompt(filepath) {
    try {
      const fs = require("fs");
      const path = require("path");
      const content = fs.readFileSync(filepath, "utf8");
      const filename = path.basename(filepath, path.extname(filepath));
      this.currentSystemPrompt = content;
      this.currentSystemPromptFilename = filename;
      console.log("System prompt loaded:", filename);
      if (this.currentConversationId) {
        const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
        if (conversation) {
          conversation.systemPrompt = content;
          conversation.systemPromptFilename = filename;
          conversation.updatedAt = Date.now();
          this.plugin.saveSettings();
          console.log("System prompt saved to conversation:", filename);
        }
      }
      this.updateSystemPromptIndicator();
    } catch (error) {
      this.addMessage(`Error loading system prompt: ${error.message}`, "error");
    }
  }
  unloadSystemPrompt() {
    this.currentSystemPrompt = null;
    this.currentSystemPromptFilename = null;
    console.log("System prompt unloaded");
    if (this.currentConversationId) {
      const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
      if (conversation) {
        conversation.systemPrompt = void 0;
        conversation.systemPromptFilename = void 0;
        conversation.updatedAt = Date.now();
        this.plugin.saveSettings();
        console.log("System prompt removed from conversation");
      }
    }
    this.updateSystemPromptIndicator();
  }
  async showNoteSelector() {
    const modal = new NoteSelectorModal(
      this.app,
      {
        onSelect: (filename, content) => {
          this.contextNotes.push({ name: filename, content });
          this.updateContextIndicator();
          console.log(`Added note context: ${filename}`);
        },
        onClose: () => {
        }
      }
    );
    modal.open();
  }
  async addNoteContext(file) {
    try {
      const content = await this.app.vault.read(file);
      this.contextNotes.push({
        name: file.basename,
        content
      });
      this.updateContextIndicator();
      console.log(`Added note context: ${file.basename}`);
    } catch (error) {
      this.addMessage(`Error reading note: ${error.message}`, "error");
    }
  }
  removeNoteContext(index) {
    if (index >= 0 && index < this.contextNotes.length) {
      const removed = this.contextNotes.splice(index, 1)[0];
      this.updateContextIndicator();
      console.log(`Removed note context: ${removed.name}`);
    }
  }
  showNoteContextManager() {
    const modal = new import_obsidian4.Modal(this.app);
    modal.titleEl.setText("Manage Note Context");
    const container = modal.contentEl.createDiv({ cls: "stella-note-manager-container" });
    if (this.contextNotes.length === 0) {
      container.createEl("p", { text: "No notes are currently loaded in context." });
      const addButton = container.createEl("button", {
        text: "Add Notes",
        cls: "mod-cta"
      });
      addButton.addEventListener("click", () => {
        modal.close();
        this.showNoteSelector();
      });
    } else {
      container.createEl("p", { text: `${this.contextNotes.length} note(s) loaded in context:` });
      const notesList = container.createEl("div", { cls: "stella-notes-manager-list" });
      this.contextNotes.forEach((note, index) => {
        const noteItem = notesList.createDiv({ cls: "stella-note-manager-item" });
        const noteName = noteItem.createEl("span", {
          text: note.name,
          cls: "stella-note-name"
        });
        const removeButton = noteItem.createEl("button", {
          text: "\xD7",
          cls: "stella-note-remove-btn"
        });
        removeButton.addEventListener("click", () => {
          this.removeNoteContext(index);
          modal.close();
        });
      });
      const buttonContainer = container.createEl("div", { cls: "stella-note-manager-buttons" });
      const addMoreButton = buttonContainer.createEl("button", {
        text: "Add More Notes",
        cls: "mod-secondary"
      });
      addMoreButton.addEventListener("click", () => {
        modal.close();
        this.showNoteSelector();
      });
      const clearAllButton = buttonContainer.createEl("button", {
        text: "Clear All",
        cls: "mod-warning"
      });
      clearAllButton.addEventListener("click", () => {
        this.contextNotes = [];
        this.updateContextIndicator();
        modal.close();
      });
    }
    modal.open();
  }
  showHelpMessage() {
    const helpText = "Available Commands:\n\n" + this.availableCommands.map((cmd) => `${cmd.command.padEnd(12)} - ${cmd.description}`).join("\n");
    const messageEl = this.addMessage(helpText, "system");
    const contentEl = messageEl.querySelector(".stella-message-content");
    if (contentEl) {
      contentEl.style.fontFamily = "var(--font-monospace)";
      contentEl.style.whiteSpace = "pre-line";
      contentEl.style.backgroundColor = "var(--background-secondary)";
      contentEl.style.padding = "12px";
      contentEl.style.borderRadius = "4px";
      contentEl.style.fontSize = "13px";
    }
  }
  updateContextIndicator() {
    if (this.contextIndicator) {
      this.contextIndicator.style.display = "none";
    }
    this.updateNoteIndicator();
  }
  updateNoteIndicator() {
    var _a;
    if (!this.noteIndicator)
      return;
    const newNoteIndicator = this.noteIndicator.cloneNode(true);
    (_a = this.noteIndicator.parentNode) == null ? void 0 : _a.replaceChild(newNoteIndicator, this.noteIndicator);
    this.noteIndicator = newNoteIndicator;
    if (this.contextNotes.length > 0) {
      this.noteIndicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>';
      this.noteIndicator.style.display = "block";
      this.noteIndicator.addEventListener("click", (e) => {
        e.preventDefault();
        this.showNoteContextManager();
      });
      let tooltipElement = null;
      this.noteIndicator.addEventListener("mouseenter", (e) => {
        if (tooltipElement) {
          tooltipElement.remove();
        }
        const notesList = this.contextNotes.map((note) => `\u2022 ${note.name}`).join("\n");
        const tooltipText = `Loaded notes:
${notesList}`;
        tooltipElement = document.body.createEl("div", {
          cls: "stella-tooltip",
          text: tooltipText
        });
        const rect = this.noteIndicator.getBoundingClientRect();
        const tooltipRect = tooltipElement.getBoundingClientRect();
        const left = rect.left + rect.width / 2 - tooltipRect.width / 2;
        const top = rect.top - tooltipRect.height - 10;
        tooltipElement.style.position = "fixed";
        tooltipElement.style.left = `${Math.max(10, left)}px`;
        tooltipElement.style.top = `${Math.max(10, top)}px`;
        tooltipElement.style.zIndex = "10000";
      });
      this.noteIndicator.addEventListener("mouseleave", () => {
        if (tooltipElement) {
          tooltipElement.remove();
          tooltipElement = null;
        }
      });
    } else {
      this.noteIndicator.innerHTML = "";
      this.noteIndicator.style.display = "none";
    }
    this.updateIndicatorPositions();
  }
  buildSystemMessage() {
    let systemMessage = "";
    if (this.currentSystemPrompt) {
      systemMessage += this.currentSystemPrompt;
    }
    if (this.currentMentalModel) {
      if (systemMessage) {
        systemMessage += "\n\n";
      }
      systemMessage += this.currentMentalModel;
    }
    if (this.contextNotes.length > 0) {
      if (systemMessage) {
        systemMessage += "\n\n";
      }
      systemMessage += "Here are reference notes that may be relevant to the conversation:\n\n";
      systemMessage += this.contextNotes.map(
        (note) => `=== Note: ${note.name} ===
${note.content}
`
      ).join("\n");
    }
    try {
      if (this.activeMCPServers && Array.isArray(this.activeMCPServers) && this.activeMCPServers.length > 0) {
        console.log("buildSystemMessage: Adding MCP tools to system message", this.activeMCPServers);
        if (systemMessage) {
          systemMessage += "\n\n";
        }
        systemMessage += "You have access to the following MCP (Model Context Protocol) tools through Google's function calling system:\n\n";
        let totalToolCount = 0;
        for (const serverInfo of this.activeMCPServers) {
          try {
            if (!serverInfo) {
              console.warn("buildSystemMessage: Skipping null/undefined server");
              continue;
            }
            console.log(`buildSystemMessage: Processing server ${serverInfo.name || "unknown"}`, serverInfo);
            const tools = Array.isArray(serverInfo.tools) ? serverInfo.tools : [];
            const prompts = Array.isArray(serverInfo.prompts) ? serverInfo.prompts : [];
            const highlighted = Array.isArray(serverInfo.highlightedTools) ? serverInfo.highlightedTools : [];
            totalToolCount += tools.length;
            if (tools.length > 0) {
              systemMessage += `=== ${serverInfo.name} Server Tools ===
`;
              for (const tool of tools) {
                try {
                  if (tool && tool.name) {
                    const functionName = `${serverInfo.name}_${tool.name}`;
                    const isHighlighted = highlighted.includes(tool.name);
                    if (isHighlighted) {
                      systemMessage += `\u2022 **PREFERRED** Function: ${functionName}`;
                      if (tool.description) {
                        systemMessage += ` - ${tool.description}`;
                      }
                      systemMessage += "\n  (User explicitly selected this tool - use it when relevant)\n";
                    } else {
                      systemMessage += `\u2022 Function: ${functionName}`;
                      if (tool.description) {
                        systemMessage += ` - ${tool.description}`;
                      }
                      systemMessage += "\n";
                    }
                    if (tool.inputSchema && tool.inputSchema.properties) {
                      const properties = Object.keys(tool.inputSchema.properties);
                      if (properties.length > 0) {
                        systemMessage += `  Parameters: ${properties.join(", ")}
`;
                      }
                    }
                  }
                } catch (toolError) {
                  console.error("Error processing tool:", tool, toolError);
                }
              }
              systemMessage += "\n";
            }
            if (prompts.length > 0) {
              systemMessage += `=== ${serverInfo.name} Server Prompts ===
`;
              for (const prompt of prompts) {
                try {
                  if (prompt && prompt.name) {
                    systemMessage += `\u2022 ${prompt.name}`;
                    if (prompt.description) {
                      systemMessage += ` - ${prompt.description}`;
                    }
                    systemMessage += "\n";
                  }
                } catch (promptError) {
                  console.error("Error processing prompt:", prompt, promptError);
                }
              }
              systemMessage += "\n";
            }
          } catch (serverError) {
            console.error(`buildSystemMessage: Error processing server ${(serverInfo == null ? void 0 : serverInfo.name) || "unknown"}:`, serverError);
            systemMessage += `=== ${(serverInfo == null ? void 0 : serverInfo.name) || "Unknown Server"} Server ===
(Error loading tools/prompts)

`;
          }
        }
        if (totalToolCount > 3) {
          systemMessage += "\n**DISAMBIGUATION**: If the user's request could apply to multiple tools, ask for clarification about which specific tool or action they want before proceeding.\n";
        }
        systemMessage += "\nIMPORTANT: You can call these functions directly using Google's function calling capability. When you need to use a tool, call the corresponding function and I will automatically execute it and return the results to you. Do not ask the user to run tools - call them directly when needed.";
        console.log("buildSystemMessage: Final system message with MCP info:", systemMessage);
      }
    } catch (mcpError) {
      console.error("buildSystemMessage: Error processing MCP servers:", mcpError, this.activeMCPServers);
      if (systemMessage)
        systemMessage += "\n\n";
      systemMessage += "=== MCP Integration ===\n(Error loading MCP server information)\n\n";
    }
    return systemMessage;
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById("stella-mcp");
  }
  updateModelInfo(container) {
    const { provider, model } = this.plugin.settings;
    const providerName = provider === "anthropic" ? "claude" : provider === "openai" ? "openai" : provider === "google" ? "google" : provider === "ollama" ? "ollama" : provider === "lmstudio" ? "lm-studio" : "custom";
    if (!model || model.trim() === "") {
      container.textContent = `${providerName}: no model selected`;
    } else {
      container.textContent = `${providerName}: ${model}`;
    }
  }
  updateSystemPromptIndicator() {
    if (!this.systemPromptIndicator)
      return;
    if (this.currentSystemPrompt) {
      this.systemPromptIndicator.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M7 7l4 4-4 4"></path><path d="M13 15h4"></path></svg>';
      this.systemPromptIndicator.style.display = "block";
      const promptName = this.currentSystemPromptFilename || "System Prompt";
      this.systemPromptIndicator.setAttribute("title", promptName);
    } else {
      this.systemPromptIndicator.innerHTML = "";
      this.systemPromptIndicator.style.display = "none";
    }
    this.updateIndicatorPositions();
  }
  updateMentalModelIndicator() {
    if (!this.mentalModelIndicator)
      return;
    if (this.currentMentalModel) {
      this.mentalModelIndicator.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a7 7 0 1 0 10 10"/></svg>';
      this.mentalModelIndicator.style.display = "block";
      const modelName = this.currentMentalModelFilename || "Mental Model";
      this.mentalModelIndicator.setAttribute("title", modelName);
    } else {
      this.mentalModelIndicator.innerHTML = "";
      this.mentalModelIndicator.style.display = "none";
    }
    this.updateIndicatorPositions();
  }
  updateIndicatorPositions() {
    if (!this.systemPromptIndicator || !this.mentalModelIndicator || !this.mcpIndicator || !this.noteIndicator)
      return;
    const hasSystemPrompt = this.currentSystemPrompt !== null;
    const hasMentalModel = this.currentMentalModel !== null;
    const hasMCP = this.activeMCPServers && this.activeMCPServers.length > 0;
    const hasNotes = this.contextNotes.length > 0;
    this.systemPromptIndicator.style.right = "";
    this.mentalModelIndicator.style.right = "";
    this.mcpIndicator.style.right = "";
    this.noteIndicator.style.right = "";
    const activeIndicators = [];
    if (hasSystemPrompt)
      activeIndicators.push("system");
    if (hasMentalModel)
      activeIndicators.push("mental");
    if (hasMCP)
      activeIndicators.push("mcp");
    if (hasNotes)
      activeIndicators.push("note");
    activeIndicators.forEach((type, index) => {
      const rightPosition = 16 + index * 32;
      if (type === "system") {
        this.systemPromptIndicator.style.right = `${rightPosition}px`;
      } else if (type === "mental") {
        this.mentalModelIndicator.style.right = `${rightPosition}px`;
      } else if (type === "mcp") {
        this.mcpIndicator.style.right = `${rightPosition}px`;
      } else if (type === "note") {
        this.noteIndicator.style.right = `${rightPosition}px`;
      }
    });
  }
  async showMentalModelSelector() {
    const resolvedPath = this.resolveVaultPath(this.plugin.settings.mentalModelsPath);
    if (!resolvedPath) {
      new import_obsidian4.Notice("Mental models directory not configured. Please set it in plugin settings.");
      return;
    }
    const modal = createMentalModelModal(
      this.app,
      resolvedPath,
      {
        onSelect: async (filePath, _filename) => {
          await this.loadMentalModel(filePath);
        },
        onClose: () => {
          setTimeout(() => this.chatInput.focus(), 100);
        }
      }
    );
    modal.open();
  }
  async loadMentalModel(filepath) {
    try {
      const fs = require("fs");
      const path = require("path");
      const content = fs.readFileSync(filepath, "utf8");
      const filename = path.basename(filepath, path.extname(filepath));
      this.currentMentalModel = content;
      this.currentMentalModelFilename = filename;
      console.log("Mental model loaded:", filename);
      if (this.currentConversationId) {
        const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
        if (conversation) {
          conversation.mentalModel = content;
          conversation.mentalModelFilename = filename;
          conversation.updatedAt = Date.now();
          this.plugin.saveSettings();
          console.log("Mental model saved to conversation:", filename);
        }
      }
      this.updateMentalModelIndicator();
    } catch (error) {
      this.addMessage(`Error loading mental model: ${error.message}`, "error");
    }
  }
  unloadMentalModel() {
    this.currentMentalModel = null;
    this.currentMentalModelFilename = null;
    console.log("Mental model unloaded");
    if (this.currentConversationId) {
      const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
      if (conversation) {
        conversation.mentalModel = void 0;
        conversation.mentalModelFilename = void 0;
        conversation.updatedAt = Date.now();
        this.plugin.saveSettings();
        console.log("Mental model removed from conversation");
      }
    }
    this.updateMentalModelIndicator();
  }
  async showMCPSelector() {
    const modal = new import_obsidian4.Modal(this.app);
    modal.titleEl.setText("MCP Servers");
    modal.modalEl.style.width = "70vw";
    modal.modalEl.style.height = "70vh";
    modal.modalEl.style.maxWidth = "1000px";
    modal.modalEl.style.minWidth = "600px";
    const contentEl = modal.contentEl;
    contentEl.empty();
    modal.open();
    try {
      const mcpManager = this.plugin.mcpClientManager;
      let servers = [];
      if (mcpManager) {
        servers = Array.from(mcpManager.getServers().values());
      }
      const configuredServers = this.plugin.settings.mcpServers || [];
      console.log(`MCP Modal: Found ${servers.length} in manager, ${configuredServers.length} in settings`);
      if (servers.length === 0 && configuredServers.length === 0) {
        this.showAddServerForm(contentEl, modal);
        return;
      }
      if (servers.length === 0 && configuredServers.length > 0 && mcpManager) {
        contentEl.createEl("p", { text: "Connecting to configured servers..." });
        for (const serverConfig of configuredServers) {
          try {
            await mcpManager.addServer(serverConfig);
          } catch (e) {
            console.error(`Failed to add server ${serverConfig.name}:`, e);
          }
        }
        servers = Array.from(mcpManager.getServers().values());
        contentEl.empty();
      }
      if (servers.length === 0) {
        this.showAddServerForm(contentEl, modal);
        return;
      }
      for (const server of servers) {
        if (server.connected && mcpManager) {
          mcpManager.refreshServerTools(server.id).catch(() => {
          });
          mcpManager.refreshServerPrompts(server.id).catch(() => {
          });
        }
      }
      const mainContainer = contentEl.createDiv();
      mainContainer.style.display = "flex";
      mainContainer.style.height = "100%";
      mainContainer.style.gap = "16px";
      const leftPanel = mainContainer.createDiv();
      leftPanel.style.width = "40%";
      leftPanel.style.borderRight = "1px solid var(--background-modifier-border)";
      leftPanel.style.paddingRight = "16px";
      const rightPanel = mainContainer.createDiv();
      rightPanel.style.width = "60%";
      const serverList = leftPanel.createDiv();
      serverList.style.maxHeight = "calc(70vh - 100px)";
      serverList.style.overflowY = "auto";
      const previewContent = rightPanel.createDiv();
      previewContent.style.maxHeight = "calc(70vh - 100px)";
      previewContent.style.overflowY = "auto";
      previewContent.textContent = "Select a server to view tools & prompts";
      let selectedIndex = 0;
      const mcpServerItems = [];
      servers.forEach((server, index) => {
        var _a;
        const serverItem = serverList.createDiv();
        serverItem.style.padding = "12px";
        serverItem.style.marginBottom = "8px";
        serverItem.style.cursor = "pointer";
        serverItem.style.borderRadius = "4px";
        serverItem.style.border = "1px solid transparent";
        serverItem.style.backgroundColor = "var(--background-secondary)";
        const isActive = (_a = this.activeMCPServers) == null ? void 0 : _a.some((s) => s.name === server.name);
        if (index === 0) {
          serverItem.style.backgroundColor = "var(--background-modifier-hover)";
          serverItem.style.border = "1px solid var(--accent-color)";
          serverItem.classList.add("selected");
        }
        if (isActive) {
          serverItem.style.borderLeft = "3px solid var(--interactive-accent)";
        }
        const toggleContainer = serverItem.createDiv();
        toggleContainer.style.display = "flex";
        toggleContainer.style.justifyContent = "space-between";
        toggleContainer.style.alignItems = "center";
        toggleContainer.style.marginBottom = "4px";
        const nameEl = toggleContainer.createDiv();
        nameEl.textContent = server.name;
        nameEl.style.fontWeight = "500";
        const toggleSwitch = toggleContainer.createEl("div");
        toggleSwitch.className = "stella-mcp-toggle";
        toggleSwitch.style.cssText = `
                    width: 40px; height: 22px;
                    background: ${isActive ? "var(--interactive-accent)" : "var(--background-modifier-border)"};
                    border-radius: 11px; cursor: pointer; position: relative;
                    transition: background 0.2s ease; flex-shrink: 0;
                `;
        const toggleKnob = toggleSwitch.createEl("div");
        toggleKnob.style.cssText = `
                    width: 18px; height: 18px;
                    background: white; border-radius: 50%;
                    position: absolute; top: 2px;
                    left: ${isActive ? "20px" : "2px"};
                    transition: left 0.2s ease;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                `;
        toggleSwitch.onclick = (e) => {
          e.stopPropagation();
          const newState = this.toggleMCPServer(server);
          toggleSwitch.style.background = newState ? "var(--interactive-accent)" : "var(--background-modifier-border)";
          toggleKnob.style.left = newState ? "20px" : "2px";
          serverItem.style.borderLeft = newState ? "3px solid var(--interactive-accent)" : "none";
        };
        const statusEl = serverItem.createDiv();
        statusEl.textContent = server.connected ? "Connected" : "Disconnected";
        statusEl.style.fontSize = "12px";
        statusEl.style.color = server.connected ? "var(--text-success)" : "var(--text-error)";
        mcpServerItems.push(serverItem);
        serverItem.onclick = () => {
          var _a2;
          mcpServerItems.forEach((el, i) => {
            var _a3;
            el.style.backgroundColor = "var(--background-secondary)";
            el.style.border = "1px solid transparent";
            el.classList.remove("selected");
            if ((_a3 = this.activeMCPServers) == null ? void 0 : _a3.some((s) => {
              var _a4;
              return s.name === ((_a4 = servers[i]) == null ? void 0 : _a4.name);
            })) {
              el.style.borderLeft = "3px solid var(--interactive-accent)";
            }
          });
          serverItem.style.backgroundColor = "var(--background-modifier-hover)";
          serverItem.style.border = "1px solid var(--accent-color)";
          if (isActive || ((_a2 = this.activeMCPServers) == null ? void 0 : _a2.some((s) => s.name === server.name))) {
            serverItem.style.borderLeft = "3px solid var(--interactive-accent)";
          }
          serverItem.classList.add("selected");
          selectedIndex = index;
          showPreview(server);
        };
      });
      const addServerBtn = serverList.createDiv();
      addServerBtn.style.padding = "12px";
      addServerBtn.style.marginTop = "8px";
      addServerBtn.style.cursor = "pointer";
      addServerBtn.style.borderRadius = "4px";
      addServerBtn.style.border = "1px dashed var(--background-modifier-border)";
      addServerBtn.style.textAlign = "center";
      addServerBtn.style.color = "var(--text-muted)";
      addServerBtn.textContent = "+ Add Server";
      addServerBtn.addEventListener("mouseenter", () => {
        addServerBtn.style.backgroundColor = "var(--background-modifier-hover)";
        addServerBtn.style.color = "var(--text-normal)";
      });
      addServerBtn.addEventListener("mouseleave", () => {
        addServerBtn.style.backgroundColor = "transparent";
        addServerBtn.style.color = "var(--text-muted)";
      });
      addServerBtn.onclick = () => {
        this.showAddServerForm(contentEl, modal);
      };
      const showPreview = async (server) => {
        previewContent.innerHTML = "";
        const header = previewContent.createDiv();
        header.style.marginBottom = "16px";
        const title = header.createEl("h3");
        title.textContent = server.name;
        title.style.margin = "0 0 8px 0";
        const status = header.createDiv();
        status.textContent = server.connected ? "Connected" : "Disconnected";
        status.style.color = server.connected ? "var(--text-success)" : "var(--text-error)";
        status.style.fontSize = "14px";
        const tools = mcpManager.getTools().get(server.id) || [];
        const prompts = mcpManager.getPrompts().get(server.id) || [];
        if (tools.length > 0) {
          const toolsSection = previewContent.createDiv();
          toolsSection.style.marginBottom = "16px";
          const toolsTitle = toolsSection.createEl("h4");
          toolsTitle.textContent = `Tools (${tools.length})`;
          toolsTitle.style.margin = "0 0 8px 0";
          toolsTitle.style.fontSize = "16px";
          tools.forEach((tool) => {
            const toolItem = toolsSection.createDiv();
            toolItem.style.padding = "8px";
            toolItem.style.marginBottom = "4px";
            toolItem.style.backgroundColor = "var(--background-secondary)";
            toolItem.style.borderRadius = "4px";
            toolItem.style.cursor = "pointer";
            toolItem.style.border = "1px solid transparent";
            toolItem.addEventListener("mouseenter", () => {
              toolItem.style.backgroundColor = "var(--background-modifier-hover)";
              toolItem.style.border = "1px solid var(--accent-color)";
            });
            toolItem.addEventListener("mouseleave", () => {
              toolItem.style.backgroundColor = "var(--background-secondary)";
              toolItem.style.border = "1px solid transparent";
            });
            const toolName = toolItem.createDiv();
            toolName.textContent = tool.name;
            toolName.style.fontWeight = "500";
            if (tool.description) {
              const desc = toolItem.createDiv();
              desc.textContent = tool.description;
              desc.style.fontSize = "12px";
              desc.style.color = "var(--text-muted)";
              desc.style.marginTop = "4px";
            }
            toolItem.onclick = () => {
              this.activateMCPTool(server.name, tool);
              modal.close();
              setTimeout(() => this.chatInput.focus(), 100);
            };
          });
        }
        if (prompts.length > 0) {
          const promptsSection = previewContent.createDiv();
          const promptsTitle = promptsSection.createEl("h4");
          promptsTitle.textContent = `Prompts (${prompts.length})`;
          promptsTitle.style.margin = "0 0 8px 0";
          promptsTitle.style.fontSize = "16px";
          prompts.forEach((prompt) => {
            const promptItem = promptsSection.createDiv();
            promptItem.style.padding = "8px";
            promptItem.style.marginBottom = "4px";
            promptItem.style.backgroundColor = "var(--background-secondary)";
            promptItem.style.borderRadius = "4px";
            promptItem.style.cursor = "pointer";
            promptItem.style.border = "1px solid transparent";
            promptItem.addEventListener("mouseenter", () => {
              promptItem.style.backgroundColor = "var(--background-modifier-hover)";
              promptItem.style.border = "1px solid var(--accent-color)";
            });
            promptItem.addEventListener("mouseleave", () => {
              promptItem.style.backgroundColor = "var(--background-secondary)";
              promptItem.style.border = "1px solid transparent";
            });
            const promptName = promptItem.createDiv();
            promptName.textContent = prompt.name;
            promptName.style.fontWeight = "500";
            if (prompt.description) {
              const desc = promptItem.createDiv();
              desc.textContent = prompt.description;
              desc.style.fontSize = "12px";
              desc.style.color = "var(--text-muted)";
              desc.style.marginTop = "4px";
            }
            promptItem.onclick = () => {
              this.activateMCPPrompt(server.name, prompt);
              modal.close();
              setTimeout(() => this.chatInput.focus(), 100);
            };
          });
        }
        if (tools.length === 0 && prompts.length === 0) {
          const emptyMsg = previewContent.createDiv();
          emptyMsg.textContent = "No tools or prompts available for this server.";
          emptyMsg.style.color = "var(--text-muted)";
          emptyMsg.style.fontStyle = "italic";
        }
      };
      const handleKeydown = (e) => {
        if (e.key === "ArrowUp") {
          e.preventDefault();
          selectedIndex = selectedIndex === 0 ? servers.length - 1 : selectedIndex - 1;
          mcpServerItems.forEach((el) => {
            el.style.backgroundColor = "var(--background-secondary)";
            el.style.border = "1px solid transparent";
            el.classList.remove("selected");
          });
          mcpServerItems[selectedIndex].style.backgroundColor = "var(--background-modifier-hover)";
          mcpServerItems[selectedIndex].style.border = "1px solid var(--accent-color)";
          mcpServerItems[selectedIndex].classList.add("selected");
          showPreview(servers[selectedIndex]);
          mcpServerItems[selectedIndex].scrollIntoView({ behavior: "smooth", block: "nearest" });
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          selectedIndex = (selectedIndex + 1) % servers.length;
          mcpServerItems.forEach((el) => {
            el.style.backgroundColor = "var(--background-secondary)";
            el.style.border = "1px solid transparent";
            el.classList.remove("selected");
          });
          mcpServerItems[selectedIndex].style.backgroundColor = "var(--background-modifier-hover)";
          mcpServerItems[selectedIndex].style.border = "1px solid var(--accent-color)";
          mcpServerItems[selectedIndex].classList.add("selected");
          showPreview(servers[selectedIndex]);
          mcpServerItems[selectedIndex].scrollIntoView({ behavior: "smooth", block: "nearest" });
        } else if (e.key === "Enter") {
          e.preventDefault();
          this.activateMCPServer(servers[selectedIndex]);
          modal.close();
          setTimeout(() => this.chatInput.focus(), 100);
        } else if (e.key === "Escape") {
          modal.close();
        }
      };
      modal.modalEl.addEventListener("keydown", handleKeydown);
      modal.onClose = () => {
        modal.modalEl.removeEventListener("keydown", handleKeydown);
      };
      modal.modalEl.setAttribute("tabindex", "-1");
      modal.modalEl.focus();
      if (servers.length > 0) {
        showPreview(servers[0]);
      }
    } catch (error) {
      console.error("Error in MCP selector:", error);
      contentEl.createEl("p", { text: `Error loading MCP data: ${error.message}` });
    }
  }
  showAddServerForm(contentEl, modal) {
    contentEl.empty();
    const formContainer = contentEl.createDiv();
    formContainer.style.padding = "16px";
    formContainer.style.maxWidth = "500px";
    formContainer.style.margin = "0 auto";
    formContainer.createEl("h3", { text: "Add MCP Server" });
    formContainer.createEl("p", {
      text: "Configure a new MCP server to enable AI tools.",
      cls: "setting-item-description"
    });
    let selectedTransport = "stdio";
    let nameInput;
    let commandInput;
    let argsInput;
    let endpointInput;
    let envVars = [];
    const nameContainer = formContainer.createDiv();
    nameContainer.style.marginTop = "16px";
    nameContainer.createEl("label", { text: "Server Name" });
    nameInput = nameContainer.createEl("input", {
      type: "text",
      attr: { placeholder: "e.g., Filesystem, GitHub, etc." }
    });
    nameInput.style.width = "100%";
    nameInput.style.marginTop = "4px";
    nameInput.style.padding = "8px";
    const transportContainer = formContainer.createDiv();
    transportContainer.style.marginTop = "16px";
    transportContainer.createEl("label", { text: "Server Type" });
    const transportToggle = transportContainer.createDiv();
    transportToggle.style.marginTop = "8px";
    transportToggle.style.display = "flex";
    transportToggle.style.gap = "16px";
    const stdioOption = transportToggle.createEl("label");
    stdioOption.style.cursor = "pointer";
    stdioOption.style.display = "flex";
    stdioOption.style.alignItems = "center";
    stdioOption.style.gap = "6px";
    const stdioRadio = stdioOption.createEl("input", { type: "radio", value: "stdio" });
    stdioRadio.name = "transport";
    stdioRadio.checked = true;
    stdioOption.createSpan({ text: "Local (stdio)" });
    const httpOption = transportToggle.createEl("label");
    httpOption.style.cursor = "pointer";
    httpOption.style.display = "flex";
    httpOption.style.alignItems = "center";
    httpOption.style.gap = "6px";
    const httpRadio = httpOption.createEl("input", { type: "radio", value: "http" });
    httpRadio.name = "transport";
    httpOption.createSpan({ text: "Remote (WebSocket)" });
    const configContainer = formContainer.createDiv();
    configContainer.style.marginTop = "16px";
    const updateConfig = () => {
      configContainer.empty();
      if (selectedTransport === "stdio") {
        configContainer.createEl("label", { text: "Command" });
        commandInput = configContainer.createEl("input", {
          type: "text",
          value: "npx",
          attr: { placeholder: "npx" }
        });
        commandInput.style.width = "100%";
        commandInput.style.marginTop = "4px";
        commandInput.style.padding = "8px";
        const argsLabel = configContainer.createEl("label", { text: "Arguments" });
        argsLabel.style.marginTop = "12px";
        argsLabel.style.display = "block";
        argsInput = configContainer.createEl("input", {
          type: "text",
          attr: { placeholder: "-y @modelcontextprotocol/server-filesystem /path" }
        });
        argsInput.style.width = "100%";
        argsInput.style.marginTop = "4px";
        argsInput.style.padding = "8px";
        const exampleText = configContainer.createEl("p", {
          text: "Example: npx -y @modelcontextprotocol/server-filesystem /home/user/documents",
          cls: "setting-item-description"
        });
        exampleText.style.marginTop = "8px";
        exampleText.style.fontSize = "12px";
      } else {
        configContainer.createEl("label", { text: "WebSocket Endpoint" });
        endpointInput = configContainer.createEl("input", {
          type: "url",
          attr: { placeholder: "wss://your-mcp-server.com/mcp" }
        });
        endpointInput.style.width = "100%";
        endpointInput.style.marginTop = "4px";
        endpointInput.style.padding = "8px";
      }
    };
    stdioRadio.onchange = () => {
      selectedTransport = "stdio";
      updateConfig();
    };
    httpRadio.onchange = () => {
      selectedTransport = "http";
      updateConfig();
    };
    updateConfig();
    const buttonContainer = formContainer.createDiv();
    buttonContainer.style.marginTop = "24px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.justifyContent = "flex-end";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const saveBtn = buttonContainer.createEl("button", { text: "Add Server", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      const name = nameInput.value.trim();
      if (!name) {
        nameInput.style.border = "1px solid var(--text-error)";
        return;
      }
      const serverConfig = {
        id: `mcp-${Date.now()}`,
        name,
        transport: selectedTransport,
        connected: false
      };
      if (selectedTransport === "stdio") {
        serverConfig.command = (commandInput == null ? void 0 : commandInput.value.trim()) || "npx";
        serverConfig.args = argsInput == null ? void 0 : argsInput.value.trim().split(" ").filter((a) => a);
      } else {
        serverConfig.endpoint = endpointInput == null ? void 0 : endpointInput.value.trim();
      }
      if (!this.plugin.settings.mcpServers) {
        this.plugin.settings.mcpServers = [];
      }
      this.plugin.settings.mcpServers.push(serverConfig);
      this.plugin.settings.mcpEnabled = true;
      await this.plugin.saveSettings();
      try {
        const success = await this.plugin.mcpClientManager.addServer(serverConfig);
        if (success) {
          this.addMessage(`Connected to MCP server "${name}". Use /mcp to select tools.`, "system");
        } else {
          this.addMessage(`Added MCP server "${name}" but connection failed. Check settings.`, "error");
        }
      } catch (error) {
        this.addMessage(`Added MCP server "${name}" but connection failed: ${error.message}`, "error");
      }
      modal.close();
    };
    setTimeout(() => nameInput.focus(), 100);
  }
  activateMCPServer(server) {
    try {
      if (!this.activeMCPServers || !Array.isArray(this.activeMCPServers)) {
        this.activeMCPServers = [];
      }
      const existingIndex = this.activeMCPServers.findIndex((s) => s.name === server.name);
      if (existingIndex >= 0) {
        this.addMessage(`MCP server "${server.name}" is already active.`, "system");
        return;
      }
    } catch (error) {
      console.error("Error checking existing MCP servers:", error);
      this.activeMCPServers = [];
    }
    try {
      const mcpManager = this.plugin.mcpClientManager;
      const tools = (mcpManager == null ? void 0 : mcpManager.getTools().get(server.id)) || [];
      const prompts = (mcpManager == null ? void 0 : mcpManager.getPrompts().get(server.id)) || [];
      const resources = (mcpManager == null ? void 0 : mcpManager.getResources().get(server.id)) || [];
      console.log(`MCP Debug - Activating server ${server.name} with ${tools.length} tools, ${prompts.length} prompts, and ${resources.length} resources`);
      this.activeMCPServers.push({
        name: server.name,
        tools: tools || [],
        prompts: prompts || [],
        resources: resources || [],
        highlightedTools: []
      });
      this.addMessage(`MCP server "${server.name}" activated with ${tools.length} tools, ${prompts.length} prompts, and ${resources.length} resources.`, "system");
    } catch (error) {
      console.error("Error activating MCP server:", server.name, error);
      this.activeMCPServers.push({
        name: server.name,
        tools: [],
        prompts: [],
        resources: [],
        highlightedTools: []
      });
    }
    this.updateMCPIndicator();
  }
  deactivateMCPServer(serverName) {
    if (!this.activeMCPServers || !Array.isArray(this.activeMCPServers)) {
      return;
    }
    const index = this.activeMCPServers.findIndex((s) => s.name === serverName);
    if (index >= 0) {
      this.activeMCPServers.splice(index, 1);
      this.addMessage(`MCP server "${serverName}" deactivated.`, "system");
    }
    this.updateMCPIndicator();
  }
  toggleMCPServer(server) {
    var _a;
    const isActive = (_a = this.activeMCPServers) == null ? void 0 : _a.some((s) => s.name === server.name);
    if (isActive) {
      this.deactivateMCPServer(server.name);
    } else {
      this.activateMCPServer(server);
    }
    return !isActive;
  }
  async executeMCPTool(functionName, args) {
    try {
      console.log(`executeMCPTool called with function: ${functionName}, args:`, args);
      if (!functionName || typeof functionName !== "string") {
        throw new Error(`Invalid function name: ${functionName}`);
      }
      const parts = functionName.split("_");
      if (!parts || !Array.isArray(parts) || parts.length < 2) {
        const error = `Invalid function name format: ${functionName}`;
        console.error(error);
        throw new Error(error);
      }
      const serverName = parts[0];
      const toolName = parts.slice(1).join("_");
      console.log(`Parsed server: ${serverName}, tool: ${toolName}`);
      const mcpManager = this.plugin.mcpClientManager;
      if (!mcpManager) {
        const error = "MCP manager not available";
        console.error(error);
        throw new Error(error);
      }
      const servers = Array.from(mcpManager.getServers().values());
      console.log("Available MCP servers:", servers.map((s) => ({ name: s.name, id: s.id, connected: s.connected })));
      const server = servers.find((s) => s.name === serverName);
      if (!server) {
        const error = `MCP server not found: ${serverName}`;
        console.error(error, "Available servers:", servers.map((s) => s.name));
        throw new Error(error);
      }
      console.log(`Found server: ${server.name} (${server.id}), connected: ${server.connected}`);
      console.log(`Executing MCP tool: ${toolName} on server: ${serverName} (${server.id}) with args:`, args);
      const result = await mcpManager.executeTool(server.id, toolName, args);
      console.log(`MCP tool execution result:`, result);
      return result;
    } catch (error) {
      console.error(`MCP executeMCPTool: Comprehensive error handler caught:`, error);
      console.error(`MCP executeMCPTool: Error stack:`, error.stack);
      console.error(`MCP executeMCPTool: Function name: ${functionName}, args:`, args);
      throw new Error(`MCP Tool Execution Failed [${functionName}]: ${error.message}`);
    }
  }
  activateMCPTool(serverName, tool) {
    try {
      if (!this.activeMCPServers || !Array.isArray(this.activeMCPServers)) {
        this.activeMCPServers = [];
      }
      let serverEntry = this.activeMCPServers.find((s) => s.name === serverName);
      if (!serverEntry) {
        const mcpManager = this.plugin.mcpClientManager;
        const server = Array.from((mcpManager == null ? void 0 : mcpManager.getServers().values()) || []).find((s) => s.name === serverName);
        if (server)
          this.activateMCPServer(server);
        serverEntry = this.activeMCPServers.find((s) => s.name === serverName);
      }
      if (serverEntry) {
        if (!serverEntry.highlightedTools) {
          serverEntry.highlightedTools = [];
        }
        if (!serverEntry.highlightedTools.includes(tool.name)) {
          serverEntry.highlightedTools.push(tool.name);
          this.addMessage(`Tool "${tool.name}" highlighted for priority use.`, "system");
        }
        this.updateMCPIndicator();
      }
    } catch (error) {
      console.error("Error activating MCP tool:", serverName, tool.name, error);
    }
  }
  activateMCPPrompt(serverName, prompt) {
    const currentInput = this.chatInput.value;
    const promptText = `[MCP Prompt: ${prompt.name}]
${prompt.description || ""}`;
    this.chatInput.value = currentInput + (currentInput ? "\n\n" : "") + promptText;
  }
  updateMCPIndicator() {
    if (!this.mcpIndicator)
      return;
    if (this.activeMCPServers && this.activeMCPServers.length > 0) {
      this.mcpIndicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bow-arrow-icon lucide-bow-arrow"><path d="M17 3h4v4"/><path d="M18.575 11.082a13 13 0 0 1 1.048 9.027 1.17 1.17 0 0 1-1.914.597L14 17"/><path d="M7 10 3.29 6.29a1.17 1.17 0 0 1 .6-1.91 13 13 0 0 1 9.03 1.05"/><path d="M7 14a1.7 1.7 0 0 0-1.207.5l-2.646 2.646A.5.5 0 0 0 3.5 18H5a1 1 0 0 1 1 1v1.5a.5.5 0 0 0 .854.354L9.5 18.207A1.7 1.7 0 0 0 10 17v-2a1 1 0 0 0-1-1z"/><path d="M9.707 14.293 21 3"/></svg>';
      this.mcpIndicator.style.display = "flex";
      const tooltipLines = [];
      for (const activeServer of this.activeMCPServers) {
        try {
          const serverLine = `${activeServer.name}:`;
          tooltipLines.push(serverLine);
          const tools = activeServer.tools || [];
          const prompts = activeServer.prompts || [];
          const resources = activeServer.resources || [];
          const highlighted = activeServer.highlightedTools || [];
          if (tools.length > 0) {
            const toolNames = tools.map((t) => {
              const isHighlighted = highlighted.includes(t.name);
              return `  ${isHighlighted ? "\u2605" : "\u2022"} ${t.name}${isHighlighted ? " (selected)" : ""}`;
            }).join("\n");
            tooltipLines.push(toolNames);
          }
          if (prompts.length > 0) {
            const promptNames = prompts.map((p) => `  \u2022 ${p.name} (prompt)`).join("\n");
            tooltipLines.push(promptNames);
          }
          if (resources.length > 0) {
            const resourceNames = resources.map((r) => `  \u2022 ${r.name} (resource)`).join("\n");
            tooltipLines.push(resourceNames);
          }
          if (tools.length === 0 && prompts.length === 0 && resources.length === 0) {
            tooltipLines.push("  \u2022 (server only)");
          }
        } catch (error) {
          console.error("Error processing MCP server for tooltip:", activeServer, error);
          tooltipLines.push(`${activeServer.name || "Unknown Server"}: (error loading tools/prompts)`);
        }
      }
      this.mcpIndicator.removeAttribute("title");
      this.mcpIndicator.removeAttribute("aria-label");
      let tooltipElement = null;
      this.mcpIndicator.addEventListener("mouseenter", (e) => {
        if (tooltipElement) {
          tooltipElement.remove();
        }
        tooltipElement = document.createElement("div");
        tooltipElement.className = "stella-mcp-tooltip";
        tooltipElement.style.position = "fixed";
        tooltipElement.style.backgroundColor = "var(--background-primary)";
        tooltipElement.style.color = "var(--text-normal)";
        tooltipElement.style.padding = "8px 12px";
        tooltipElement.style.borderRadius = "6px";
        tooltipElement.style.border = "1px solid var(--background-modifier-border)";
        tooltipElement.style.fontSize = "13px";
        tooltipElement.style.zIndex = "10000";
        tooltipElement.style.pointerEvents = "none";
        tooltipElement.style.whiteSpace = "pre-line";
        tooltipElement.style.minWidth = "200px";
        tooltipElement.style.maxWidth = "400px";
        tooltipElement.style.lineHeight = "1.4";
        tooltipElement.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.15)";
        const tooltipText = tooltipLines.join("\n");
        tooltipElement.textContent = tooltipText;
        tooltipElement.style.visibility = "hidden";
        document.body.appendChild(tooltipElement);
        const tooltipRect = tooltipElement.getBoundingClientRect();
        const rect = this.mcpIndicator.getBoundingClientRect();
        const left = rect.left + rect.width / 2 - tooltipRect.width / 2;
        const top = rect.top - tooltipRect.height - 10;
        const finalLeft = Math.max(10, Math.min(left, window.innerWidth - tooltipRect.width - 10));
        const finalTop = Math.max(10, top);
        tooltipElement.style.left = `${finalLeft}px`;
        tooltipElement.style.top = `${finalTop}px`;
        tooltipElement.style.visibility = "visible";
        document.body.appendChild(tooltipElement);
      });
      this.mcpIndicator.addEventListener("mouseleave", () => {
        if (tooltipElement) {
          tooltipElement.remove();
          tooltipElement = null;
        }
      });
    } else {
      this.mcpIndicator.innerHTML = "";
      this.mcpIndicator.style.display = "none";
    }
    this.updateIndicatorPositions();
  }
  clearMCPContext() {
    this.activeMCPServers = [];
    console.log("MCP context cleared");
    if (this.currentConversationId) {
      const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
      if (conversation) {
        conversation.mcpServers = [];
        conversation.updatedAt = Date.now();
        this.plugin.saveSettings();
        console.log("MCP context removed from conversation");
      }
    }
    this.updateMCPIndicator();
  }
  clearAllContext() {
    this.unloadSystemPrompt();
    this.unloadMentalModel();
    this.activeMCPServers = [];
    this.contextNotes = [];
    this.startNewConversation();
    console.log("All context cleared and new conversation started");
    this.updateSystemPromptIndicator();
    this.updateMentalModelIndicator();
    this.updateMCPIndicator();
    this.updateContextIndicator();
  }
  async detectAndActivateMCP(message) {
    if (!this.plugin.mcpClientManager)
      return;
    const mcpManager = this.plugin.mcpClientManager;
    const servers = Array.from(mcpManager.getServers().values());
    for (const server of servers) {
      const tools = mcpManager.getTools().get(server.id) || [];
      const prompts = mcpManager.getPrompts().get(server.id) || [];
      for (const tool of tools) {
        const toolNameRegex = new RegExp(`\\b${tool.name}\\b`, "i");
        if (toolNameRegex.test(message)) {
          this.activateMCPTool(server.name, tool);
        }
      }
      for (const prompt of prompts) {
        const promptNameRegex = new RegExp(`\\b${prompt.name}\\b`, "i");
        if (promptNameRegex.test(message)) {
          this.activateMCPPrompt(server.name, prompt);
        }
      }
      const serverNameRegex = new RegExp(`\\b${server.name}\\b`, "i");
      if (serverNameRegex.test(message)) {
        this.activateMCPServer(server);
      }
    }
    const mcpKeywords = ["file system", "filesystem", "directory", "folders", "github", "git repo", "database", "sql", "api", "weather", "calendar"];
    const messageLower = message.toLowerCase();
    for (const keyword of mcpKeywords) {
      if (messageLower.includes(keyword)) {
        const relevantServer = servers.find((s) => {
          if (keyword.includes("file") || keyword.includes("directory") || keyword.includes("folder")) {
            return s.name.toLowerCase().includes("file") || s.name.toLowerCase().includes("fs");
          }
          if (keyword.includes("github") || keyword.includes("git")) {
            return s.name.toLowerCase().includes("github") || s.name.toLowerCase().includes("git");
          }
          if (keyword.includes("database") || keyword.includes("sql")) {
            return s.name.toLowerCase().includes("database") || s.name.toLowerCase().includes("sql");
          }
          if (keyword.includes("weather")) {
            return s.name.toLowerCase().includes("weather");
          }
          if (keyword.includes("calendar")) {
            return s.name.toLowerCase().includes("calendar");
          }
          return false;
        });
        if (relevantServer && !this.activeMCPServers.find((s) => s.name === relevantServer.name)) {
          this.activateMCPServer(relevantServer);
        }
        break;
      }
    }
  }
  updateBackgroundImage() {
    var _a;
    console.log("updateBackgroundImage called");
    if (!this.chatContainer) {
      console.log("No chatContainer found");
      return;
    }
    const { backgroundImage, backgroundMode, backgroundOpacity } = this.plugin.settings;
    console.log("Background settings:", { backgroundImage, backgroundMode, backgroundOpacity });
    if (!backgroundImage) {
      console.log("No background image set, clearing styles");
      this.chatContainer.style.setProperty("--bg-image", "none");
      this.chatContainer.style.setProperty("--bg-size", "auto");
      this.chatContainer.style.setProperty("--bg-opacity", "1");
      return;
    }
    try {
      let imageUrl = backgroundImage;
      const isLocalPath = !backgroundImage.startsWith("http") && (backgroundImage.includes("\\") || backgroundImage.startsWith("/") || /^[A-Za-z]:/.test(backgroundImage));
      console.log("isLocalPath:", isLocalPath);
      if (isLocalPath) {
        try {
          const fs = require("fs");
          const fileBuffer = fs.readFileSync(backgroundImage);
          const base64 = fileBuffer.toString("base64");
          const fileExt = (_a = backgroundImage.split(".").pop()) == null ? void 0 : _a.toLowerCase();
          const mimeType = fileExt === "webp" ? "image/webp" : fileExt === "png" ? "image/png" : fileExt === "jpg" || fileExt === "jpeg" ? "image/jpeg" : fileExt === "gif" ? "image/gif" : "image/*";
          imageUrl = `data:${mimeType};base64,${base64}`;
          console.log("Using base64 data URL for local file (size: ~" + Math.round(base64.length / 1024) + "KB)");
        } catch (fsError) {
          console.log("Failed to read file as base64:", fsError);
          try {
            const adapter = this.app.vault.adapter;
            if (adapter && adapter.getResourcePath) {
              const cleanPath = backgroundImage.replace(/\\/g, "/");
              imageUrl = adapter.getResourcePath(cleanPath);
              console.log("Fallback: Using Obsidian resource path:", imageUrl);
            } else {
              imageUrl = backgroundImage.replace(/\\/g, "/");
              console.log("Final fallback: Using direct path:", imageUrl);
            }
          } catch (e2) {
            console.log("All methods failed:", e2);
            imageUrl = backgroundImage.replace(/\\/g, "/");
          }
        }
      }
      console.log("Setting background image to:", imageUrl);
      this.chatContainer.style.setProperty("--bg-image", `url("${imageUrl}")`);
      console.log("Setting background mode to:", backgroundMode);
      let backgroundSize;
      switch (backgroundMode) {
        case "centered":
          backgroundSize = "auto";
          break;
        case "fill":
          backgroundSize = "cover";
          break;
        case "stretch":
          backgroundSize = "100% 100%";
          break;
        default:
          backgroundSize = "cover";
      }
      this.chatContainer.style.setProperty("--bg-size", backgroundSize);
      console.log("Setting opacity to:", backgroundOpacity);
      this.chatContainer.style.setProperty("--bg-opacity", backgroundOpacity.toString());
      console.log("Background image applied successfully");
    } catch (error) {
      console.error("Error setting background image:", error);
      this.messagesContainer.style.backgroundImage = "";
    }
  }
  updateHeaderVisibility() {
    if (!this.headerContainer) {
      return;
    }
    const shouldHide = this.plugin.settings.autoHideHeader;
    if (shouldHide) {
      this.headerContainer.style.display = "none";
    } else {
      this.headerContainer.style.display = "flex";
    }
  }
  toggleHeader() {
    if (!this.headerContainer) {
      return;
    }
    this.plugin.settings.autoHideHeader = !this.plugin.settings.autoHideHeader;
    this.plugin.saveSettings();
    const isHiding = this.plugin.settings.autoHideHeader;
    if (isHiding) {
      this.headerContainer.style.opacity = "0";
      this.headerContainer.style.transform = "translateY(-100%)";
      setTimeout(() => {
        this.headerContainer.style.display = "none";
      }, 300);
    } else {
      this.headerContainer.style.display = "flex";
      this.headerContainer.style.opacity = "0";
      this.headerContainer.style.transform = "translateY(-100%)";
      this.headerContainer.offsetHeight;
      this.headerContainer.style.opacity = "1";
      this.headerContainer.style.transform = "translateY(0)";
    }
  }
  showNameInput() {
    const modal = new import_obsidian4.Modal(this.app);
    modal.setTitle("Rename Conversation");
    const currentConversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
    const currentName = currentConversation ? currentConversation.title : "";
    const input = modal.contentEl.createEl("input", {
      type: "text",
      placeholder: "Enter conversation name...",
      value: currentName
    });
    input.style.width = "100%";
    input.style.marginBottom = "16px";
    input.style.padding = "8px";
    input.style.fontSize = "14px";
    input.style.border = "1px solid var(--background-modifier-border)";
    input.style.borderRadius = "4px";
    input.style.background = "var(--background-primary)";
    input.style.color = "var(--text-normal)";
    const buttonContainer = modal.contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.style.padding = "8px 16px";
    cancelButton.style.border = "1px solid var(--background-modifier-border)";
    cancelButton.style.borderRadius = "4px";
    cancelButton.style.background = "var(--background-secondary)";
    cancelButton.style.color = "var(--text-normal)";
    cancelButton.style.cursor = "pointer";
    const saveButton = buttonContainer.createEl("button", { text: "Save" });
    saveButton.style.padding = "8px 16px";
    saveButton.style.border = "1px solid var(--interactive-accent)";
    saveButton.style.borderRadius = "4px";
    saveButton.style.background = "var(--interactive-accent)";
    saveButton.style.color = "var(--text-on-accent)";
    saveButton.style.cursor = "pointer";
    const saveName = async () => {
      const newName = input.value.trim();
      if (newName && currentConversation) {
        currentConversation.title = newName;
        await this.plugin.saveSettings();
        this.conversationNameInput.value = newName;
        modal.close();
      }
    };
    cancelButton.addEventListener("click", () => modal.close());
    saveButton.addEventListener("click", saveName);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        saveName();
      } else if (e.key === "Escape") {
        e.preventDefault();
        modal.close();
      }
    });
    modal.open();
    setTimeout(() => {
      input.focus();
      input.select();
    }, 100);
  }
  openPluginSettings() {
    const app = this.app;
    app.setting.open();
    app.setting.openTabById("stella");
  }
  async onClose() {
    if (this.logger) {
      this.logger.destroy();
    }
  }
};
var StellaSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("AI Provider").setDesc("Select your AI provider").addDropdown((dropdown) => dropdown.addOption("anthropic", "Anthropic (Claude)").addOption("openai", "OpenAI (GPT)").addOption("google", "Google (Gemini)").addOption("ollama", "Ollama (Local)").addOption("lmstudio", "LM Studio (Local)").addOption("custom", "Custom API").setValue(this.plugin.settings.provider).onChange(async (value) => {
      this.plugin.settings.provider = value;
      this.plugin.settings.model = "";
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateModelInfo) {
          chatView.updateModelInfo(chatView.modelInfoContainer);
        }
      });
      this.display();
    }));
    if (this.plugin.settings.provider === "openai") {
      new import_obsidian4.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "anthropic") {
      new import_obsidian4.Setting(containerEl).setName("Anthropic API Key").setDesc("Enter your Anthropic API key").addText((text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "google") {
      new import_obsidian4.Setting(containerEl).setName("Google API Key").setDesc("Enter your Google AI API key").addText((text) => text.setPlaceholder("AI...").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "ollama") {
      new import_obsidian4.Setting(containerEl).setName("Ollama Base URL").setDesc("Ollama server URL").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaBaseUrl).onChange(async (value) => {
        this.plugin.settings.ollamaBaseUrl = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "lmstudio") {
      new import_obsidian4.Setting(containerEl).setName("LM Studio Base URL").setDesc("LM Studio server URL").addText((text) => text.setPlaceholder("http://localhost:1234").setValue(this.plugin.settings.lmStudioBaseUrl).onChange(async (value) => {
        this.plugin.settings.lmStudioBaseUrl = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "custom") {
      new import_obsidian4.Setting(containerEl).setName("Custom API URL").setDesc("Your custom API endpoint URL").addText((text) => text.setPlaceholder("https://your-api.com/v1/chat/completions").setValue(this.plugin.settings.customApiUrl).onChange(async (value) => {
        this.plugin.settings.customApiUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian4.Setting(containerEl).setName("Custom API Key").setDesc("API key for your custom endpoint (optional)").addText((text) => text.setPlaceholder("your-api-key").setValue(this.plugin.settings.customApiKey).onChange(async (value) => {
        this.plugin.settings.customApiKey = value;
        await this.plugin.saveSettings();
      }));
    }
    this.modelSetting = new import_obsidian4.Setting(containerEl).setName("Model").setDesc("Select the model to use (fetched from API)").addButton((button) => button.setButtonText("Refresh Models").onClick(() => this.refreshModelDropdown()));
    this.modelDropdown = this.modelSetting.addDropdown((dropdown) => {
      dropdown.setValue(this.plugin.settings.model);
      dropdown.onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
        this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
          const chatView = leaf.view;
          if (chatView && chatView.updateModelInfo) {
            chatView.updateModelInfo(chatView.modelInfoContainer);
          }
        });
      });
      return dropdown;
    });
    setTimeout(() => {
      console.log("Settings tab displayed, refreshing model dropdown...");
      this.refreshModelDropdown();
    }, 100);
    new import_obsidian4.Setting(containerEl).setName("Max Tokens").setDesc("Maximum tokens per response").addText((text) => text.setValue(this.plugin.settings.maxTokens.toString()).onChange(async (value) => {
      this.plugin.settings.maxTokens = parseInt(value) || 4e3;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Temperature").setDesc("Creativity level (0-1)").addText((text) => text.setValue(this.plugin.settings.temperature.toString()).onChange(async (value) => {
      this.plugin.settings.temperature = parseFloat(value) || 0.7;
      await this.plugin.saveSettings();
    }));
    const systemPromptsPathSetting = new import_obsidian4.Setting(containerEl).setName("System Prompts Directory").setDesc("Path to directory containing your system prompt .md files (for /sys command)");
    let systemPromptsInput;
    systemPromptsPathSetting.addText((text) => {
      systemPromptsInput = text;
      text.setPlaceholder("/path/to/your/system-prompts").setValue(this.plugin.settings.systemPromptsPath).onChange(async (value) => {
        this.plugin.settings.systemPromptsPath = value;
        await this.plugin.saveSettings();
      });
    });
    systemPromptsPathSetting.addButton((button) => button.setButtonText("Browse").onClick(async () => {
      const folders = this.app.vault.getAllLoadedFiles().filter((f) => f.children !== void 0);
      const modal = new FolderSuggestModal(this.app, folders, async (folder) => {
        this.plugin.settings.systemPromptsPath = folder.path;
        systemPromptsInput.setValue(folder.path);
        await this.plugin.saveSettings();
      });
      modal.open();
    }));
    const mentalModelsPathSetting = new import_obsidian4.Setting(containerEl).setName("Mental Models Directory").setDesc("Path to directory containing your mental model .md files (for /model command)");
    let mentalModelsInput;
    mentalModelsPathSetting.addText((text) => {
      mentalModelsInput = text;
      text.setPlaceholder("/path/to/your/mental-models").setValue(this.plugin.settings.mentalModelsPath).onChange(async (value) => {
        this.plugin.settings.mentalModelsPath = value;
        await this.plugin.saveSettings();
      });
    });
    mentalModelsPathSetting.addButton((button) => button.setButtonText("Browse").onClick(async () => {
      const folders = this.app.vault.getAllLoadedFiles().filter((f) => f.children !== void 0);
      const modal = new FolderSuggestModal(this.app, folders, async (folder) => {
        this.plugin.settings.mentalModelsPath = folder.path;
        mentalModelsInput.setValue(folder.path);
        await this.plugin.saveSettings();
      });
      modal.open();
    }));
    const backgroundImageSetting = new import_obsidian4.Setting(containerEl).setName("Background Image URL/Path").setDesc("URL or local file path to background image for chat area");
    let backgroundImageInput;
    backgroundImageSetting.addText((text) => {
      backgroundImageInput = text;
      text.setPlaceholder("https://example.com/image.jpg or /path/to/image.png").setValue(this.plugin.settings.backgroundImage).onChange(async (value) => {
        this.plugin.settings.backgroundImage = value;
        await this.plugin.saveSettings();
        this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
          const chatView = leaf.view;
          if (chatView && chatView.updateBackgroundImage) {
            chatView.updateBackgroundImage();
          }
        });
      });
    });
    backgroundImageSetting.addButton((button) => button.setButtonText("Browse").onClick(async () => {
      const imageExtensions = ["png", "jpg", "jpeg", "gif", "webp", "svg"];
      const files = this.app.vault.getFiles().filter((f) => imageExtensions.includes(f.extension.toLowerCase()));
      if (files.length === 0) {
        new import_obsidian4.Notice("No image files found in your vault.");
        return;
      }
      const modal = new FileSuggestModal(this.app, files, async (file) => {
        this.plugin.settings.backgroundImage = file.path;
        backgroundImageInput.setValue(file.path);
        await this.plugin.saveSettings();
        this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
          const chatView = leaf.view;
          if (chatView && chatView.updateBackgroundImage) {
            chatView.updateBackgroundImage();
          }
        });
      });
      modal.open();
    }));
    new import_obsidian4.Setting(containerEl).setName("Background Display Mode").setDesc("How the background image should be displayed").addDropdown((dropdown) => dropdown.addOption("centered", "Centered").addOption("fill", "Fill").addOption("stretch", "Stretch").setValue(this.plugin.settings.backgroundMode).onChange(async (value) => {
      this.plugin.settings.backgroundMode = value;
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateBackgroundImage) {
          chatView.updateBackgroundImage();
        }
      });
    }));
    new import_obsidian4.Setting(containerEl).setName("Background Opacity").setDesc("Opacity of the background image (0.0 to 1.0)").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.backgroundOpacity).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.backgroundOpacity = value;
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateBackgroundImage) {
          chatView.updateBackgroundImage();
        }
      });
    }));
    const loadingGifSetting = new import_obsidian4.Setting(containerEl).setName("Loading Animation GIF").setDesc("Custom GIF to display while waiting for AI response (leave empty for default)");
    let loadingGifInput;
    loadingGifSetting.addText((text) => {
      loadingGifInput = text;
      text.setPlaceholder("path/to/your/animation.gif").setValue(this.plugin.settings.loadingGif).onChange(async (value) => {
        this.plugin.settings.loadingGif = value;
        await this.plugin.saveSettings();
      });
    });
    loadingGifSetting.addButton((button) => button.setButtonText("Browse").onClick(async () => {
      const files = this.app.vault.getFiles().filter((f) => f.extension.toLowerCase() === "gif");
      if (files.length === 0) {
        new import_obsidian4.Notice("No GIF files found in your vault. Add a .gif file to your vault first.");
        return;
      }
      const modal = new FileSuggestModal(this.app, files, async (file) => {
        this.plugin.settings.loadingGif = file.path;
        loadingGifInput.setValue(file.path);
        await this.plugin.saveSettings();
      });
      modal.open();
    }));
    new import_obsidian4.Setting(containerEl).setName("Auto-hide header").setDesc("Automatically hide the header bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoHideHeader).onChange(async (value) => {
      this.plugin.settings.autoHideHeader = value;
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateHeaderVisibility) {
          chatView.updateHeaderVisibility();
        }
      });
    }));
    new import_obsidian4.Setting(containerEl).setName("Show Token Count").setDesc("Display estimated token usage during and after response generation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTokenCount).onChange(async (value) => {
      this.plugin.settings.showTokenCount = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("QuickAdd Commands").setDesc("Configure right-click context menu options that trigger QuickAdd commands").addButton((button) => button.setButtonText("Show Available Commands").onClick(() => {
      this.showAvailableQuickAddCommands();
    })).addButton((button) => button.setButtonText("Add Command").onClick(() => {
      this.plugin.settings.quickAddCommands.push({
        id: `command-${Date.now()}`,
        name: "New Command",
        description: "Description for new command"
      });
      this.plugin.saveSettings();
      this.display();
    }));
    this.plugin.settings.quickAddCommands.forEach((command, index) => {
      const commandContainer = containerEl.createDiv("quickadd-command-item");
      new import_obsidian4.Setting(commandContainer).setName(`Command ${index + 1}`).addText((text) => text.setPlaceholder("Command Name").setValue(command.name).onChange(async (value) => {
        this.plugin.settings.quickAddCommands[index].name = value;
        await this.plugin.saveSettings();
      })).addText((text) => text.setPlaceholder('QuickAdd Command ID (click "Show Available Commands" for help)').setValue(command.id).onChange(async (value) => {
        this.plugin.settings.quickAddCommands[index].id = value;
        await this.plugin.saveSettings();
      })).addTextArea((text) => text.setPlaceholder("Description").setValue(command.description).onChange(async (value) => {
        this.plugin.settings.quickAddCommands[index].description = value;
        await this.plugin.saveSettings();
      })).addButton((button) => button.setButtonText("Remove").setWarning().onClick(async () => {
        this.plugin.settings.quickAddCommands.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      }));
    });
    containerEl.createEl("h2", { text: "MCP (Model Context Protocol)" });
    new import_obsidian4.Setting(containerEl).setName("Enable MCP").setDesc("Enable Model Context Protocol for connecting to external tools and data sources").addToggle((toggle) => toggle.setValue(this.plugin.settings.mcpEnabled).onChange(async (value) => {
      this.plugin.settings.mcpEnabled = value;
      await this.plugin.saveSettings();
      if (value && this.plugin.settings.mcpServers.length > 0) {
        await this.plugin.initializeMCPServers();
      }
      this.display();
    }));
    if (this.plugin.settings.mcpEnabled) {
      new import_obsidian4.Setting(containerEl).setName("Auto-discovery").setDesc("Automatically discover MCP servers on the network").addToggle((toggle) => toggle.setValue(this.plugin.settings.mcpAutoDiscovery).onChange(async (value) => {
        this.plugin.settings.mcpAutoDiscovery = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian4.Setting(containerEl).setName("Add MCP Server").setDesc("Configure connections to MCP servers").addButton((button) => button.setButtonText("Add Server").onClick(() => {
        this.showMCPServerModal();
      }));
      this.plugin.settings.mcpServers.forEach((server, index) => {
        const serverSetting = new import_obsidian4.Setting(containerEl);
        const serverInfo = serverSetting.settingEl.createDiv("mcp-server-info");
        serverInfo.style.display = "flex";
        serverInfo.style.alignItems = "center";
        serverInfo.style.gap = "10px";
        serverInfo.style.width = "100%";
        const statusDot = serverInfo.createSpan("mcp-status-dot");
        statusDot.style.width = "8px";
        statusDot.style.height = "8px";
        statusDot.style.borderRadius = "50%";
        statusDot.style.backgroundColor = server.connected ? "#4ade80" : "#ef4444";
        const serverDetails = serverInfo.createDiv();
        serverDetails.createEl("strong", { text: server.name });
        serverDetails.createEl("br");
        serverDetails.createEl("small", {
          text: `${server.transport} - ${server.endpoint || server.command}`,
          attr: { style: "color: var(--text-muted);" }
        });
        const actions = serverInfo.createDiv();
        actions.style.marginLeft = "auto";
        actions.style.display = "flex";
        actions.style.gap = "8px";
        const connectBtn = actions.createEl("button", {
          text: server.connected ? "Disconnect" : "Connect",
          cls: "mod-cta"
        });
        connectBtn.onclick = async () => {
          if (server.connected) {
            await this.plugin.mcp.removeServer(server.id);
          } else {
            await this.plugin.mcp.addServer(server);
          }
          this.display();
        };
        const editBtn = actions.createEl("button", { text: "Edit" });
        editBtn.onclick = () => {
          this.showMCPServerModal(server, index);
        };
        const removeBtn = actions.createEl("button", {
          text: "Remove",
          cls: "mod-warning"
        });
        removeBtn.onclick = async () => {
          await this.plugin.mcp.removeServer(server.id);
          this.plugin.settings.mcpServers.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        };
      });
      if (this.plugin.settings.mcpServers.length > 0) {
        const connectedServers = this.plugin.mcp.getConnectedServers();
        const totalTools = this.plugin.mcp.getAllTools().length;
        const totalResources = this.plugin.mcp.getAllResources().length;
        const statusSetting = new import_obsidian4.Setting(containerEl);
        const statusDiv = statusSetting.settingEl.createDiv("mcp-status");
        statusDiv.innerHTML = `
                    <strong>MCP Status:</strong><br>
                    Connected Servers: ${connectedServers.length}/${this.plugin.settings.mcpServers.length}<br>
                    Available Tools: ${totalTools}<br>
                    Available Resources: ${totalResources}
                `;
      }
    }
  }
  async fetchModelsForProvider(provider) {
    try {
      switch (provider) {
        case "openai":
          return await this.fetchOpenAIModels();
        case "anthropic":
          return await this.fetchAnthropicModels();
        case "google":
          return await this.fetchGoogleModels();
        case "ollama":
          return await this.fetchOllamaModels();
        case "lmstudio":
          return await this.fetchLMStudioModels();
        default:
          return [];
      }
    } catch (error) {
      console.error(`Failed to fetch models for ${provider}:`, error);
      return [];
    }
  }
  async fetchOpenAIModels() {
    if (!this.plugin.settings.openaiApiKey)
      return [];
    try {
      const response = await fetch("https://api.openai.com/v1/models", {
        headers: {
          "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`,
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        console.error("OpenAI API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("OpenAI API response:", data);
      if (!data.data)
        return [];
      return data.data.filter((model) => {
        return model.id.includes("gpt") || model.id.includes("o1") || model.id.includes("o3");
      }).map((model) => model.id).sort();
    } catch (error) {
      console.error("Error fetching OpenAI models:", error);
      return [];
    }
  }
  async fetchAnthropicModels() {
    if (!this.plugin.settings.anthropicApiKey)
      return [];
    try {
      const response = await FetchManager.enhancedFetch("https://api.anthropic.com/v1/models", {
        headers: {
          "x-api-key": this.plugin.settings.anthropicApiKey,
          "anthropic-version": "2023-06-01"
        }
      });
      if (!response.ok) {
        console.error("Anthropic API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("Anthropic API response:", data);
      if (!data.data)
        return [];
      return data.data.map((model) => model.id).sort();
    } catch (error) {
      console.error("Error fetching Anthropic models:", error);
      return [];
    }
  }
  async fetchGoogleModels() {
    if (!this.plugin.settings.googleApiKey)
      return [];
    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${this.plugin.settings.googleApiKey}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        console.error("Google API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("Google API response:", data);
      if (!data.models)
        return [];
      return data.models.filter((model) => {
        var _a;
        return (_a = model.supportedGenerationMethods) == null ? void 0 : _a.includes("generateContent");
      }).map((model) => {
        return model.name.replace("models/", "");
      }).sort();
    } catch (error) {
      console.error("Error fetching Google models:", error);
      return [];
    }
  }
  async fetchOllamaModels() {
    var _a;
    try {
      const response = await fetch(`${this.plugin.settings.ollamaBaseUrl}/api/tags`);
      if (!response.ok)
        return [];
      const data = await response.json();
      return ((_a = data.models) == null ? void 0 : _a.map((model) => model.name)) || [];
    } catch (error) {
      console.error("Error fetching Ollama models:", error);
      return [];
    }
  }
  async fetchLMStudioModels() {
    var _a;
    try {
      const response = await fetch(`${this.plugin.settings.lmStudioBaseUrl}/v1/models`);
      if (!response.ok)
        return [];
      const data = await response.json();
      return ((_a = data.data) == null ? void 0 : _a.map((model) => model.id)) || [];
    } catch (error) {
      console.error("Error fetching LM Studio models:", error);
      return [];
    }
  }
  async refreshModelDropdown() {
    if (!this.modelDropdown) {
      console.log("No model dropdown found");
      return;
    }
    console.log(`Refreshing models for provider: ${this.plugin.settings.provider}`);
    console.log("Dropdown object:", this.modelDropdown);
    console.log("Dropdown keys:", Object.keys(this.modelDropdown));
    try {
      const models = await this.fetchModelsForProvider(this.plugin.settings.provider);
      console.log(`Fetched ${models.length} models for ${this.plugin.settings.provider}:`, models);
      const dropdown = this.modelDropdown;
      if (dropdown.selectEl) {
        console.log("Using selectEl method");
        dropdown.selectEl.empty();
        if (models.length === 0) {
          dropdown.addOption("", `No ${this.plugin.settings.provider} models found`);
        } else {
          models.forEach((model) => {
            console.log(`Adding model option: ${model}`);
            dropdown.addOption(model, model);
          });
        }
        dropdown.setValue(this.plugin.settings.model);
        console.log(`Set dropdown value to: ${this.plugin.settings.model}`);
      } else if (dropdown.dropdownEl) {
        console.log("Using dropdownEl method");
        const select = dropdown.dropdownEl;
        select.empty();
        if (models.length === 0) {
          select.createEl("option", { text: `No ${this.plugin.settings.provider} models found`, value: "" });
        } else {
          models.forEach((model) => {
            console.log(`Adding model option: ${model}`);
            select.createEl("option", { text: model, value: model });
          });
        }
        dropdown.setValue(this.plugin.settings.model);
        console.log(`Set dropdown value to: ${this.plugin.settings.model}`);
      } else {
        console.log("Recreating dropdown");
        this.createModelDropdown(models);
      }
    } catch (error) {
      console.error("Error refreshing models:", error);
    }
  }
  createModelDropdown(models) {
    if (!this.modelSetting) {
      console.error("No model setting found for dropdown creation");
      return;
    }
    console.log("Creating model dropdown, current components:", this.modelSetting.components.length);
    this.modelSetting.controlEl.empty();
    this.modelSetting.components = [];
    this.modelDropdown = this.modelSetting.addDropdown((dropdown) => {
      if (models.length === 0) {
        dropdown.addOption("", `No ${this.plugin.settings.provider} models found`);
      } else {
        models.forEach((model) => {
          dropdown.addOption(model, model);
        });
      }
      dropdown.setValue(this.plugin.settings.model);
      dropdown.onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
        this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
          const chatView = leaf.view;
          if (chatView && chatView.updateModelInfo) {
            chatView.updateModelInfo(chatView.modelInfoContainer);
          }
        });
      });
      return dropdown;
    });
    console.log(`Created new dropdown with ${models.length} models, components now:`, this.modelSetting.components.length);
  }
  showAvailableQuickAddCommands() {
    try {
      const commands = this.app.commands;
      if (!commands) {
        new import_obsidian4.Notice("Commands system not available");
        return;
      }
      const allCommands = commands.listCommands();
      const quickAddCommands = allCommands.filter((cmd) => cmd.id.includes("quickadd"));
      if (quickAddCommands.length === 0) {
        new import_obsidian4.Notice("No QuickAdd commands found. Make sure QuickAdd plugin is installed and configured.");
        return;
      }
      const modal = new import_obsidian4.Modal(this.app);
      modal.titleEl.setText("Available QuickAdd Commands");
      const content = modal.contentEl;
      content.createEl("p", { text: "Copy the Command ID to use in Stella settings:" });
      const container = content.createDiv("quickadd-commands-list");
      quickAddCommands.forEach((cmd) => {
        const cmdItem = container.createDiv("quickadd-command-item");
        cmdItem.style.marginBottom = "10px";
        cmdItem.style.padding = "8px";
        cmdItem.style.border = "1px solid var(--background-modifier-border)";
        cmdItem.style.borderRadius = "4px";
        const nameEl = cmdItem.createEl("strong", { text: cmd.name });
        nameEl.style.display = "block";
        const idEl = cmdItem.createEl("code", { text: cmd.id });
        idEl.style.display = "block";
        idEl.style.marginTop = "4px";
        idEl.style.fontSize = "12px";
        idEl.style.color = "var(--text-muted)";
        idEl.style.cursor = "pointer";
        idEl.addEventListener("click", () => {
          navigator.clipboard.writeText(cmd.id);
          new import_obsidian4.Notice(`Copied: ${cmd.id}`);
        });
      });
      const buttonContainer = content.createDiv();
      buttonContainer.style.marginTop = "16px";
      buttonContainer.style.textAlign = "right";
      const closeBtn = buttonContainer.createEl("button", { text: "Close" });
      closeBtn.onclick = () => modal.close();
      modal.open();
    } catch (error) {
      new import_obsidian4.Notice("Failed to retrieve QuickAdd commands");
      console.error("Error showing QuickAdd commands:", error);
    }
  }
  showMCPServerModal(server, index) {
    const modal = new import_obsidian4.Modal(this.app);
    modal.titleEl.setText(server ? "Edit MCP Server" : "Add MCP Server");
    const content = modal.contentEl;
    let selectedTransport = (server == null ? void 0 : server.transport) || "stdio";
    let nameInput;
    let commandInput;
    let argsInput;
    let endpointInput;
    let envContainer;
    const nameContainer = content.createDiv();
    nameContainer.createEl("label", { text: "Server Name" });
    nameInput = nameContainer.createEl("input", {
      type: "text",
      value: (server == null ? void 0 : server.name) || "",
      attr: { placeholder: "e.g., My Custom MCP Server" }
    });
    nameInput.style.width = "100%";
    nameInput.style.marginTop = "4px";
    const transportContainer = content.createDiv();
    transportContainer.style.marginTop = "16px";
    transportContainer.createEl("label", { text: "Server Type" });
    const transportToggle = transportContainer.createDiv();
    transportToggle.style.marginTop = "8px";
    transportToggle.style.display = "flex";
    transportToggle.style.gap = "12px";
    const stdioOption = transportToggle.createEl("label");
    stdioOption.style.cursor = "pointer";
    stdioOption.style.display = "flex";
    stdioOption.style.alignItems = "center";
    stdioOption.style.gap = "6px";
    const stdioRadio = stdioOption.createEl("input", { type: "radio", value: "stdio" });
    stdioRadio.name = "transport";
    stdioRadio.checked = selectedTransport === "stdio";
    stdioOption.createSpan({ text: "Local Server (like Claude Desktop)" });
    const httpOption = transportToggle.createEl("label");
    httpOption.style.cursor = "pointer";
    httpOption.style.display = "flex";
    httpOption.style.alignItems = "center";
    httpOption.style.gap = "6px";
    const httpRadio = httpOption.createEl("input", { type: "radio", value: "http" });
    httpRadio.name = "transport";
    httpRadio.checked = selectedTransport === "http";
    httpOption.createSpan({ text: "Remote Server (WebSocket)" });
    const configContainer = content.createDiv();
    configContainer.style.marginTop = "16px";
    const updateConfig = () => {
      var _a;
      configContainer.empty();
      if (selectedTransport === "stdio") {
        configContainer.createEl("label", { text: "Command" });
        commandInput = configContainer.createEl("input", {
          type: "text",
          value: (server == null ? void 0 : server.command) || "npx",
          attr: { placeholder: "npx" }
        });
        commandInput.style.width = "100%";
        commandInput.style.marginTop = "4px";
        const argsLabel = configContainer.createEl("label", { text: "Arguments" });
        argsLabel.style.marginTop = "12px";
        argsLabel.style.display = "block";
        argsInput = configContainer.createEl("input", {
          type: "text",
          value: ((_a = server == null ? void 0 : server.args) == null ? void 0 : _a.join(" ")) || "",
          attr: { placeholder: "-y @modelcontextprotocol/server-filesystem /path/to/files" }
        });
        argsInput.style.width = "100%";
        argsInput.style.marginTop = "4px";
        const envLabel = configContainer.createEl("label", { text: "Environment Variables (optional)" });
        envLabel.style.marginTop = "12px";
        envLabel.style.display = "block";
        envContainer = configContainer.createDiv();
        envContainer.style.marginTop = "8px";
        if (server == null ? void 0 : server.env) {
          Object.entries(server.env).forEach(([key, value]) => {
            addEnvVar(key, value);
          });
        }
        const addEnvBtn = configContainer.createEl("button", { text: "+ Add Environment Variable" });
        addEnvBtn.style.marginTop = "8px";
        addEnvBtn.onclick = (e) => {
          e.preventDefault();
          addEnvVar();
        };
      } else {
        configContainer.createEl("label", { text: "WebSocket Endpoint" });
        endpointInput = configContainer.createEl("input", {
          type: "url",
          value: (server == null ? void 0 : server.endpoint) || "",
          attr: { placeholder: "wss://your-mcp-server.com/mcp" }
        });
        endpointInput.style.width = "100%";
        endpointInput.style.marginTop = "4px";
      }
    };
    const addEnvVar = (key = "", value = "") => {
      const envRow = envContainer.createDiv();
      envRow.style.display = "flex";
      envRow.style.gap = "8px";
      envRow.style.marginBottom = "8px";
      envRow.style.alignItems = "center";
      const keyInput = envRow.createEl("input", {
        type: "text",
        value: key,
        attr: { placeholder: "VARIABLE_NAME" }
      });
      keyInput.style.flex = "1";
      keyInput.dataset.envKey = "true";
      const valueInput = envRow.createEl("input", {
        type: "text",
        value,
        attr: { placeholder: "value" }
      });
      valueInput.style.flex = "2";
      valueInput.dataset.envValue = "true";
      const removeBtn = envRow.createEl("button", { text: "\xD7" });
      removeBtn.style.width = "30px";
      removeBtn.style.height = "30px";
      removeBtn.style.borderRadius = "4px";
      removeBtn.onclick = (e) => {
        e.preventDefault();
        envRow.remove();
      };
    };
    stdioRadio.onchange = () => {
      selectedTransport = "stdio";
      updateConfig();
    };
    httpRadio.onchange = () => {
      selectedTransport = "http";
      updateConfig();
    };
    updateConfig();
    const buttonContainer = content.createDiv();
    buttonContainer.style.marginTop = "24px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const saveBtn = buttonContainer.createEl("button", {
      text: server ? "Update" : "Add",
      cls: "mod-cta"
    });
    saveBtn.onclick = async () => {
      const name = nameInput.value.trim();
      if (!name) {
        new import_obsidian4.Notice("Server name is required");
        return;
      }
      const newServer = {
        id: (server == null ? void 0 : server.id) || `mcp-${Date.now()}`,
        name,
        transport: selectedTransport,
        connected: false
      };
      if (selectedTransport === "stdio") {
        newServer.command = commandInput.value.trim() || "npx";
        newServer.args = argsInput.value.trim() ? argsInput.value.trim().split(" ").filter((arg) => arg.length > 0) : [];
        const envVars = {};
        const keyInputs = envContainer.querySelectorAll("[data-env-key]");
        const valueInputs = envContainer.querySelectorAll("[data-env-value]");
        keyInputs.forEach((keyInput, i) => {
          var _a;
          const key = keyInput.value.trim();
          const value = (_a = valueInputs[i]) == null ? void 0 : _a.value.trim();
          if (key && value) {
            envVars[key] = value;
          }
        });
        if (Object.keys(envVars).length > 0) {
          newServer.env = envVars;
        }
      } else {
        const endpoint = endpointInput.value.trim();
        if (!endpoint) {
          new import_obsidian4.Notice("WebSocket endpoint is required");
          return;
        }
        newServer.endpoint = endpoint;
      }
      try {
        if (server && typeof index === "number") {
          this.plugin.settings.mcpServers[index] = newServer;
        } else {
          this.plugin.settings.mcpServers.push(newServer);
        }
        await this.plugin.saveSettings();
        if (this.plugin.settings.mcpEnabled) {
          await this.plugin.mcp.addServer(newServer);
        }
        new import_obsidian4.Notice(`MCP server ${server ? "updated" : "added"}: ${name}`);
        modal.close();
        this.display();
      } catch (error) {
        new import_obsidian4.Notice(`Failed to ${server ? "update" : "add"} MCP server`);
        console.error("MCP server error:", error);
      }
    };
    modal.open();
  }
  showMCPTemplateConfigModal(template) {
    const modal = new import_obsidian4.Modal(this.app);
    modal.titleEl.setText(`Configure ${template.name} Server`);
    const content = modal.contentEl;
    content.createEl("p", {
      text: template.description,
      attr: { style: "color: var(--text-muted); margin-bottom: 16px;" }
    });
    const commandInfo = content.createDiv();
    commandInfo.style.marginBottom = "20px";
    commandInfo.style.padding = "12px";
    commandInfo.style.backgroundColor = "var(--background-secondary)";
    commandInfo.style.borderRadius = "8px";
    commandInfo.createEl("strong", { text: "Command:" }).style.display = "block";
    commandInfo.createEl("code", { text: `${template.command} ${template.args.join(" ")}` });
    const envInputs = {};
    if (template.envVariables.length > 0) {
      content.createEl("h4", { text: "Configuration" });
      template.envVariables.forEach((envVar) => {
        const container = content.createDiv();
        container.style.marginBottom = "16px";
        const label = container.createEl("label", { text: envVar.description });
        if (envVar.required) {
          label.createSpan({ text: " *", attr: { style: "color: var(--text-error);" } });
        }
        const input = container.createEl("input", {
          type: envVar.key.toLowerCase().includes("token") || envVar.key.toLowerCase().includes("key") ? "password" : "text",
          attr: { placeholder: envVar.placeholder || "" }
        });
        input.style.width = "100%";
        input.style.marginTop = "4px";
        envInputs[envVar.key] = input;
      });
    }
    const buttonContainer = content.createDiv();
    buttonContainer.style.marginTop = "24px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const addBtn = buttonContainer.createEl("button", {
      text: "Add Server",
      cls: "mod-cta"
    });
    addBtn.onclick = async () => {
      for (const envVar of template.envVariables) {
        if (envVar.required && !envInputs[envVar.key].value.trim()) {
          new import_obsidian4.Notice(`${envVar.description} is required`);
          return;
        }
      }
      const newServer = {
        id: `mcp-${Date.now()}`,
        name: template.name,
        transport: "stdio",
        command: template.command,
        args: [...template.args],
        connected: false
      };
      const env = {};
      Object.entries(envInputs).forEach(([key, input]) => {
        const value = input.value.trim();
        if (value) {
          env[key] = value;
        }
      });
      if (Object.keys(env).length > 0) {
        newServer.env = env;
      }
      try {
        this.plugin.settings.mcpServers.push(newServer);
        await this.plugin.saveSettings();
        if (this.plugin.settings.mcpEnabled) {
          await this.plugin.mcp.addServer(newServer);
        }
        new import_obsidian4.Notice(`Added ${template.name} MCP server`);
        modal.close();
        this.display();
      } catch (error) {
        new import_obsidian4.Notice(`Failed to add ${template.name} server`);
        console.error("Template server error:", error);
      }
    };
    modal.open();
  }
};
