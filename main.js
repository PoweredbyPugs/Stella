/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StellaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  provider: "anthropic",
  openaiApiKey: "",
  anthropicApiKey: "",
  googleApiKey: "",
  ollamaBaseUrl: "http://localhost:11434",
  lmStudioBaseUrl: "http://localhost:1234",
  customApiUrl: "",
  customApiKey: "",
  model: "",
  maxTokens: 4e3,
  temperature: 0.7,
  conversations: [],
  currentConversationId: null,
  systemPromptsPath: "",
  mentalModelsPath: "",
  backgroundImage: "",
  backgroundMode: "centered",
  backgroundOpacity: 0.5,
  autoHideHeader: false,
  quickAddCommands: [
    {
      id: "seed",
      name: "Seed",
      description: "Create a seed note from selected text"
    }
  ],
  showTokenCount: false,
  // MCP Default Settings
  mcpEnabled: false,
  mcpServers: [],
  mcpAutoDiscovery: true
};
var FetchManager = class {
  static async enhancedFetch(url, options = {}) {
    const headers = new Headers(options.headers);
    headers.set("Accept-Encoding", "gzip, deflate, br");
    if (!headers.has("Content-Type") && options.method === "POST") {
      headers.set("Content-Type", "application/json");
    }
    headers.set("User-Agent", "Stella-Obsidian-Plugin/1.0");
    const enhancedOptions = {
      ...options,
      headers
    };
    return await fetch(url, enhancedOptions);
  }
};
var CacheManager = class {
  // 1 hour in milliseconds
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.DEFAULT_TTL = 36e5;
    this.loadFromLocalStorage();
    setInterval(() => this.cleanExpiredEntries(), 3e5);
  }
  set(key, data, ttlMs = this.DEFAULT_TTL) {
    const item = {
      data: JSON.parse(JSON.stringify(data)),
      // Deep clone to avoid references
      timestamp: Date.now(),
      ttl: ttlMs
    };
    this.cache.set(key, item);
    try {
      if (this.getDataSize(data) < 1e5) {
        localStorage.setItem(`stella_cache_${key}`, JSON.stringify(item));
      }
    } catch (error) {
      console.warn("Failed to persist cache item to localStorage:", error);
    }
  }
  get(key) {
    const item = this.cache.get(key);
    if (!item)
      return null;
    const now = Date.now();
    if (now - item.timestamp > item.ttl) {
      this.delete(key);
      return null;
    }
    return item.data;
  }
  delete(key) {
    this.cache.delete(key);
    localStorage.removeItem(`stella_cache_${key}`);
  }
  has(key) {
    const item = this.cache.get(key);
    if (!item)
      return false;
    const now = Date.now();
    if (now - item.timestamp > item.ttl) {
      this.delete(key);
      return false;
    }
    return true;
  }
  clear() {
    this.cache.clear();
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith("stella_cache_")) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach((key) => localStorage.removeItem(key));
  }
  loadFromLocalStorage() {
    try {
      const now = Date.now();
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith("stella_cache_")) {
          const rawData = localStorage.getItem(key);
          if (rawData) {
            const item = JSON.parse(rawData);
            const cacheKey = key.replace("stella_cache_", "");
            if (now - item.timestamp <= item.ttl) {
              this.cache.set(cacheKey, item);
            } else {
              localStorage.removeItem(key);
            }
          }
        }
      }
    } catch (error) {
      console.warn("Failed to load cache from localStorage:", error);
    }
  }
  cleanExpiredEntries() {
    const now = Date.now();
    const expiredKeys = [];
    this.cache.forEach((item, key) => {
      if (now - item.timestamp > item.ttl) {
        expiredKeys.push(key);
      }
    });
    expiredKeys.forEach((key) => this.delete(key));
  }
  getDataSize(data) {
    return new Blob([JSON.stringify(data)]).size;
  }
  // Cache key generators for common use cases
  static modelListKey(provider) {
    return `models_${provider}`;
  }
  static conversationMetaKey() {
    return "conversation_metadata";
  }
  static systemPromptsKey() {
    return "system_prompts_list";
  }
  static apiResponseKey(provider, modelName) {
    return `api_response_${provider}_${modelName}`;
  }
  // Cache invalidation methods
  invalidateProviderCache(provider) {
    const modelKey = CacheManager.modelListKey(provider);
    this.delete(modelKey);
  }
  invalidateAllModels() {
    const providers = ["openai", "anthropic", "google", "ollama", "lmstudio"];
    providers.forEach((provider) => this.invalidateProviderCache(provider));
  }
  invalidateConversationData() {
    this.delete(CacheManager.conversationMetaKey());
  }
  // Get cache statistics
  getCacheStats() {
    let totalSize = 0;
    const providers = /* @__PURE__ */ new Set();
    this.cache.forEach((item, key) => {
      totalSize += this.getDataSize(item.data);
      if (key.startsWith("models_")) {
        providers.add(key.replace("models_", ""));
      }
    });
    return {
      totalItems: this.cache.size,
      totalSize,
      providers: Array.from(providers)
    };
  }
};
var AsyncLogger = class {
  // Force flush at 100 messages
  constructor() {
    this.logQueue = [];
    this.isProcessing = false;
    this.FLUSH_INTERVAL = 1e3;
    // Flush every 1 second
    this.MAX_QUEUE_SIZE = 100;
    this.startPeriodicFlush();
  }
  startPeriodicFlush() {
    this.flushInterval = setInterval(() => {
      this.flushLogs();
    }, this.FLUSH_INTERVAL);
  }
  log(message, data) {
    this.addToQueue("log", message, data);
  }
  warn(message, data) {
    this.addToQueue("warn", message, data);
  }
  error(message, data) {
    this.addToQueue("error", message, data);
  }
  addToQueue(level, message, data) {
    this.logQueue.push({
      level,
      message,
      timestamp: Date.now(),
      data
    });
    if (this.logQueue.length >= this.MAX_QUEUE_SIZE) {
      this.flushLogs();
    }
  }
  async flushLogs() {
    if (this.isProcessing || this.logQueue.length === 0)
      return;
    this.isProcessing = true;
    const logsToFlush = [...this.logQueue];
    this.logQueue = [];
    setTimeout(() => {
      try {
        logsToFlush.forEach((log) => {
          const timestamp = new Date(log.timestamp).toISOString();
          const logMessage = `[${timestamp}] ${log.message}`;
          switch (log.level) {
            case "error":
              console.error(logMessage, log.data || "");
              break;
            case "warn":
              console.warn(logMessage, log.data || "");
              break;
            default:
              console.log(logMessage, log.data || "");
              break;
          }
        });
      } catch (error) {
        console.error("AsyncLogger flush failed:", error);
      } finally {
        this.isProcessing = false;
      }
    }, 0);
  }
  destroy() {
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
    }
    this.flushLogs();
  }
};
var MCPClientManager = class {
  constructor(logger) {
    this.servers = /* @__PURE__ */ new Map();
    this.connections = /* @__PURE__ */ new Map();
    this.tools = /* @__PURE__ */ new Map();
    this.resources = /* @__PURE__ */ new Map();
    this.prompts = /* @__PURE__ */ new Map();
    this.messageId = 0;
    this.pendingRequests = /* @__PURE__ */ new Map();
    this.logger = logger;
  }
  // Getters for accessing private properties
  getServers() {
    return this.servers;
  }
  getTools() {
    return this.tools;
  }
  getPrompts() {
    return this.prompts;
  }
  getResources() {
    return this.resources;
  }
  // Public methods to force refresh tools and prompts
  async refreshServerTools(serverId) {
    const server = this.servers.get(serverId);
    console.log(`MCP Debug - refreshServerTools called for ${serverId}, server exists: ${!!server}, connected: ${server == null ? void 0 : server.connected}`);
    if (server && server.connected) {
      console.log(`MCP Debug - Discovering tools for server ${serverId}...`);
      await this.discoverTools(serverId);
      const tools = this.tools.get(serverId) || [];
      console.log(`MCP Debug - After discovery, server ${serverId} has ${tools.length} tools:`, tools.map((t) => t.name));
    }
  }
  async refreshServerPrompts(serverId) {
    const server = this.servers.get(serverId);
    console.log(`MCP Debug - refreshServerPrompts called for ${serverId}, server exists: ${!!server}, connected: ${server == null ? void 0 : server.connected}`);
    if (server && server.connected) {
      console.log(`MCP Debug - Discovering prompts for server ${serverId}...`);
      await this.discoverPrompts(serverId);
      const prompts = this.prompts.get(serverId) || [];
      console.log(`MCP Debug - After discovery, server ${serverId} has ${prompts.length} prompts:`, prompts.map((p) => p.name));
    }
  }
  // Server Management
  async addServer(server) {
    this.logger.log(`Adding MCP server: ${server.name}`);
    this.servers.set(server.id, server);
    return this.connectToServer(server.id);
  }
  async removeServer(serverId) {
    this.logger.log(`Removing MCP server: ${serverId}`);
    await this.disconnectFromServer(serverId);
    this.servers.delete(serverId);
    this.tools.delete(serverId);
    this.resources.delete(serverId);
    this.prompts.delete(serverId);
  }
  async connectToServer(serverId) {
    const server = this.servers.get(serverId);
    if (!server) {
      this.logger.error(`Server not found: ${serverId}`);
      return false;
    }
    try {
      if (server.transport === "http") {
        return await this.connectHTTP(server);
      } else if (server.transport === "stdio") {
        return await this.connectStdio(server);
      }
    } catch (error) {
      this.logger.error(`Failed to connect to server ${serverId}:`, error);
      server.connected = false;
      return false;
    }
    return false;
  }
  async connectHTTP(server) {
    if (!server.endpoint) {
      this.logger.error(`HTTP server ${server.id} missing endpoint`);
      return false;
    }
    try {
      const ws = new WebSocket(server.endpoint);
      ws.onopen = () => {
        this.logger.log(`Connected to MCP server: ${server.name}`);
        server.connected = true;
        this.initializeServerCapabilities(server.id);
      };
      ws.onmessage = (event) => {
        this.handleMessage(server.id, JSON.parse(event.data));
      };
      ws.onclose = () => {
        this.logger.log(`Disconnected from MCP server: ${server.name}`);
        server.connected = false;
      };
      ws.onerror = (error) => {
        this.logger.error(`WebSocket error for server ${server.name}:`, error);
        server.connected = false;
      };
      this.connections.set(server.id, ws);
      return true;
    } catch (error) {
      this.logger.error(`HTTP connection failed for server ${server.id}:`, error);
      return false;
    }
  }
  /**
   * Fix command for Windows compatibility
   * On Windows, many commands need .cmd extension to work properly
   */
  fixWindowsCommand(command) {
    if (process.platform !== "win32") {
      return command;
    }
    const windowsCommands = ["npm", "npx", "yarn", "pnpm", "node"];
    const baseCommand = command.split(" ")[0];
    if (windowsCommands.includes(baseCommand) && !baseCommand.endsWith(".cmd")) {
      return command.replace(baseCommand, `${baseCommand}.cmd`);
    }
    return command;
  }
  async connectStdio(server) {
    if (!server.command) {
      this.logger.error(`STDIO server ${server.id} missing command`);
      return false;
    }
    try {
      const { spawn } = require("child_process");
      const args = server.args || [];
      const env = {
        ...process.env,
        ...server.env || {}
      };
      const command = this.fixWindowsCommand(server.command);
      this.logger.log(`Starting STDIO MCP server: ${command} ${args.join(" ")}`);
      const spawnOptions = {
        stdio: ["pipe", "pipe", "pipe"],
        env
      };
      if (process.platform === "win32" && command.endsWith(".cmd")) {
        spawnOptions.shell = true;
      }
      const childProcess = spawn(command, args, spawnOptions);
      childProcess.on("error", (error) => {
        this.logger.error(`STDIO server ${server.name} process error:`, error);
        server.connected = false;
      });
      childProcess.on("exit", (code, signal) => {
        this.logger.log(`STDIO server ${server.name} exited with code ${code}, signal ${signal}`);
        server.connected = false;
      });
      childProcess.stderr.on("data", (data) => {
        this.logger.warn(`STDIO server ${server.name} stderr: ${data.toString()}`);
      });
      let buffer = "";
      childProcess.stdout.on("data", (data) => {
        buffer += data.toString();
        let lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.trim()) {
            try {
              const message = JSON.parse(line.trim());
              this.handleMessage(server.id, message);
            } catch (error) {
              this.logger.error(`Failed to parse JSON from ${server.name}:`, error);
              this.logger.error(`Raw line: ${line}`);
            }
          }
        }
      });
      this.connections.set(server.id, childProcess);
      server.connected = true;
      this.logger.log(`Connected to STDIO MCP server: ${server.name}`);
      await this.initializeServerCapabilities(server.id);
      return true;
    } catch (error) {
      this.logger.error(`STDIO connection failed for server ${server.id}:`, error);
      return false;
    }
  }
  async disconnectFromServer(serverId) {
    const connection = this.connections.get(serverId);
    if (connection) {
      if (connection instanceof WebSocket) {
        connection.close();
      } else if (connection && connection.kill) {
        connection.kill("SIGTERM");
      }
      this.connections.delete(serverId);
    }
    const server = this.servers.get(serverId);
    if (server) {
      server.connected = false;
    }
  }
  // Protocol Message Handling
  async sendMessage(serverId, message) {
    try {
      console.log(`MCP sendMessage: Sending to server ${serverId}:`, message);
      const connection = this.connections.get(serverId);
      if (!connection) {
        throw new Error(`No connection to server: ${serverId}`);
      }
      if (message.method) {
        message.id = ++this.messageId;
        console.log(`MCP sendMessage: Added message ID: ${message.id}`);
      }
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          if (this.pendingRequests && this.pendingRequests.has(message.id)) {
            this.pendingRequests.delete(message.id);
          }
          reject(new Error("MCP request timeout"));
        }, 1e4);
        const responseHandler = (response) => {
          try {
            console.log(`MCP sendMessage: Got response for message ${message.id}:`, response);
            clearTimeout(timeout);
            if (this.pendingRequests && this.pendingRequests.has(message.id)) {
              this.pendingRequests.delete(message.id);
            }
            if (response && response.error) {
              reject(new Error(`MCP Error: ${response.error.message}`));
            } else {
              resolve(response ? response.result : null);
            }
          } catch (handlerError) {
            console.error("MCP sendMessage: Error in response handler:", handlerError);
            reject(handlerError);
          }
        };
        if (!this.pendingRequests) {
          this.pendingRequests = /* @__PURE__ */ new Map();
        }
        this.pendingRequests.set(message.id, responseHandler);
        if (connection instanceof WebSocket) {
          connection.send(JSON.stringify(message));
        } else if (connection && connection.stdin) {
          connection.stdin.write(JSON.stringify(message) + "\n");
        }
      });
    } catch (sendError) {
      console.error("MCP sendMessage: Error in sendMessage:", sendError);
      throw sendError;
    }
  }
  handleMessage(serverId, message) {
    try {
      this.logger.log(`Received MCP message from ${serverId}:`, message);
      if (!message) {
        console.warn(`Received null/undefined message from server ${serverId}`);
        return;
      }
      if (message.method) {
        this.handleServerRequest(serverId, message);
      } else if (message.result !== void 0 || message.error !== void 0) {
        this.handleServerResponse(serverId, message);
      } else {
        console.log(`Unknown message type from server ${serverId}:`, message);
      }
    } catch (error) {
      console.error(`Error handling message from server ${serverId}:`, error, message);
    }
  }
  handleServerRequest(serverId, message) {
    this.logger.log(`Server ${serverId} sent request: ${message.method}`);
  }
  handleServerResponse(serverId, message) {
    try {
      const messageId = message == null ? void 0 : message.id;
      this.logger.log(`Server ${serverId} sent response to request ${messageId || "unknown"}`);
      if (messageId && this.pendingRequests && this.pendingRequests.has(messageId)) {
        const responseHandler = this.pendingRequests.get(messageId);
        if (responseHandler && typeof responseHandler === "function") {
          responseHandler(message);
        }
        this.pendingRequests.delete(messageId);
      } else {
        console.log(`No pending request handler found for message ID: ${messageId}`);
      }
    } catch (error) {
      console.error(`Error handling server response from ${serverId}:`, error, message);
    }
  }
  // Server Initialization
  async initializeServerCapabilities(serverId) {
    try {
      await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "initialize",
        params: {
          protocolVersion: "2024-11-05",
          capabilities: {
            roots: {
              listChanged: true
            },
            sampling: {}
          },
          clientInfo: {
            name: "stella-obsidian-plugin",
            version: "1.0.0"
          }
        }
      });
      await this.discoverTools(serverId);
      await this.discoverResources(serverId);
      await this.discoverPrompts(serverId);
    } catch (error) {
      this.logger.error(`Failed to initialize server ${serverId}:`, error);
    }
  }
  // Tool Discovery and Execution
  async discoverTools(serverId) {
    try {
      console.log(`MCP Debug - Discovering tools for server ${serverId}`);
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "tools/list"
      });
      console.log(`MCP Debug - Tools/list result for ${serverId}:`, result);
      if (result == null ? void 0 : result.tools) {
        const tools = result.tools.map((tool) => ({
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema,
          serverId
        }));
        console.log(`MCP Debug - Mapped ${tools.length} tools for server ${serverId}:`, tools.map((t) => t.name));
        this.tools.set(serverId, tools);
        this.logger.log(`Discovered ${tools.length} tools for server ${serverId}`);
      }
    } catch (error) {
      this.logger.error(`Failed to discover tools for server ${serverId}:`, error);
    }
  }
  async executeTool(serverId, toolName, arguments_) {
    try {
      console.log(`MCP executeTool: Starting execution of ${toolName} on server ${serverId}`);
      console.log(`MCP executeTool: Arguments:`, arguments_);
      const safeArguments = arguments_ || {};
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "tools/call",
        params: {
          name: toolName,
          arguments: safeArguments
        }
      });
      console.log(`MCP executeTool: Got result for ${toolName}:`, result);
      this.logger.log(`Executed tool ${toolName} on server ${serverId}`);
      return result;
    } catch (error) {
      console.error(`MCP executeTool: Failed to execute tool ${toolName} on server ${serverId}:`, error);
      this.logger.error(`Failed to execute tool ${toolName} on server ${serverId}:`, error);
      throw error;
    }
  }
  // Resource Discovery and Access
  async discoverResources(serverId) {
    try {
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "resources/list"
      });
      if (result == null ? void 0 : result.resources) {
        const resources = result.resources.map((resource) => ({
          uri: resource.uri,
          name: resource.name,
          description: resource.description,
          mimeType: resource.mimeType,
          serverId
        }));
        this.resources.set(serverId, resources);
        this.logger.log(`Discovered ${resources.length} resources for server ${serverId}`);
      }
    } catch (error) {
      this.logger.error(`Failed to discover resources for server ${serverId}:`, error);
    }
  }
  async getResource(serverId, uri) {
    try {
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "resources/read",
        params: { uri }
      });
      this.logger.log(`Retrieved resource ${uri} from server ${serverId}`);
      return result;
    } catch (error) {
      this.logger.error(`Failed to get resource ${uri} from server ${serverId}:`, error);
      throw error;
    }
  }
  // Prompt Discovery and Usage
  async discoverPrompts(serverId) {
    try {
      console.log(`MCP Debug - Discovering prompts for server ${serverId}`);
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "prompts/list"
      });
      console.log(`MCP Debug - Prompts/list result for ${serverId}:`, result);
      if (result == null ? void 0 : result.prompts) {
        const prompts = result.prompts.map((prompt) => ({
          name: prompt.name,
          description: prompt.description,
          arguments: prompt.arguments,
          serverId
        }));
        console.log(`MCP Debug - Mapped ${prompts.length} prompts for server ${serverId}:`, prompts.map((p) => p.name));
        this.prompts.set(serverId, prompts);
        this.logger.log(`Discovered ${prompts.length} prompts for server ${serverId}`);
      }
    } catch (error) {
      this.logger.error(`Failed to discover prompts for server ${serverId}:`, error);
    }
  }
  async getPrompt(serverId, promptName, arguments_) {
    try {
      const result = await this.sendMessage(serverId, {
        jsonrpc: "2.0",
        method: "prompts/get",
        params: {
          name: promptName,
          arguments: arguments_
        }
      });
      this.logger.log(`Retrieved prompt ${promptName} from server ${serverId}`);
      return result;
    } catch (error) {
      this.logger.error(`Failed to get prompt ${promptName} from server ${serverId}:`, error);
      throw error;
    }
  }
  // Public API for UI
  getConnectedServers() {
    return Array.from(this.servers.values()).filter((server) => server.connected);
  }
  getAllTools() {
    const allTools = [];
    for (const tools of this.tools.values()) {
      allTools.push(...tools);
    }
    return allTools;
  }
  getAllResources() {
    const allResources = [];
    for (const resources of this.resources.values()) {
      allResources.push(...resources);
    }
    return allResources;
  }
  getAllPrompts() {
    const allPrompts = [];
    for (const prompts of this.prompts.values()) {
      allPrompts.push(...prompts);
    }
    return allPrompts;
  }
  destroy() {
    this.logger.log("Destroying MCP Client Manager");
    for (const serverId of this.servers.keys()) {
      this.disconnectFromServer(serverId);
    }
    this.servers.clear();
    this.connections.clear();
    this.tools.clear();
    this.resources.clear();
    this.prompts.clear();
    this.pendingRequests.clear();
  }
};
var StellaPlugin = class extends import_obsidian.Plugin {
  get cache() {
    return this.cacheManager;
  }
  get mcp() {
    return this.mcpManager;
  }
  get mcpClientManager() {
    return this.mcpManager;
  }
  // MCP Server Initialization
  async initializeMCPServers() {
    this.logger.log("Initializing MCP servers...");
    for (const serverConfig of this.settings.mcpServers) {
      try {
        const success = await this.mcpManager.addServer(serverConfig);
        if (success) {
          this.logger.log(`Successfully connected to MCP server: ${serverConfig.name}`);
        } else {
          this.logger.warn(`Failed to connect to MCP server: ${serverConfig.name}`);
        }
      } catch (error) {
        this.logger.error(`Error connecting to MCP server ${serverConfig.name}:`, error);
      }
    }
    const connectedCount = this.mcpManager.getConnectedServers().length;
    this.logger.log(`MCP initialization complete. Connected to ${connectedCount} server(s).`);
  }
  async onload() {
    this.logger = new AsyncLogger();
    this.cacheManager = new CacheManager();
    this.mcpManager = new MCPClientManager(this.logger);
    this.logger.log("Stella plugin loading...");
    await this.loadSettings();
    if (this.settings.mcpEnabled) {
      await this.initializeMCPServers();
    }
    this.registerView(
      CHAT_VIEW_TYPE,
      (leaf) => new StellaChatView(leaf, this)
    );
    this.addRibbonIcon("message-circle", "Open Stella Chat", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-stella-chat",
      name: "Open Stella Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new StellaSettingTab(this.app, this));
    setTimeout(() => {
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateModelInfo) {
          chatView.updateModelInfo(chatView.modelInfoContainer);
        }
      });
    }, 1e3);
  }
  async onunload() {
    this.logger.log("Stella plugin unloading...");
    this.logger.destroy();
    this.app.workspace.detachLeavesOfType(CHAT_VIEW_TYPE);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (typeof this.settings.backgroundImage === "undefined") {
      this.settings.backgroundImage = "";
      this.settings.backgroundMode = "centered";
      this.settings.backgroundOpacity = 0.5;
    }
    if (!this.settings.conversations) {
      this.settings.conversations = [];
    }
    this.logger.log(`Loaded settings - Conversations count: ${this.settings.conversations.length}`);
  }
  async saveSettings() {
    if (!this.settings.conversations) {
      this.logger.warn("Conversations array is missing, preserving existing data");
      const existingData = await this.loadData();
      if (existingData && existingData.conversations) {
        this.settings.conversations = existingData.conversations;
      } else {
        this.settings.conversations = [];
      }
    }
    this.logger.log(`Saving settings - Conversations count: ${this.settings.conversations.length}`);
    await this.saveData(this.settings);
    this.cacheManager.invalidateConversationData();
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(CHAT_VIEW_TYPE);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: CHAT_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE)[0]
    );
  }
};
var CHAT_VIEW_TYPE = "stella-mcp-chat-view";
var StellaChatView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.conversations = [];
    this.currentConversationId = null;
    this.chatHistory = [];
    this.currentSystemPrompt = null;
    this.currentSystemPromptFilename = null;
    this.currentMentalModel = null;
    this.currentMentalModelFilename = null;
    // Message pagination state
    this.messagePageSize = 50;
    // Show 50 messages at a time
    this.currentMessagePage = 0;
    this.totalMessagePages = 0;
    this.isLoadingMoreMessages = false;
    this.contextNotes = [];
    // MCP context state
    this.activeMCPServers = [];
    // Available commands list (keep this updated when adding new commands)
    this.availableCommands = [
      { command: "/help", description: "Show all available commands" },
      { command: "/sys", description: "Load system prompt from file" },
      { command: "/sysclear", description: "Clear current system prompt" },
      { command: "/model", description: "Load mental model from file" },
      { command: "/modelclear", description: "Clear current mental model" },
      { command: "/mcp", description: "Connect to MCP server" },
      { command: "/mcpclear", description: "Clear MCP connections" },
      { command: "/clear", description: "Clear all context and start new conversation" },
      { command: "/new", description: "Start new conversation" },
      { command: "/del", description: "Delete current conversation" },
      { command: "/history", description: "Show conversation history" },
      { command: "/name", description: "Rename current conversation" },
      { command: "/settings", description: "Open plugin settings" },
      { command: "/hide", description: "Toggle header visibility" }
    ];
    this.plugin = plugin;
    this.logger = new AsyncLogger();
  }
  getViewType() {
    return CHAT_VIEW_TYPE;
  }
  getDisplayText() {
    return "Stella";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("stella-mcp-chat-container");
    this.buildChatUI(container);
    this.loadConversations();
    this.updateHeaderVisibility();
    this.updateBackgroundImage();
  }
  buildChatUI(container) {
    this.chatContainer = container;
    const header = container.createEl("div", { cls: "stella-chat-header" });
    this.headerContainer = header;
    const leftControls = header.createEl("div", { cls: "stella-header-left" });
    this.conversationNameInput = leftControls.createEl("input", {
      cls: "stella-conversation-name",
      type: "text",
      value: "Current Chat"
    });
    this.conversationNameInput.addEventListener("blur", () => {
      this.saveConversationName();
    });
    this.conversationNameInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        this.conversationNameInput.blur();
      }
    });
    const rightControls = header.createEl("div", { cls: "stella-header-right" });
    this.modelInfoContainer = rightControls.createEl("span", { cls: "stella-model-info" });
    this.updateModelInfo(this.modelInfoContainer);
    const newChatBtn = rightControls.createEl("button", {
      cls: "stella-action-btn",
      attr: { "aria-label": "New chat" }
    });
    newChatBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
    newChatBtn.addEventListener("click", () => {
      this.startNewConversation();
    });
    const historyBtn = rightControls.createEl("button", {
      cls: "stella-action-btn",
      attr: { "aria-label": "Chat history" }
    });
    historyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12,6 12,12 16,14"></polyline></svg>';
    historyBtn.addEventListener("click", () => {
      try {
        this.showChatHistory();
      } catch (error) {
        this.logger.error("Error showing chat history:", error);
        console.log("Chat history feature will be implemented in a future update.");
      }
    });
    const settingsBtn = rightControls.createEl("button", {
      cls: "stella-action-btn",
      attr: { "aria-label": "Settings" }
    });
    settingsBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>';
    settingsBtn.addEventListener("click", () => {
      this.openSettings();
    });
    this.messagesContainer = container.createEl("div", { cls: "stella-messages-container" });
    this.contextIndicator = container.createEl("div", {
      cls: "stella-context-indicator"
    });
    this.updateContextIndicator();
    this.inputContainer = container.createEl("div", { cls: "stella-input-container" });
    this.chatInput = this.inputContainer.createEl("textarea", {
      cls: "stella-chat-input"
    });
    this.systemPromptIndicator = this.inputContainer.createEl("div", {
      cls: "stella-system-prompt-indicator",
      attr: { "title": "System prompt loaded - use /sysclear to remove" }
    });
    this.updateSystemPromptIndicator();
    this.mentalModelIndicator = this.inputContainer.createEl("div", {
      cls: "stella-mental-model-indicator",
      attr: { "title": "Mental model loaded - use /modelclear to remove" }
    });
    this.updateMentalModelIndicator();
    this.mcpIndicator = this.inputContainer.createEl("div", {
      cls: "stella-mcp-indicator"
    });
    this.noteIndicator = this.inputContainer.createEl("div", {
      cls: "stella-note-indicator"
    });
    this.updateMCPIndicator();
    this.chatInput.addEventListener("keydown", (e) => {
      if (e.key === "@") {
        e.preventDefault();
        this.showNoteSelector();
        return;
      }
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        const message = this.chatInput.value.trim();
        console.log("Enter pressed with message:", message);
        if (message === "/sys") {
          this.showSystemPromptSelector();
          this.chatInput.value = "";
          return;
        }
        if (message === "/sysclear") {
          this.unloadSystemPrompt();
          this.chatInput.value = "";
          return;
        }
        if (message === "/model") {
          this.showMentalModelSelector();
          this.chatInput.value = "";
          return;
        }
        if (message === "/modelclear") {
          this.unloadMentalModel();
          this.chatInput.value = "";
          return;
        }
        if (message === "/mcp") {
          this.showMCPSelector();
          this.chatInput.value = "";
          return;
        }
        if (message === "/new") {
          this.startNewConversation();
          this.chatInput.value = "";
          return;
        }
        if (message === "/del") {
          this.deleteCurrentConversationAndStartNew();
          this.chatInput.value = "";
          return;
        }
        if (message === "/history") {
          this.showChatHistory();
          this.chatInput.value = "";
          return;
        }
        if (message === "/settings") {
          this.openPluginSettings();
          this.chatInput.value = "";
          return;
        }
        if (message === "/name") {
          this.showNameInput();
          this.chatInput.value = "";
          return;
        }
        if (message === "/hide") {
          this.toggleHeader();
          this.chatInput.value = "";
          return;
        }
        if (message === "/help") {
          this.showHelpMessage();
          this.chatInput.value = "";
          return;
        }
        this.sendMessage();
      }
    });
    this.updateBackgroundImage();
  }
  async sendMessage() {
    const message = this.chatInput.value.trim();
    if (!message)
      return;
    if (message === "/sys") {
      this.showSystemPromptSelector();
      this.chatInput.value = "";
      return;
    }
    if (message === "/sysclear") {
      this.unloadSystemPrompt();
      this.chatInput.value = "";
      return;
    }
    if (message === "/model") {
      this.showMentalModelSelector();
      this.chatInput.value = "";
      return;
    }
    if (message === "/modelclear") {
      this.unloadMentalModel();
      this.chatInput.value = "";
      return;
    }
    if (message === "/mcp") {
      this.showMCPSelector();
      this.chatInput.value = "";
      return;
    }
    if (message === "/mcpclear") {
      this.clearMCPContext();
      this.chatInput.value = "";
      return;
    }
    if (message === "/clear") {
      this.clearAllContext();
      this.chatInput.value = "";
      return;
    }
    if (message.startsWith("/")) {
      this.logger.warn(`Unknown slash command detected: ${message}`);
      const commandList = this.availableCommands.map((cmd) => cmd.command).join(", ");
      this.addMessage(`Unknown command: ${message}. Available commands: ${commandList}`, "error");
      this.chatInput.value = "";
      return;
    }
    const userMessageEl = this.addMessage(message, "user");
    this.chatInput.value = "";
    await this.detectAndActivateMCP(message);
    const loadingOverlay = this.messagesContainer.createDiv("stella-cat-loading-overlay");
    setTimeout(() => {
      loadingOverlay.classList.add("stella-cat-loading-visible");
    }, 100);
    setTimeout(() => {
      loadingOverlay.scrollIntoView({ behavior: "smooth", block: "center" });
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }, 200);
    const catTimerGroup = loadingOverlay.createDiv("stella-cat-timer-group");
    const catSprite = catTimerGroup.createEl("img", {
      cls: "stella-cat-sprite",
      attr: {
        alt: "Bulbasaur loading animation"
      }
    });
    this.loadGifAsDataUrl(catSprite);
    const timerText = catTimerGroup.createDiv("stella-countdown-timer");
    let tokenCounter = null;
    let mcpStatus = null;
    if (this.plugin.settings.showTokenCount) {
      tokenCounter = loadingOverlay.createDiv("stella-token-counter-floating");
      tokenCounter.textContent = "Estimating tokens...";
    }
    if (this.activeMCPServers && this.activeMCPServers.length > 0) {
      mcpStatus = loadingOverlay.createDiv("stella-mcp-status-floating");
      mcpStatus.textContent = "";
      mcpStatus.style.display = "none";
      mcpStatus.style.position = "absolute";
      mcpStatus.style.right = "40px";
      mcpStatus.style.top = tokenCounter ? "60px" : "80px";
      mcpStatus.style.fontSize = "12px";
      mcpStatus.style.color = "var(--text-muted)";
      mcpStatus.style.backgroundColor = "var(--background-secondary)";
      mcpStatus.style.padding = "4px 8px";
      mcpStatus.style.borderRadius = "12px";
      mcpStatus.style.border = "1px solid var(--background-modifier-border)";
      mcpStatus.style.zIndex = "1001";
    }
    const estimatedTokens = this.estimateTokens(message + this.buildSystemMessage());
    let elapsedSeconds = 0;
    timerText.textContent = `${elapsedSeconds}s`;
    setTimeout(() => {
      loadingOverlay.classList.add("stella-cat-loading-visible");
    }, 50);
    let displayedTokens = Math.floor(estimatedTokens * 0.3);
    const loadingInterval = setInterval(() => {
      elapsedSeconds++;
      timerText.textContent = `${elapsedSeconds}s`;
      if (tokenCounter) {
        const increment = Math.max(1, Math.floor(estimatedTokens / (elapsedSeconds + 10)));
        displayedTokens = Math.min(displayedTokens + increment, estimatedTokens);
        tokenCounter.textContent = `${displayedTokens} tokens`;
      }
    }, 1e3);
    try {
      const response = await this.callLLM(message);
      clearInterval(loadingInterval);
      this.hideLoadingAnimation(loadingOverlay);
      const responseTokens = this.estimateTokens(response);
      const totalTokens = estimatedTokens + responseTokens;
      if (tokenCounter) {
        tokenCounter.textContent = `${totalTokens} tokens`;
      }
      setTimeout(() => {
        const responseEl = this.addMessage(response, "assistant");
        if (this.plugin.settings.showTokenCount) {
          const responseContentEl = responseEl.querySelector(".stella-message-content");
          const finalTokenCounter = responseContentEl.createDiv("stella-token-counter stella-token-final");
          finalTokenCounter.textContent = `${totalTokens} tokens`;
        }
      }, 300);
    } catch (error) {
      clearInterval(loadingInterval);
      this.hideLoadingAnimation(loadingOverlay);
      this.addMessage(`Error: ${error.message}`, "error");
    }
  }
  hideLoadingAnimation(loadingOverlay) {
    loadingOverlay.classList.add("stella-cat-loading-hiding");
    setTimeout(() => {
      loadingOverlay.remove();
    }, 300);
  }
  async loadGifAsDataUrl(imgElement) {
    try {
      const paths = [
        "bulbasaur.gif",
        "./bulbasaur.gif",
        `${this.plugin.manifest.dir}/bulbasaur.gif`,
        `.obsidian/plugins/stella/bulbasaur.gif`
      ];
      for (const path of paths) {
        try {
          const response = await fetch(path);
          if (response.ok) {
            const blob = await response.blob();
            const reader = new FileReader();
            reader.onload = () => {
              imgElement.src = reader.result;
            };
            reader.readAsDataURL(blob);
            return;
          }
        } catch (e) {
          continue;
        }
      }
      const adapter = this.app.vault.adapter;
      if ("readBinary" in adapter) {
        const pluginDir = ".obsidian/plugins/stella";
        const gifPath = `${pluginDir}/bulbasaur.gif`;
        const data = await adapter.readBinary(gifPath);
        const blob = new Blob([data], { type: "image/gif" });
        const reader = new FileReader();
        reader.onload = () => {
          imgElement.src = reader.result;
        };
        reader.readAsDataURL(blob);
      }
    } catch (error) {
      console.error("Failed to load Bulbasaur GIF:", error);
      imgElement.style.background = "#7CD55A";
      imgElement.style.borderRadius = "4px";
    }
  }
  addMessage(content, type, isTemp = false) {
    if (!isTemp) {
      this.chatHistory.push({
        role: type === "user" ? "user" : "assistant",
        content,
        timestamp: Date.now()
      });
      if (this.currentConversationId) {
        this.saveCurrentConversation();
      }
    }
    return this.addMessageToUI(content, type, isTemp);
  }
  addMessageToUI(content, type, isTemp = false) {
    const messageEl = this.messagesContainer.createEl("div", {
      cls: `stella-message stella-message-${type}`
    });
    if (isTemp) {
      messageEl.addClass("stella-message-temp");
    }
    const contentEl = messageEl.createEl("div", { cls: "stella-message-content" });
    if (type === "assistant" && !isTemp) {
      this.renderMarkdown(contentEl, content);
    } else {
      this.renderTextWithWikiLinks(contentEl, content);
    }
    this.setupContextMenu(contentEl);
    return messageEl;
  }
  // Simple token estimation (roughly 4 characters per token)
  estimateTokens(text) {
    return Math.ceil(text.length / 4);
  }
  setupContextMenu(contentEl) {
    contentEl.addEventListener("contextmenu", (e) => {
      const selection = window.getSelection();
      const selectedText = selection == null ? void 0 : selection.toString().trim();
      if (selectedText) {
        e.preventDefault();
        this.showQuickAddContextMenu(e, selectedText);
      }
    });
  }
  showQuickAddContextMenu(event, selectedText) {
    const menu = new import_obsidian.Menu();
    this.plugin.settings.quickAddCommands.forEach((command) => {
      menu.addItem(
        (item) => item.setTitle(command.name).setIcon("plus-circle").onClick(() => {
          this.executeQuickAddCommand(command.id, selectedText);
        })
      );
    });
    if (this.plugin.settings.quickAddCommands.length === 0) {
      menu.addItem(
        (item) => item.setTitle("No QuickAdd commands configured").setDisabled(true)
      );
    }
    menu.showAtMouseEvent(event);
  }
  async executeQuickAddCommand(commandId, selectedText) {
    var _a;
    try {
      const plugins = this.app.plugins;
      const quickAddPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["quickadd"];
      if (!quickAddPlugin) {
        new import_obsidian.Notice("QuickAdd plugin is not installed or enabled");
        return;
      }
      window.stellaSelectedText = selectedText;
      const commands = this.app.commands;
      if (!commands) {
        new import_obsidian.Notice("Commands system not available");
        return;
      }
      const allCommands = commands.listCommands();
      console.log("Available QuickAdd commands:", allCommands.filter((cmd) => cmd.id.includes("quickadd")));
      const possibleCommandIds = [
        `quickadd:choice:${commandId}`,
        `quickadd:${commandId}`,
        commandId,
        `QuickAdd: ${commandId}`,
        // Case variations
        commandId.toLowerCase(),
        commandId.toUpperCase()
      ];
      let commandExecuted = false;
      for (const cmdId of possibleCommandIds) {
        try {
          const foundCommand = allCommands.find(
            (cmd) => {
              var _a2;
              return cmd.id === cmdId || cmd.id.toLowerCase() === cmdId.toLowerCase() || ((_a2 = cmd.name) == null ? void 0 : _a2.toLowerCase().includes(commandId.toLowerCase()));
            }
          );
          if (foundCommand) {
            console.log(`Found QuickAdd command: ${foundCommand.id} (${foundCommand.name})`);
            commands.executeCommandById(foundCommand.id);
            new import_obsidian.Notice(`Executed QuickAdd command: ${foundCommand.name}`);
            commandExecuted = true;
            break;
          }
        } catch (error) {
          console.log(`Failed to execute command ID: ${cmdId}`, error);
        }
      }
      if (!commandExecuted) {
        const quickAddCommands = allCommands.filter((cmd) => cmd.id.includes("quickadd"));
        console.log("Available QuickAdd commands:", quickAddCommands.map((cmd) => ({ id: cmd.id, name: cmd.name })));
        if (quickAddCommands.length > 0) {
          new import_obsidian.Notice(`QuickAdd command '${commandId}' not found. Available commands: ${quickAddCommands.map((cmd) => cmd.name).join(", ")}`);
        } else {
          new import_obsidian.Notice("No QuickAdd commands found. Make sure QuickAdd is properly configured.");
        }
      }
    } catch (error) {
      new import_obsidian.Notice("Failed to execute QuickAdd command");
      console.error("QuickAdd execution error:", error);
    }
  }
  async renderMarkdown(container, content) {
    try {
      await import_obsidian.MarkdownRenderer.renderMarkdown(content, container, "", this);
    } catch (error) {
      console.error("Error rendering markdown:", error);
      container.textContent = content;
    }
    this.processAllWikiLinks(container, content);
  }
  preprocessWikiLinks(content) {
    const wikiLinkRegex = /\[\[([^\]]+?)(?:\|([^\]]+?))?\]\]/g;
    let processedContent = content;
    processedContent = processedContent.replace(wikiLinkRegex, (match, noteName, displayText) => {
      const placeholder = `__WIKILINK__${noteName}__${displayText || noteName}__ENDWIKILINK__`;
      return placeholder;
    });
    return processedContent;
  }
  enhanceWikiLinks(container) {
    this.processWikiLinkPlaceholders(container);
    const wikiLinks = container.querySelectorAll("a.internal-link");
    wikiLinks.forEach((link) => {
      const href = link.getAttribute("href");
      if (!href)
        return;
      const noteName = decodeURIComponent(href);
      const file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
      const exists = file !== null;
      link.classList.add("stella-wiki-link");
      if (!exists) {
        link.classList.add("stella-wiki-link-missing");
      }
      link.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.ctrlKey || e.metaKey) {
          if (exists) {
            this.app.workspace.openLinkText(noteName, "");
          }
        } else {
          if (exists) {
            this.addNoteToContext(file);
          } else {
            this.addMessage(`Note "${noteName}" not found in vault`, "error");
          }
        }
      });
      const existingTitle = link.getAttribute("title") || "";
      link.setAttribute(
        "title",
        exists ? `${existingTitle ? existingTitle + " | " : ""}Click to add to context, Ctrl+Click to open` : `Note "${noteName}" not found`
      );
    });
  }
  processWikiLinkPlaceholders(container) {
    const placeholderRegex = /__WIKILINK__([^_]+?)__([^_]+?)__ENDWIKILINK__/g;
    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT
    );
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      if (node.textContent && node.textContent.includes("__WIKILINK__")) {
        textNodes.push(node);
      }
    }
    textNodes.forEach((textNode) => {
      var _a;
      const content = textNode.textContent || "";
      if (placeholderRegex.test(content)) {
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        placeholderRegex.lastIndex = 0;
        while ((match = placeholderRegex.exec(content)) !== null) {
          if (match.index > lastIndex) {
            const textBefore = content.slice(lastIndex, match.index);
            fragment.appendChild(document.createTextNode(textBefore));
          }
          const noteName = match[1];
          const displayText = match[2];
          const linkWrapper = document.createElement("span");
          this.createWikiLinkElement(linkWrapper, noteName, displayText);
          fragment.appendChild(linkWrapper.firstChild);
          lastIndex = match.index + match[0].length;
        }
        if (lastIndex < content.length) {
          const textAfter = content.slice(lastIndex);
          fragment.appendChild(document.createTextNode(textAfter));
        }
        (_a = textNode.parentNode) == null ? void 0 : _a.replaceChild(fragment, textNode);
      }
    });
  }
  processAllWikiLinks(container, originalContent) {
    this.enhanceExistingWikiLinks(container);
    this.processUnprocessedWikiLinks(container, originalContent);
  }
  enhanceExistingWikiLinks(container) {
    const existingLinks = container.querySelectorAll("a.internal-link");
    existingLinks.forEach((link) => {
      this.enhanceWikiLink(link);
    });
  }
  processUnprocessedWikiLinks(container, originalContent) {
    const wikiLinkRegex = /\[\[([^\]]+?)(?:\|([^\]]+?))?\]\]/g;
    const matches = Array.from(originalContent.matchAll(wikiLinkRegex));
    if (matches.length === 0)
      return;
    console.log("Found wiki links to process:", matches.map((m) => m[0]));
    const textNodes = [];
    this.collectTextNodes(container, textNodes);
    console.log("Found text nodes:", textNodes.length);
    textNodes.forEach((textNode, index) => {
      const content = textNode.textContent || "";
      if (content.includes("[[") && content.includes("]]")) {
        console.log(`Processing text node ${index}:`, content.substring(0, 100));
        this.replaceWikiLinksInTextNode(textNode, content);
      }
    });
  }
  collectTextNodes(node, textNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      textNodes.push(node);
    } else {
      for (let child of Array.from(node.childNodes)) {
        this.collectTextNodes(child, textNodes);
      }
    }
  }
  replaceWikiLinksInTextNode(textNode, content) {
    console.log("Replacing wiki links in text node:", content.substring(0, 100));
    const wikiLinkRegex = /\[\[([^\]]+?)(?:\|([^\]]+?))?\]\]/g;
    const fragment = document.createDocumentFragment();
    let lastIndex = 0;
    let match;
    let replacements = 0;
    wikiLinkRegex.lastIndex = 0;
    while ((match = wikiLinkRegex.exec(content)) !== null) {
      if (match.index > lastIndex) {
        const textBefore = content.slice(lastIndex, match.index);
        fragment.appendChild(document.createTextNode(textBefore));
      }
      const noteName = match[1].trim();
      const displayText = match[2] ? match[2].trim() : noteName;
      console.log(`Creating wiki link: ${noteName} -> ${displayText}`);
      const link = this.createWikiLink(noteName, displayText);
      fragment.appendChild(link);
      replacements++;
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < content.length) {
      const textAfter = content.slice(lastIndex);
      fragment.appendChild(document.createTextNode(textAfter));
    }
    console.log(`Made ${replacements} wiki link replacements`);
    if (replacements > 0 && textNode.parentNode) {
      textNode.parentNode.replaceChild(fragment, textNode);
    }
  }
  createWikiLink(noteName, displayText) {
    const file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
    const exists = file !== null;
    const link = document.createElement("a");
    link.textContent = displayText;
    link.className = "stella-wiki-link internal-link";
    if (!exists) {
      link.classList.add("stella-wiki-link-missing");
    }
    this.enhanceWikiLink(link, noteName, file);
    return link;
  }
  enhanceWikiLink(link, noteName, file) {
    if (!noteName) {
      const href = link.getAttribute("href");
      noteName = href ? decodeURIComponent(href) : link.textContent || "";
    }
    if (!file) {
      file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
    }
    const exists = file !== null;
    link.classList.add("stella-wiki-link");
    if (!exists) {
      link.classList.add("stella-wiki-link-missing");
    }
    link.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.ctrlKey || e.metaKey) {
        if (exists) {
          this.app.workspace.openLinkText(noteName, "");
        }
      } else {
        if (exists) {
          this.addNoteToContext(file);
        } else {
          this.addMessage(`Note "${noteName}" not found in vault`, "error");
        }
      }
    });
    link.setAttribute(
      "title",
      exists ? `Click to add to context, Ctrl+Click to open` : `Note "${noteName}" not found`
    );
  }
  renderTextWithWikiLinks(container, content) {
    container.textContent = content;
    this.processAllWikiLinks(container, content);
  }
  createWikiLinkElement(container, noteName, displayText) {
    const file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
    const exists = file !== null;
    const link = container.createEl("a", {
      text: displayText,
      cls: ["stella-wiki-link", "internal-link"]
    });
    if (!exists) {
      link.classList.add("stella-wiki-link-missing");
    }
    link.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.ctrlKey || e.metaKey) {
        if (exists) {
          this.app.workspace.openLinkText(noteName, "");
        }
      } else {
        if (exists) {
          this.addNoteToContext(file);
        } else {
          this.addMessage(`Note "${noteName}" not found in vault`, "error");
        }
      }
    });
    link.setAttribute(
      "title",
      exists ? `Click to add to context, Ctrl+Click to open` : `Note "${noteName}" not found`
    );
  }
  async addNoteToContext(file) {
    try {
      const content = await this.app.vault.read(file);
      const existing = this.contextNotes.find((note) => note.name === file.basename);
      if (existing) {
        this.addMessage(`"${file.basename}" is already in context`, "error");
        return;
      }
      this.contextNotes.push({
        name: file.basename,
        content
      });
      this.updateContextIndicator();
    } catch (error) {
      this.addMessage(`Error loading "${file.basename}": ${error.message}`, "error");
    }
  }
  async streamLLMResponse(message, contentEl) {
    const { provider } = this.plugin.settings;
    let accumulatedResponse = "";
    let streamingSucceeded = false;
    const updateContent = (text) => {
      accumulatedResponse += text;
      contentEl.textContent = accumulatedResponse;
    };
    const finalizeContent = async () => {
      const messageEl = contentEl.closest(".stella-message");
      if (messageEl) {
        messageEl.removeClass("stella-message-temp");
      }
      contentEl.innerHTML = "";
      await this.renderMarkdown(contentEl, accumulatedResponse);
      this.chatHistory.push({
        role: "assistant",
        content: accumulatedResponse,
        timestamp: Date.now()
      });
      if (this.currentConversationId) {
        this.saveCurrentConversation();
      }
      streamingSucceeded = true;
    };
    try {
      console.log(`Attempting streaming for provider: ${provider}`);
      switch (provider) {
        case "openai":
          await this.streamOpenAI(message, updateContent, finalizeContent);
          break;
        case "anthropic":
          await this.streamAnthropic(message, updateContent, finalizeContent);
          break;
        case "google":
          console.log("Google streaming disabled, forcing fallback to regular API");
          throw new Error("Google streaming temporarily disabled");
        case "ollama":
          await this.streamOllama(message, updateContent, finalizeContent);
          break;
        case "lmstudio":
          await this.streamLMStudio(message, updateContent, finalizeContent);
          break;
        case "custom":
          await this.streamCustomAPI(message, updateContent, finalizeContent);
          break;
        default:
          throw new Error(`Unsupported provider: ${provider}`);
      }
    } catch (error) {
      console.error(`Streaming failed for ${provider}, falling back to regular API:`, error);
      if (!streamingSucceeded) {
        try {
          const response = await this.callLLM(message);
          const messageEl = contentEl.closest(".stella-message");
          if (messageEl) {
            messageEl.removeClass("stella-message-temp");
          }
          contentEl.innerHTML = "";
          await this.renderMarkdown(contentEl, response);
          this.chatHistory.push({
            role: "assistant",
            content: response,
            timestamp: Date.now()
          });
          if (this.currentConversationId) {
            this.saveCurrentConversation();
          }
          console.log(`Fallback API call succeeded for ${provider}`);
        } catch (fallbackError) {
          console.error(`Both streaming and fallback failed for ${provider}:`, fallbackError);
          throw fallbackError;
        }
      }
    }
  }
  async callLLM(message) {
    const { provider } = this.plugin.settings;
    switch (provider) {
      case "openai":
        return this.callOpenAI(message);
      case "anthropic":
        return this.callAnthropic(message);
      case "google":
        return this.callGoogle(message);
      case "ollama":
        return this.callOllama(message);
      case "lmstudio":
        return this.callLMStudio(message);
      case "custom":
        return this.callCustomAPI(message);
      default:
        throw new Error(`Unsupported provider: ${provider}`);
    }
  }
  async callOpenAI(message) {
    if (!this.plugin.settings.openaiApiKey) {
      throw new Error("Please set your OpenAI API key in settings");
    }
    const messages = [];
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      messages.push({ role: "system", content: this.buildSystemMessage() });
      console.log("OpenAI: Including system message in request");
    }
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        messages,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  async streamOpenAI(message, updateContent, finalizeContent) {
    var _a, _b, _c;
    if (!this.plugin.settings.openaiApiKey) {
      throw new Error("Please set your OpenAI API key in settings");
    }
    const messages = [];
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      messages.push({ role: "system", content: this.buildSystemMessage() });
    }
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        messages,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature,
        stream: true
      })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`OpenAI API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6).trim();
            if (data === "[DONE]") {
              await finalizeContent();
              return;
            }
            try {
              const parsed = JSON.parse(data);
              const content = (_c = (_b = (_a = parsed.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content;
              if (content) {
                updateContent(content);
              }
            } catch (e) {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    await finalizeContent();
  }
  async callAnthropic(message) {
    if (!this.plugin.settings.anthropicApiKey) {
      throw new Error("Please set your Anthropic API key in settings");
    }
    const messages = [];
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.plugin.settings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature,
        messages,
        ...(this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) && {
          system: this.buildSystemMessage()
        }
      })
    });
    if (!response.ok) {
      throw new Error(`Anthropic API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.content[0].text;
  }
  async streamAnthropic(message, updateContent, finalizeContent) {
    var _a;
    if (!this.plugin.settings.anthropicApiKey) {
      throw new Error("Please set your Anthropic API key in settings");
    }
    const messages = [];
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const requestBody = {
      model: this.plugin.settings.model,
      max_tokens: this.plugin.settings.maxTokens,
      temperature: this.plugin.settings.temperature,
      messages,
      stream: true
    };
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      requestBody.system = this.buildSystemMessage();
    }
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.plugin.settings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Anthropic API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6).trim();
            if (data === "[DONE]") {
              await finalizeContent();
              return;
            }
            try {
              const parsed = JSON.parse(data);
              if (parsed.type === "content_block_delta") {
                const content = (_a = parsed.delta) == null ? void 0 : _a.text;
                if (content) {
                  updateContent(content);
                }
              }
            } catch (e) {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    await finalizeContent();
  }
  async callGoogle(message, retryCount = 0) {
    var _a, _b, _c;
    if (!this.plugin.settings.googleApiKey) {
      throw new Error("Please set your Google API key in settings");
    }
    const contents = [];
    for (const msg of this.chatHistory) {
      contents.push({
        role: msg.role === "assistant" ? "model" : "user",
        parts: [{ text: msg.content }]
      });
    }
    contents.push({
      role: "user",
      parts: [{ text: message }]
    });
    if (this.currentSystemPrompt) {
      console.log("Google: Including system prompt in request");
    } else {
      console.log("Google: No system prompt to include");
    }
    const requestBody = {
      contents,
      systemInstruction: this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0 ? {
        parts: [{ text: this.buildSystemMessage() }]
      } : void 0,
      generationConfig: {
        temperature: this.plugin.settings.temperature,
        maxOutputTokens: this.plugin.settings.maxTokens
      }
    };
    if (this.activeMCPServers && this.activeMCPServers.length > 0) {
      const functionDeclarations = [];
      for (const server of this.activeMCPServers) {
        console.log(`Adding tools from MCP server (non-streaming): ${server.name}`, server);
        const tools = server.tools || [];
        for (const tool of tools) {
          let cleanedSchema = tool.inputSchema || {
            type: "object",
            properties: {},
            required: []
          };
          if (cleanedSchema && typeof cleanedSchema === "object") {
            const { $schema, additionalProperties, ...googleCompatibleSchema } = cleanedSchema;
            cleanedSchema = googleCompatibleSchema;
          }
          const functionDecl = {
            name: `${server.name}_${tool.name}`,
            description: tool.description || `Execute ${tool.name} from ${server.name}`,
            parameters: cleanedSchema
          };
          console.log(`Adding function declaration (non-streaming):`, functionDecl);
          functionDeclarations.push(functionDecl);
        }
      }
      if (functionDeclarations.length > 0) {
        requestBody.tools = [{
          functionDeclarations
        }];
        console.log(`Google API non-streaming request with ${functionDeclarations.length} MCP tools:`, requestBody.tools);
      }
    }
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.plugin.settings.model}:generateContent?key=${this.plugin.settings.googleApiKey}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error("Google API error details:", {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      if (response.status === 503 && retryCount < 2) {
        console.log(`Retrying Google API call (attempt ${retryCount + 1})...`);
        await new Promise((resolve) => setTimeout(resolve, 1e3 * (retryCount + 1)));
        return this.callGoogle(message, retryCount + 1);
      }
      throw new Error(`Google API error (${response.status}): ${response.statusText}. ${errorText || "Service temporarily unavailable"}`);
    }
    const data = await response.json();
    console.log("Google API non-streaming response:", data);
    const candidate = (_a = data == null ? void 0 : data.candidates) == null ? void 0 : _a[0];
    if (!candidate) {
      throw new Error("No candidate in Google API response");
    }
    const functionCall = (_c = (_b = candidate.content) == null ? void 0 : _b.parts) == null ? void 0 : _c.find((part) => part.functionCall);
    if (functionCall && functionCall.functionCall) {
      console.log("Found function call in non-streaming response:", functionCall.functionCall);
      try {
        const functionName = functionCall.functionCall.name;
        const functionArgs = functionCall.functionCall.args || {};
        if (!functionName) {
          throw new Error("Function call missing name");
        }
        const result = await this.executeMCPTool(functionName, functionArgs);
        console.log("MCP tool execution result (non-streaming):", result);
        const followUpContents = [...contents];
        followUpContents.push({
          role: "function",
          parts: [{
            functionResponse: {
              name: functionCall.functionCall.name,
              response: result
            }
          }]
        });
        const followUpResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.plugin.settings.model}:generateContent?key=${this.plugin.settings.googleApiKey}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            ...requestBody,
            contents: followUpContents
          })
        });
        if (followUpResponse.ok) {
          const followUpData = await followUpResponse.json();
          return followUpData.candidates[0].content.parts[0].text;
        }
      } catch (error) {
        console.error("MCP tool execution failed (non-streaming):", error);
        return `Error executing tool ${functionCall.functionCall.name}: ${error.message}`;
      }
    }
    return candidate.content.parts[0].text;
  }
  async streamGoogle(message, updateContent, finalizeContent) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    if (!this.plugin.settings.googleApiKey) {
      throw new Error("Please set your Google API key in settings");
    }
    console.log("Starting Google streaming...");
    const contents = [];
    let systemInstruction = null;
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      systemInstruction = { parts: [{ text: this.buildSystemMessage() }] };
      console.log("Google: Including system instruction");
    }
    this.chatHistory.forEach((msg) => {
      contents.push({
        role: msg.role === "user" ? "user" : "model",
        parts: [{ text: msg.content }]
      });
    });
    contents.push({
      role: "user",
      parts: [{ text: message }]
    });
    const requestBody = {
      contents,
      generationConfig: {
        temperature: this.plugin.settings.temperature,
        maxOutputTokens: this.plugin.settings.maxTokens
      }
    };
    if (this.activeMCPServers && this.activeMCPServers.length > 0) {
      const functionDeclarations = [];
      for (const server of this.activeMCPServers) {
        console.log(`Adding tools from MCP server: ${server.name}`, server);
        const tools = server.tools || [];
        for (const tool of tools) {
          let cleanedSchema = tool.inputSchema || {
            type: "object",
            properties: {},
            required: []
          };
          if (cleanedSchema && typeof cleanedSchema === "object") {
            const { $schema, additionalProperties, ...googleCompatibleSchema } = cleanedSchema;
            cleanedSchema = googleCompatibleSchema;
          }
          const functionDecl = {
            name: `${server.name}_${tool.name}`,
            description: tool.description || `Execute ${tool.name} from ${server.name}`,
            parameters: cleanedSchema
          };
          console.log(`Adding function declaration:`, functionDecl);
          functionDeclarations.push(functionDecl);
        }
      }
      if (functionDeclarations.length > 0) {
        requestBody.tools = [{
          functionDeclarations
        }];
        console.log(`Google API request with ${functionDeclarations.length} MCP tools:`, requestBody.tools);
      } else {
        console.log("No MCP tools available to add to Google function declarations");
      }
    } else {
      console.log("No active MCP servers for Google function calling");
    }
    if (systemInstruction) {
      requestBody.systemInstruction = systemInstruction;
    }
    console.log("Google request body:", requestBody);
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.plugin.settings.model}:streamGenerateContent?key=${this.plugin.settings.googleApiKey}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const error = await response.text();
      console.error("Google API error response:", error);
      throw new Error(`Google API error: ${error}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.trim() === "")
            continue;
          try {
            let jsonLine = line.trim();
            if (jsonLine.startsWith("data: ")) {
              jsonLine = jsonLine.slice(6).trim();
            }
            if (jsonLine === "[" || jsonLine === "]" || jsonLine === "") {
              continue;
            }
            if (jsonLine.endsWith(",")) {
              jsonLine = jsonLine.slice(0, -1);
            }
            const parsed = JSON.parse(jsonLine);
            console.log("Google streaming chunk:", parsed);
            const candidates = Array.isArray(parsed) ? parsed : [parsed];
            for (const item of candidates) {
              console.log("Processing Google streaming item:", item);
              const functionCall = (_e = (_d = (_c = (_b = (_a = item.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.functionCall;
              if (functionCall) {
                console.log("Found function call from Google:", functionCall);
                const mcpStatusEl = document.querySelector(".stella-mcp-status-floating");
                if (mcpStatusEl) {
                  mcpStatusEl.style.display = "block";
                  mcpStatusEl.textContent = `Executing: ${functionCall.name}`;
                }
                try {
                  const functionName = functionCall == null ? void 0 : functionCall.name;
                  const functionArgs = (functionCall == null ? void 0 : functionCall.args) || {};
                  if (!functionName) {
                    throw new Error("Function call missing name in streaming response");
                  }
                  console.log(`Executing MCP tool: ${functionName} with args:`, functionArgs);
                  const result = await this.executeMCPTool(functionName, functionArgs);
                  console.log("MCP tool execution result:", result);
                  contents.push({
                    role: "function",
                    parts: [{
                      functionResponse: {
                        name: functionCall.name,
                        response: result
                      }
                    }]
                  });
                  if (mcpStatusEl) {
                    mcpStatusEl.textContent = `Completed: ${functionCall.name}`;
                  }
                } catch (error) {
                  console.error("MCP tool execution error:", error);
                  if (mcpStatusEl) {
                    mcpStatusEl.textContent = `Error: ${functionCall.name}`;
                  }
                }
              }
              const content = (_j = (_i = (_h = (_g = (_f = item.candidates) == null ? void 0 : _f[0]) == null ? void 0 : _g.content) == null ? void 0 : _h.parts) == null ? void 0 : _i[0]) == null ? void 0 : _j.text;
              if (content) {
                updateContent(content);
              }
            }
          } catch (e) {
            console.log("Failed to parse Google streaming chunk:", line, e);
          }
        }
      }
      if (buffer.trim()) {
        try {
          const parsed = JSON.parse(buffer);
          const content = (_o = (_n = (_m = (_l = (_k = parsed.candidates) == null ? void 0 : _k[0]) == null ? void 0 : _l.content) == null ? void 0 : _m.parts) == null ? void 0 : _n[0]) == null ? void 0 : _o.text;
          if (content) {
            updateContent(content);
          }
        } catch (e) {
          console.log("Failed to parse final Google buffer:", buffer, e);
        }
      }
    } finally {
      reader.releaseLock();
    }
    await finalizeContent();
    console.log("Google streaming completed");
  }
  async callOllama(message) {
    let prompt = "";
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      prompt += this.buildSystemMessage() + "\n\n";
    }
    this.chatHistory.forEach((msg) => {
      const role = msg.role === "user" ? "User" : "Assistant";
      prompt += `${role}: ${msg.content}
`;
    });
    prompt += `User: ${message}
Assistant:`;
    const response = await fetch(`${this.plugin.settings.ollamaBaseUrl}/api/generate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        prompt,
        stream: false,
        options: {
          temperature: this.plugin.settings.temperature,
          num_predict: this.plugin.settings.maxTokens
        }
      })
    });
    if (!response.ok) {
      throw new Error(`Ollama API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.response;
  }
  async callLMStudio(message) {
    const messages = [];
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      messages.push({ role: "system", content: this.buildSystemMessage() });
    }
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const response = await fetch(`${this.plugin.settings.lmStudioBaseUrl}/v1/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.plugin.settings.model,
        messages,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`LM Studio API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  async callCustomAPI(message) {
    if (!this.plugin.settings.customApiUrl) {
      throw new Error("Please set your custom API URL in settings");
    }
    const messages = [];
    if (this.currentSystemPrompt || this.currentMentalModel || this.contextNotes.length > 0) {
      messages.push({ role: "system", content: this.buildSystemMessage() });
    }
    this.chatHistory.forEach((msg) => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    messages.push({ role: "user", content: message });
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.plugin.settings.customApiKey) {
      headers["Authorization"] = `Bearer ${this.plugin.settings.customApiKey}`;
    }
    const response = await fetch(this.plugin.settings.customApiUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({
        model: this.plugin.settings.model,
        messages,
        max_tokens: this.plugin.settings.maxTokens,
        temperature: this.plugin.settings.temperature
      })
    });
    if (!response.ok) {
      throw new Error(`Custom API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  // Streaming methods for providers without native streaming support
  async streamOllama(message, updateContent, finalizeContent) {
    const response = await this.callOllama(message);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      updateContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await finalizeContent();
  }
  async streamLMStudio(message, updateContent, finalizeContent) {
    const response = await this.callLMStudio(message);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      updateContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await finalizeContent();
  }
  async streamCustomAPI(message, updateContent, finalizeContent) {
    const response = await this.callCustomAPI(message);
    const words = response.split(" ");
    for (let i = 0; i < words.length; i++) {
      const chunk = i === 0 ? words[i] : " " + words[i];
      updateContent(chunk);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    await finalizeContent();
  }
  // Fetch available models from each provider with caching
  async fetchAvailableModels() {
    const { provider } = this.plugin.settings;
    const cacheKey = CacheManager.modelListKey(provider);
    const cachedModels = this.plugin.cache.get(cacheKey);
    if (cachedModels) {
      this.logger.log(`Using cached models for ${provider}: ${cachedModels.length} models`);
      return cachedModels;
    }
    try {
      let models = [];
      switch (provider) {
        case "openai":
          models = await this.fetchOpenAIModels();
          break;
        case "anthropic":
          models = await this.fetchAnthropicModels();
          break;
        case "google":
          models = await this.fetchGoogleModels();
          break;
        case "ollama":
          models = await this.fetchOllamaModels();
          break;
        case "lmstudio":
          models = await this.fetchLMStudioModels();
          break;
        default:
          return [];
      }
      if (models.length > 0) {
        this.plugin.cache.set(cacheKey, models, 18e5);
        this.logger.log(`Cached ${models.length} models for ${provider}`);
      }
      return models;
    } catch (error) {
      this.logger.error(`Failed to fetch models for ${provider}:`, error);
      return [];
    }
  }
  async fetchOpenAIModels() {
    if (!this.plugin.settings.openaiApiKey)
      return [];
    const response = await FetchManager.enhancedFetch("https://api.openai.com/v1/models", {
      headers: {
        "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`
      }
    });
    if (!response.ok)
      return [];
    const data = await response.json();
    return data.data.filter((model) => model.id.includes("gpt")).map((model) => model.id).sort();
  }
  async fetchAnthropicModels() {
    if (!this.plugin.settings.anthropicApiKey)
      return [];
    try {
      const response = await FetchManager.enhancedFetch("https://api.anthropic.com/v1/models", {
        headers: {
          "x-api-key": this.plugin.settings.anthropicApiKey,
          "anthropic-version": "2023-06-01"
        }
      });
      if (!response.ok) {
        console.error("Anthropic API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("Anthropic API response:", data);
      if (!data.data)
        return [];
      return data.data.map((model) => model.id).sort();
    } catch (error) {
      console.error("Error fetching Anthropic models:", error);
      return [];
    }
  }
  async fetchGoogleModels() {
    if (!this.plugin.settings.googleApiKey)
      return [];
    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${this.plugin.settings.googleApiKey}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        console.error("Google API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("Google API response:", data);
      if (!data.models)
        return [];
      return data.models.filter((model) => {
        var _a;
        return (_a = model.supportedGenerationMethods) == null ? void 0 : _a.includes("generateContent");
      }).map((model) => {
        return model.name.replace("models/", "");
      }).sort();
    } catch (error) {
      console.error("Error fetching Google models:", error);
      return [];
    }
  }
  async fetchOllamaModels() {
    try {
      const response = await fetch(`${this.plugin.settings.ollamaBaseUrl}/api/tags`);
      if (!response.ok)
        return [];
      const data = await response.json();
      return data.models.map((model) => model.name);
    } catch (e) {
      return [];
    }
  }
  async fetchLMStudioModels() {
    try {
      const response = await fetch(`${this.plugin.settings.lmStudioBaseUrl}/v1/models`);
      if (!response.ok)
        return [];
      const data = await response.json();
      return data.data.map((model) => model.id);
    } catch (e) {
      return [];
    }
  }
  loadConversation(conversationId) {
    this.saveCurrentConversation();
    const conversation = this.plugin.settings.conversations.find((c) => c.id === conversationId);
    if (!conversation)
      return;
    this.currentConversationId = conversationId;
    this.plugin.settings.currentConversationId = conversationId;
    this.plugin.saveSettings();
    this.chatHistory = [...conversation.messages];
    this.conversationNameInput.value = conversation.title;
    this.currentSystemPrompt = conversation.systemPrompt || null;
    this.currentSystemPromptFilename = conversation.systemPromptFilename || null;
    this.currentMentalModel = conversation.mentalModel || null;
    this.currentMentalModelFilename = conversation.mentalModelFilename || null;
    this.messagesContainer.empty();
    this.initializeMessagePagination(conversation.messages);
    this.updateSystemPromptIndicator();
    this.updateMentalModelIndicator();
  }
  loadConversations() {
    const currentId = this.plugin.settings.currentConversationId;
    if (currentId) {
      this.loadConversation(currentId);
    } else {
      const now = new Date();
      const localDateStr = now.toLocaleDateString("en-CA");
      const dateTitle = localDateStr;
      this.conversationNameInput.value = dateTitle;
    }
  }
  initializeMessagePagination(messages) {
    if (!messages || messages.length === 0)
      return;
    this.totalMessagePages = Math.ceil(messages.length / this.messagePageSize);
    this.currentMessagePage = messages.length > this.messagePageSize ? this.totalMessagePages - 1 : 0;
    this.renderMessagePage(messages);
    if (this.totalMessagePages > 1) {
      this.setupInfiniteScrolling(messages);
    }
  }
  renderMessagePage(allMessages) {
    const startIndex = this.currentMessagePage * this.messagePageSize;
    const endIndex = Math.min(startIndex + this.messagePageSize, allMessages.length);
    const pageMessages = allMessages.slice(startIndex, endIndex);
    if (this.currentMessagePage > 0 && !this.messagesContainer.querySelector(".stella-load-older-messages")) {
      const loadOlderBtn = this.messagesContainer.createDiv({
        cls: "stella-load-older-messages",
        text: `Load ${Math.min(this.messagePageSize, startIndex)} older messages...`
      });
      loadOlderBtn.addEventListener("click", () => {
        if (!this.isLoadingMoreMessages) {
          this.loadOlderMessages(allMessages);
        }
      });
    }
    pageMessages.forEach((msg) => {
      this.addMessageToUI(msg.content, msg.role);
    });
    if (this.currentMessagePage === this.totalMessagePages - 1) {
      setTimeout(() => {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      }, 100);
    }
  }
  async loadOlderMessages(allMessages) {
    if (this.isLoadingMoreMessages || this.currentMessagePage <= 0)
      return;
    this.isLoadingMoreMessages = true;
    const loadBtn = this.messagesContainer.querySelector(".stella-load-older-messages");
    if (loadBtn) {
      loadBtn.textContent = "Loading older messages...";
      loadBtn.classList.add("loading");
    }
    await new Promise((resolve) => setTimeout(resolve, 300));
    const scrollHeight = this.messagesContainer.scrollHeight;
    const scrollTop = this.messagesContainer.scrollTop;
    this.currentMessagePage--;
    const startIndex = this.currentMessagePage * this.messagePageSize;
    const endIndex = startIndex + this.messagePageSize;
    const olderMessages = allMessages.slice(startIndex, endIndex);
    if (loadBtn) {
      loadBtn.remove();
    }
    const tempContainer = document.createElement("div");
    olderMessages.forEach((msg) => {
      const messageEl = document.createElement("div");
      messageEl.className = `stella-message stella-message-${msg.role}`;
      const contentEl = document.createElement("div");
      contentEl.className = "stella-message-content";
      contentEl.textContent = msg.content;
      messageEl.appendChild(contentEl);
      tempContainer.appendChild(messageEl);
    });
    if (this.currentMessagePage > 0) {
      const newLoadBtn = document.createElement("div");
      newLoadBtn.className = "stella-load-older-messages";
      newLoadBtn.textContent = `Load ${Math.min(this.messagePageSize, startIndex)} older messages...`;
      newLoadBtn.addEventListener("click", () => {
        if (!this.isLoadingMoreMessages) {
          this.loadOlderMessages(allMessages);
        }
      });
      tempContainer.insertBefore(newLoadBtn, tempContainer.firstChild);
    }
    while (tempContainer.firstChild) {
      this.messagesContainer.insertBefore(tempContainer.firstChild, this.messagesContainer.firstChild);
    }
    const newScrollHeight = this.messagesContainer.scrollHeight;
    const scrollDiff = newScrollHeight - scrollHeight;
    this.messagesContainer.scrollTop = scrollTop + scrollDiff;
    this.isLoadingMoreMessages = false;
  }
  setupInfiniteScrolling(allMessages) {
    let scrollTimeout;
    this.messagesContainer.addEventListener("scroll", () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        const scrollTop = this.messagesContainer.scrollTop;
        if (scrollTop < 100 && this.currentMessagePage > 0 && !this.isLoadingMoreMessages) {
          this.loadOlderMessages(allMessages);
        }
      }, 150);
    });
  }
  switchConversation(conversationId) {
    if (conversationId === "new") {
      this.startNewConversation();
    }
  }
  async deleteCurrentConversationAndStartNew() {
    if (this.currentConversationId) {
      await this.deleteConversation(this.currentConversationId);
    } else {
      this.startNewConversation();
    }
  }
  startNewConversation() {
    if (this.currentConversationId) {
      this.saveCurrentConversation();
    }
    const now = new Date();
    const localDateStr = now.toLocaleDateString("en-CA");
    const dateTitle = localDateStr;
    const newConversation = {
      id: `conv_${Date.now()}`,
      title: dateTitle,
      messages: [],
      createdAt: now.getTime(),
      updatedAt: now.getTime()
    };
    this.plugin.settings.conversations.unshift(newConversation);
    this.plugin.settings.currentConversationId = newConversation.id;
    this.currentConversationId = newConversation.id;
    this.plugin.saveSettings();
    this.messagesContainer.empty();
    this.chatHistory = [];
    this.currentSystemPrompt = null;
    this.currentSystemPromptFilename = null;
    this.currentMentalModel = null;
    this.currentMentalModelFilename = null;
    this.conversationNameInput.value = dateTitle;
  }
  saveConversationName() {
    if (!this.currentConversationId)
      return;
    const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
    if (conversation) {
      conversation.title = this.conversationNameInput.value;
      conversation.updatedAt = Date.now();
      this.plugin.saveSettings();
    }
  }
  saveCurrentConversation() {
    if (!this.currentConversationId)
      return;
    const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
    if (conversation) {
      conversation.messages = [...this.chatHistory];
      conversation.updatedAt = Date.now();
      this.plugin.saveSettings();
      this.updateConversationMetadataCache();
    }
  }
  updateConversationMetadataCache() {
    const metadata = this.plugin.settings.conversations.map((conv) => ({
      id: conv.id,
      title: conv.title,
      messageCount: conv.messages.length,
      createdAt: conv.createdAt,
      updatedAt: conv.updatedAt,
      hasSystemPrompt: !!conv.systemPrompt,
      hasMentalModel: !!conv.mentalModel
    }));
    this.plugin.cache.set(CacheManager.conversationMetaKey(), metadata, 3e5);
    this.logger.log(`Updated conversation metadata cache: ${metadata.length} conversations`);
  }
  async deleteConversation(conversationId) {
    this.plugin.settings.conversations = this.plugin.settings.conversations.filter(
      (conv) => conv.id !== conversationId
    );
    if (this.currentConversationId === conversationId) {
      this.startNewConversation();
    }
    await this.plugin.saveSettings();
    this.plugin.cache.invalidateConversationData();
  }
  showChatHistory() {
    this.saveCurrentConversation();
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Conversations");
    modal.modalEl.style.width = "400px";
    modal.modalEl.style.height = "60vh";
    modal.modalEl.style.minWidth = "400px";
    const contentEl = modal.contentEl;
    contentEl.empty();
    if (this.plugin.settings.conversations.length === 0) {
      contentEl.createEl("p", {
        text: "No conversations yet. Start chatting to create your first conversation."
      });
    } else {
      const mainContainer = contentEl.createDiv({ cls: "stella-modal-container" });
      const leftPanel = mainContainer.createDiv({ cls: "stella-modal-left-panel" });
      const rightPanel = mainContainer.createDiv({ cls: "stella-modal-right-panel" });
      const previewContainer = rightPanel.createDiv({ cls: "stella-preview-container" });
      const previewContent = previewContainer.createDiv({ cls: "stella-preview-content" });
      previewContent.textContent = "Select a conversation and press \u2192 to preview";
      const ITEMS_PER_PAGE = 20;
      let currentPage = 0;
      const totalConversations = this.plugin.settings.conversations.length;
      const totalPages = Math.ceil(totalConversations / ITEMS_PER_PAGE);
      const headerContainer = leftPanel.createDiv({ cls: "stella-pagination-header" });
      if (totalPages > 1) {
        const pageInfo = headerContainer.createDiv({
          cls: "stella-page-info",
          text: `Page ${currentPage + 1} of ${totalPages} (${totalConversations} conversations)`
        });
        const paginationControls = headerContainer.createDiv({ cls: "stella-pagination-controls" });
        const prevBtn = paginationControls.createEl("button", {
          cls: "stella-pagination-btn",
          text: "\u2190 Prev"
        });
        const nextBtn = paginationControls.createEl("button", {
          cls: "stella-pagination-btn",
          text: "Next \u2192"
        });
      }
      const conversationsContainer = leftPanel.createDiv({ cls: "stella-conversations-container" });
      let selectedIndex = 0;
      let previewVisible = false;
      const fixConversationsHeight = () => {
        setTimeout(() => {
          const modalHeight = modal.modalEl.clientHeight;
          const titleHeight = modal.titleEl.offsetHeight;
          const headerHeight = headerContainer.offsetHeight || 0;
          const padding = 40;
          const availableHeight = modalHeight - titleHeight - headerHeight - padding;
          conversationsContainer.style.height = `${availableHeight}px`;
          conversationsContainer.style.maxHeight = `${availableHeight}px`;
          conversationsContainer.style.overflow = "auto";
        }, 50);
      };
      const renderConversationPage = () => {
        conversationsContainer.empty();
        const startIndex = currentPage * ITEMS_PER_PAGE;
        const endIndex = Math.min(startIndex + ITEMS_PER_PAGE, totalConversations);
        const pageConversations = this.plugin.settings.conversations.slice(startIndex, endIndex);
        pageConversations.forEach((conversation, relativeIndex) => {
          const convEl = conversationsContainer.createDiv({
            cls: "stella-conversation-item"
          });
          if (conversation.id === this.currentConversationId) {
            convEl.classList.add("stella-conversation-current");
          }
          if (relativeIndex === selectedIndex) {
            convEl.classList.add("selected");
          }
          const titleEl = convEl.createDiv({ cls: "stella-conversation-title" });
          titleEl.textContent = conversation.title;
          const metaEl = convEl.createDiv({ cls: "stella-conversation-meta" });
          const messageCount = conversation.messages.length;
          const lastUpdate = new Date(conversation.updatedAt).toLocaleDateString();
          metaEl.textContent = `${messageCount} messages \u2022 Last updated ${lastUpdate}`;
          const deleteBtn = convEl.createEl("div", {
            cls: "stella-conversation-delete",
            attr: { title: "Delete conversation" }
          });
          deleteBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3,6 5,6 21,6"></polyline><path d="M8,6V4c0-1,1-2,2-2h4c0,0,1,1,2,2v2M10,11v6M14,11v6"></path><path d="M5,6l1,14c0,1,1,2,2,2h8c1,0,2-1,2-2l1-14"></path></svg>';
          deleteBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            await this.deleteConversation(conversation.id);
            modal.close();
            setTimeout(() => this.showChatHistory(), 100);
          });
          convEl.addEventListener("click", (e) => {
            if (!e.target.closest(".stella-conversation-delete")) {
              this.loadConversation(conversation.id);
              modal.close();
            }
          });
        });
        fixConversationsHeight();
        if (totalPages > 1) {
          const prevBtn = headerContainer.querySelector(".stella-pagination-btn:first-of-type");
          const nextBtn = headerContainer.querySelector(".stella-pagination-btn:last-of-type");
          const pageInfo = headerContainer.querySelector(".stella-page-info");
          if (prevBtn && nextBtn && pageInfo) {
            prevBtn.disabled = currentPage === 0;
            nextBtn.disabled = currentPage === totalPages - 1;
            pageInfo.textContent = `Page ${currentPage + 1} of ${totalPages} (${totalConversations} conversations)`;
            prevBtn.replaceWith(prevBtn.cloneNode(true));
            nextBtn.replaceWith(nextBtn.cloneNode(true));
            const newPrevBtn = headerContainer.querySelector(".stella-pagination-btn:first-of-type");
            const newNextBtn = headerContainer.querySelector(".stella-pagination-btn:last-of-type");
            newPrevBtn.addEventListener("click", () => {
              if (currentPage > 0) {
                currentPage--;
                selectedIndex = 0;
                renderConversationPage();
              }
            });
            newNextBtn.addEventListener("click", () => {
              if (currentPage < totalPages - 1) {
                currentPage++;
                selectedIndex = 0;
                renderConversationPage();
              }
            });
          }
        }
      };
      renderConversationPage();
      const showPreview = (conversation) => {
        try {
          previewContent.empty();
          const summaryDiv = previewContent.createDiv({ cls: "stella-conversation-summary" });
          const infoDiv = summaryDiv.createDiv({ cls: "stella-conversation-info" });
          infoDiv.innerHTML = `
                        <div><strong>Messages:</strong> ${conversation.messages.length}</div>
                        <div><strong>Created:</strong> ${new Date(conversation.createdAt).toLocaleString()}</div>
                        <div><strong>Updated:</strong> ${new Date(conversation.updatedAt).toLocaleString()}</div>
                    `;
          if (conversation.systemPrompt) {
            const sysPromptDiv = summaryDiv.createDiv({ cls: "stella-system-prompt-preview" });
            sysPromptDiv.createEl("h4", { text: "System Prompt:" });
            const promptContent = sysPromptDiv.createDiv({ cls: "stella-prompt-content" });
            promptContent.textContent = conversation.systemPrompt.substring(0, 200) + (conversation.systemPrompt.length > 200 ? "..." : "");
          }
          if (conversation.messages.length > 0) {
            const messagesDiv = summaryDiv.createDiv({ cls: "stella-messages-preview" });
            messagesDiv.createEl("h4", { text: "Messages Preview:" });
            conversation.messages.slice(0, 4).forEach((msg, index) => {
              const msgDiv = messagesDiv.createDiv({ cls: `stella-preview-message stella-preview-${msg.role}` });
              const roleSpan = msgDiv.createEl("span", { cls: "stella-preview-role" });
              roleSpan.textContent = msg.role === "user" ? "\u{1F464}" : "\u{1F916}";
              const contentDiv = msgDiv.createDiv({ cls: "stella-preview-content" });
              const truncated = msg.content.length > 150 ? msg.content.substring(0, 150) + "..." : msg.content;
              contentDiv.textContent = truncated;
            });
            if (conversation.messages.length > 4) {
              const moreDiv = messagesDiv.createDiv({ cls: "stella-preview-more" });
              moreDiv.textContent = `... and ${conversation.messages.length - 4} more messages`;
            }
          }
          rightPanel.style.display = "block";
          previewVisible = true;
          modal.modalEl.style.width = "60vw";
          modal.modalEl.style.maxWidth = "980px";
          leftPanel.style.width = "50%";
          rightPanel.style.width = "50%";
          fixConversationsHeight();
        } catch (error) {
          previewContent.textContent = `Error loading preview: ${error.message}`;
        }
      };
      const hidePreview = () => {
        rightPanel.style.display = "none";
        leftPanel.style.width = "100%";
        previewVisible = false;
        modal.modalEl.style.width = "400px";
        modal.modalEl.style.maxWidth = "none";
        fixConversationsHeight();
      };
      hidePreview();
      const handleKeydown = async (e) => {
        var _a, _b, _c, _d, _e, _f;
        const items = conversationsContainer.querySelectorAll(".stella-conversation-item");
        const startIndex = currentPage * ITEMS_PER_PAGE;
        const pageConversations = this.plugin.settings.conversations.slice(startIndex, startIndex + ITEMS_PER_PAGE);
        if (e.key === "ArrowDown") {
          e.preventDefault();
          (_a = items[selectedIndex]) == null ? void 0 : _a.classList.remove("selected");
          if (selectedIndex < items.length - 1) {
            selectedIndex++;
          } else if (currentPage < totalPages - 1) {
            currentPage++;
            selectedIndex = 0;
            renderConversationPage();
            return;
          }
          (_b = items[selectedIndex]) == null ? void 0 : _b.classList.add("selected");
          (_c = items[selectedIndex]) == null ? void 0 : _c.scrollIntoView({ behavior: "smooth", block: "nearest" });
          if (previewVisible && pageConversations[selectedIndex]) {
            showPreview(pageConversations[selectedIndex]);
          }
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          (_d = items[selectedIndex]) == null ? void 0 : _d.classList.remove("selected");
          if (selectedIndex > 0) {
            selectedIndex--;
          } else if (currentPage > 0) {
            currentPage--;
            selectedIndex = Math.min(ITEMS_PER_PAGE - 1, this.plugin.settings.conversations.slice(currentPage * ITEMS_PER_PAGE).length - 1);
            renderConversationPage();
            return;
          }
          (_e = items[selectedIndex]) == null ? void 0 : _e.classList.add("selected");
          (_f = items[selectedIndex]) == null ? void 0 : _f.scrollIntoView({ behavior: "smooth", block: "nearest" });
          if (previewVisible && pageConversations[selectedIndex]) {
            showPreview(pageConversations[selectedIndex]);
          }
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          if (!previewVisible && pageConversations[selectedIndex]) {
            showPreview(pageConversations[selectedIndex]);
          }
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          if (previewVisible) {
            hidePreview();
          }
        } else if (e.key === "Enter") {
          e.preventDefault();
          const selectedConversation = pageConversations[selectedIndex];
          if (selectedConversation) {
            this.loadConversation(selectedConversation.id);
            modal.close();
          }
        } else if (e.key === "Delete" || e.key === "Backspace") {
          e.preventDefault();
          const selectedConversation = pageConversations[selectedIndex];
          if (selectedConversation) {
            await this.deleteConversation(selectedConversation.id);
            modal.close();
            setTimeout(() => this.showChatHistory(), 100);
          }
        } else if (e.key === "PageDown" || e.key === "PageUp") {
          e.preventDefault();
          if (e.key === "PageDown" && currentPage < totalPages - 1) {
            currentPage++;
            selectedIndex = 0;
            renderConversationPage();
          } else if (e.key === "PageUp" && currentPage > 0) {
            currentPage--;
            selectedIndex = 0;
            renderConversationPage();
          }
        } else if (e.key === "Escape") {
          e.preventDefault();
          modal.close();
        }
      };
      modal.containerEl.setAttribute("tabindex", "0");
      modal.containerEl.addEventListener("keydown", handleKeydown);
      setTimeout(() => modal.containerEl.focus(), 100);
      fixConversationsHeight();
      const originalClose = modal.close.bind(modal);
      modal.close = () => {
        modal.containerEl.removeEventListener("keydown", handleKeydown);
        originalClose();
      };
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const closeBtn = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeBtn.onclick = () => modal.close();
    modal.open();
    if (this.plugin.settings.conversations.length === 0) {
      setTimeout(() => {
        const modalHeight = modal.modalEl.clientHeight;
        const titleHeight = modal.titleEl.offsetHeight;
        const buttonHeight = buttonContainer.offsetHeight + 16;
        const padding = 40;
        const availableHeight = modalHeight - titleHeight - buttonHeight - padding;
        const emptyStateP = contentEl.querySelector("p");
        if (emptyStateP) {
          emptyStateP.style.height = `${availableHeight}px`;
          emptyStateP.style.display = "flex";
          emptyStateP.style.alignItems = "center";
          emptyStateP.style.justifyContent = "center";
        }
      }, 50);
    }
  }
  async showSystemPromptSelector() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Select System Prompt");
    modal.modalEl.style.width = "400px";
    modal.modalEl.style.height = "60vh";
    modal.modalEl.style.minWidth = "400px";
    const contentEl = modal.contentEl;
    contentEl.empty();
    modal.open();
    try {
      let systemPromptsPath = this.plugin.settings.systemPromptsPath;
      const isAbsolutePath = systemPromptsPath.startsWith("/") || /^[A-Za-z]:[\\/]/.test(systemPromptsPath);
      console.log("Path check - Original:", systemPromptsPath, "Is absolute:", isAbsolutePath);
      if (systemPromptsPath && !isAbsolutePath) {
        console.log("Attempting to resolve vault-relative path:", systemPromptsPath);
        let vaultPath = null;
        const adapter = this.app.vault.adapter;
        if (adapter.path) {
          vaultPath = adapter.path;
        } else if (adapter.basePath) {
          vaultPath = adapter.basePath;
        } else if (adapter.getBasePath) {
          vaultPath = adapter.getBasePath();
        }
        console.log("Found vault path:", vaultPath, "type:", typeof vaultPath);
        if (vaultPath && typeof vaultPath === "string") {
          const path2 = require("path");
          systemPromptsPath = path2.join(vaultPath, systemPromptsPath);
          console.log("Resolved vault-relative path to:", systemPromptsPath);
        } else {
          console.log("Could not get vault path as string, trying vault name approach...");
          const vaultName = this.app.vault.getName();
          if (vaultName) {
            const path2 = require("path");
            const process2 = require("process");
            systemPromptsPath = path2.join(process2.cwd(), vaultName, systemPromptsPath);
            console.log("Fallback path resolution:", systemPromptsPath);
          }
        }
      }
      if (!systemPromptsPath) {
        contentEl.createEl("p", {
          text: "System prompts directory not configured. Please set it in plugin settings."
        });
        const settingsBtn = contentEl.createEl("button", {
          text: "Open Settings",
          cls: "mod-cta"
        });
        settingsBtn.onclick = () => {
          modal.close();
          this.openSettings();
        };
        return;
      }
      const fs = require("fs");
      const path = require("path");
      if (!fs.existsSync(systemPromptsPath)) {
        contentEl.createEl("p", {
          text: `System prompts directory not found: ${systemPromptsPath}`
        });
        contentEl.createEl("p", {
          text: "Please check the path in plugin settings."
        });
        return;
      }
      const files = fs.readdirSync(systemPromptsPath).filter((file) => file.endsWith(".md")).sort();
      if (files.length === 0) {
        contentEl.createEl("p", {
          text: "No .md files found in SystemPrompts directory."
        });
      } else {
        const mainContainer = contentEl.createDiv({ cls: "stella-modal-container" });
        const leftPanel = mainContainer.createDiv({ cls: "stella-modal-left-panel" });
        const rightPanel = mainContainer.createDiv({ cls: "stella-modal-right-panel" });
        const previewContainer = rightPanel.createDiv({ cls: "stella-preview-container" });
        const previewContent = previewContainer.createDiv({ cls: "stella-preview-content" });
        previewContent.textContent = "Select a system prompt and press \u2192 to preview";
        const fileList = leftPanel.createDiv({ cls: "stella-system-prompts-list" });
        let selectedIndex = 0;
        let previewVisible = false;
        const fixFileListHeight = () => {
          setTimeout(() => {
            const modalHeight = modal.modalEl.clientHeight;
            const titleHeight = modal.titleEl.offsetHeight;
            const padding = 40;
            const availableHeight = modalHeight - titleHeight - padding;
            fileList.style.height = `${availableHeight}px`;
            fileList.style.maxHeight = `${availableHeight}px`;
            fileList.style.overflow = "auto";
          }, 50);
        };
        files.forEach((filename, index) => {
          const fileItem = fileList.createDiv({
            cls: "stella-system-prompt-item"
          });
          const titleEl = fileItem.createDiv({ cls: "stella-system-prompt-title" });
          titleEl.textContent = filename.replace(".md", "");
          fileItem.addEventListener("click", async () => {
            await this.loadSystemPrompt(path.join(systemPromptsPath, filename));
            modal.close();
            setTimeout(() => {
              this.chatInput.focus();
            }, 100);
          });
          if (index === 0) {
            fileItem.classList.add("selected");
          }
        });
        const showPreview = async (filename) => {
          try {
            const fs2 = require("fs");
            const filePath = path.join(systemPromptsPath, filename);
            const content = fs2.readFileSync(filePath, "utf8");
            previewContent.empty();
            await this.renderMarkdown(previewContent, content);
            rightPanel.style.display = "block";
            previewVisible = true;
            modal.modalEl.style.width = "60vw";
            modal.modalEl.style.maxWidth = "980px";
            leftPanel.style.width = "50%";
            rightPanel.style.width = "50%";
            fixFileListHeight();
          } catch (error) {
            previewContent.textContent = `Error loading preview: ${error.message}`;
          }
        };
        const hidePreview = () => {
          rightPanel.style.display = "none";
          leftPanel.style.width = "100%";
          previewVisible = false;
          modal.modalEl.style.width = "400px";
          modal.modalEl.style.maxWidth = "none";
          fixFileListHeight();
        };
        const handleKeydown = (e) => {
          var _a, _b, _c, _d, _e, _f;
          const items = fileList.querySelectorAll(".stella-system-prompt-item");
          if (e.key === "ArrowDown") {
            e.preventDefault();
            (_a = items[selectedIndex]) == null ? void 0 : _a.classList.remove("selected");
            selectedIndex = (selectedIndex + 1) % items.length;
            (_b = items[selectedIndex]) == null ? void 0 : _b.classList.add("selected");
            (_c = items[selectedIndex]) == null ? void 0 : _c.scrollIntoView({ behavior: "smooth", block: "nearest" });
            if (previewVisible) {
              showPreview(files[selectedIndex]);
            }
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            (_d = items[selectedIndex]) == null ? void 0 : _d.classList.remove("selected");
            selectedIndex = selectedIndex === 0 ? items.length - 1 : selectedIndex - 1;
            (_e = items[selectedIndex]) == null ? void 0 : _e.classList.add("selected");
            (_f = items[selectedIndex]) == null ? void 0 : _f.scrollIntoView({ behavior: "smooth", block: "nearest" });
            if (previewVisible) {
              showPreview(files[selectedIndex]);
            }
          } else if (e.key === "ArrowRight") {
            e.preventDefault();
            if (!previewVisible) {
              showPreview(files[selectedIndex]);
            }
          } else if (e.key === "ArrowLeft") {
            e.preventDefault();
            if (previewVisible) {
              hidePreview();
            }
          } else if (e.key === "Enter") {
            e.preventDefault();
            const selectedFilename = files[selectedIndex];
            if (selectedFilename) {
              this.loadSystemPrompt(path.join(systemPromptsPath, selectedFilename));
              modal.close();
              setTimeout(() => {
                this.chatInput.focus();
              }, 100);
            }
          } else if (e.key === "Escape") {
            e.preventDefault();
            modal.close();
          }
        };
        hidePreview();
        modal.containerEl.setAttribute("tabindex", "0");
        modal.containerEl.addEventListener("keydown", handleKeydown);
        setTimeout(() => modal.containerEl.focus(), 100);
        fixFileListHeight();
        const originalClose = modal.close.bind(modal);
        modal.close = () => {
          modal.containerEl.removeEventListener("keydown", handleKeydown);
          originalClose();
        };
      }
    } catch (error) {
      contentEl.createEl("p", {
        text: `Error reading system prompts: ${error.message}`
      });
      console.error("Error reading system prompts:", error);
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const closeBtn = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeBtn.onclick = () => {
      modal.close();
      setTimeout(() => {
        this.chatInput.focus();
      }, 100);
    };
    modal.onClose = () => {
      setTimeout(() => {
        this.chatInput.focus();
      }, 100);
    };
  }
  async loadSystemPrompt(filepath) {
    try {
      const fs = require("fs");
      const path = require("path");
      const content = fs.readFileSync(filepath, "utf8");
      const filename = path.basename(filepath, path.extname(filepath));
      this.currentSystemPrompt = content;
      this.currentSystemPromptFilename = filename;
      console.log("System prompt loaded:", filename);
      if (this.currentConversationId) {
        const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
        if (conversation) {
          conversation.systemPrompt = content;
          conversation.systemPromptFilename = filename;
          conversation.updatedAt = Date.now();
          this.plugin.saveSettings();
          console.log("System prompt saved to conversation:", filename);
        }
      }
      this.updateSystemPromptIndicator();
    } catch (error) {
      this.addMessage(`Error loading system prompt: ${error.message}`, "error");
    }
  }
  unloadSystemPrompt() {
    this.currentSystemPrompt = null;
    this.currentSystemPromptFilename = null;
    console.log("System prompt unloaded");
    if (this.currentConversationId) {
      const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
      if (conversation) {
        conversation.systemPrompt = void 0;
        conversation.systemPromptFilename = void 0;
        conversation.updatedAt = Date.now();
        this.plugin.saveSettings();
        console.log("System prompt removed from conversation");
      }
    }
    this.updateSystemPromptIndicator();
  }
  async showNoteSelector() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Add Note Context");
    modal.modalEl.style.width = "400px";
    modal.modalEl.style.height = "60vh";
    modal.modalEl.style.minWidth = "400px";
    const contentEl = modal.contentEl;
    contentEl.empty();
    const searchInput = contentEl.createEl("input", {
      type: "text",
      placeholder: "Search notes...",
      cls: "stella-note-search"
    });
    const mainContainer = contentEl.createDiv({ cls: "stella-modal-container" });
    const leftPanel = mainContainer.createDiv({ cls: "stella-modal-left-panel" });
    const rightPanel = mainContainer.createDiv({ cls: "stella-modal-right-panel" });
    const previewContainer = rightPanel.createDiv({ cls: "stella-preview-container" });
    const previewContent = previewContainer.createDiv({ cls: "stella-preview-content" });
    previewContent.textContent = "Select a note and press \u2192 to preview";
    const notesContainer = leftPanel.createDiv({ cls: "stella-notes-container" });
    const files = this.app.vault.getMarkdownFiles();
    let filteredFiles = files;
    let selectedIndex = 0;
    let previewVisible = false;
    const renderFiles = (filesToRender) => {
      notesContainer.empty();
      if (selectedIndex >= filesToRender.length) {
        selectedIndex = Math.max(0, filesToRender.length - 1);
      }
      filesToRender.slice(0, 50).forEach((file, index) => {
        const noteItem = notesContainer.createDiv({
          cls: "stella-note-item"
        });
        const titleEl = noteItem.createDiv({ cls: "stella-note-title" });
        titleEl.textContent = file.basename;
        const pathEl = noteItem.createDiv({ cls: "stella-note-path" });
        pathEl.textContent = file.path;
        noteItem.addEventListener("click", async () => {
          await this.addNoteContext(file);
          modal.close();
        });
        if (index === selectedIndex) {
          noteItem.classList.add("selected");
        }
      });
    };
    renderFiles(filteredFiles);
    const fixNotesHeight = () => {
      setTimeout(() => {
        const modalHeight = modal.modalEl.clientHeight;
        const searchInputHeight = searchInput.offsetHeight + 16;
        const titleHeight = modal.titleEl.offsetHeight;
        const padding = 40;
        const availableHeight = modalHeight - titleHeight - searchInputHeight - padding;
        notesContainer.style.height = `${availableHeight}px`;
        notesContainer.style.maxHeight = `${availableHeight}px`;
        notesContainer.style.overflow = "auto";
      }, 50);
    };
    searchInput.addEventListener("input", (e) => {
      const query = e.target.value.toLowerCase();
      if (query === "") {
        filteredFiles = files;
      } else {
        filteredFiles = files.filter(
          (file) => file.basename.toLowerCase().includes(query) || file.path.toLowerCase().includes(query)
        );
      }
      selectedIndex = 0;
      renderFiles(filteredFiles);
    });
    const showPreview = async (file) => {
      try {
        const content = await this.app.vault.read(file);
        previewContent.empty();
        await this.renderMarkdown(previewContent, content);
        rightPanel.style.display = "block";
        previewVisible = true;
        modal.modalEl.style.width = "60vw";
        modal.modalEl.style.maxWidth = "980px";
        leftPanel.style.width = "50%";
        rightPanel.style.width = "50%";
        fixNotesHeight();
      } catch (error) {
        previewContent.textContent = `Error loading preview: ${error.message}`;
      }
    };
    const hidePreview = () => {
      rightPanel.style.display = "none";
      leftPanel.style.width = "100%";
      previewVisible = false;
      modal.modalEl.style.width = "400px";
      modal.modalEl.style.maxWidth = "none";
      fixNotesHeight();
    };
    hidePreview();
    const handleKeydown = (e) => {
      var _a, _b, _c, _d, _e, _f;
      const items = notesContainer.querySelectorAll(".stella-note-item");
      const currentFilteredFiles = filteredFiles.slice(0, 50);
      if (e.key === "ArrowDown") {
        e.preventDefault();
        (_a = items[selectedIndex]) == null ? void 0 : _a.classList.remove("selected");
        selectedIndex = (selectedIndex + 1) % items.length;
        (_b = items[selectedIndex]) == null ? void 0 : _b.classList.add("selected");
        (_c = items[selectedIndex]) == null ? void 0 : _c.scrollIntoView({ behavior: "smooth", block: "nearest" });
        if (previewVisible && currentFilteredFiles[selectedIndex]) {
          showPreview(currentFilteredFiles[selectedIndex]);
        }
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        (_d = items[selectedIndex]) == null ? void 0 : _d.classList.remove("selected");
        selectedIndex = selectedIndex === 0 ? items.length - 1 : selectedIndex - 1;
        (_e = items[selectedIndex]) == null ? void 0 : _e.classList.add("selected");
        (_f = items[selectedIndex]) == null ? void 0 : _f.scrollIntoView({ behavior: "smooth", block: "nearest" });
        if (previewVisible && currentFilteredFiles[selectedIndex]) {
          showPreview(currentFilteredFiles[selectedIndex]);
        }
      } else if (e.key === "ArrowRight") {
        e.preventDefault();
        if (!previewVisible && currentFilteredFiles[selectedIndex]) {
          showPreview(currentFilteredFiles[selectedIndex]);
        }
      } else if (e.key === "ArrowLeft") {
        e.preventDefault();
        if (previewVisible) {
          hidePreview();
        }
      } else if (e.key === "Enter") {
        e.preventDefault();
        const selectedFile = currentFilteredFiles[selectedIndex];
        if (selectedFile) {
          this.addNoteContext(selectedFile);
          modal.close();
        }
      } else if (e.key === "Escape") {
        e.preventDefault();
        modal.close();
      } else if (e.key === "Tab") {
        e.preventDefault();
        if (document.activeElement === searchInput) {
          notesContainer.focus();
        } else {
          searchInput.focus();
        }
      }
    };
    modal.containerEl.setAttribute("tabindex", "0");
    modal.containerEl.addEventListener("keydown", handleKeydown);
    setTimeout(() => searchInput.focus(), 100);
    const originalClose = modal.close.bind(modal);
    modal.close = () => {
      modal.containerEl.removeEventListener("keydown", handleKeydown);
      originalClose();
    };
    modal.open();
    fixNotesHeight();
  }
  async addNoteContext(file) {
    try {
      const content = await this.app.vault.read(file);
      this.contextNotes.push({
        name: file.basename,
        content
      });
      this.updateContextIndicator();
      console.log(`Added note context: ${file.basename}`);
    } catch (error) {
      this.addMessage(`Error reading note: ${error.message}`, "error");
    }
  }
  removeNoteContext(index) {
    if (index >= 0 && index < this.contextNotes.length) {
      const removed = this.contextNotes.splice(index, 1)[0];
      this.updateContextIndicator();
      console.log(`Removed note context: ${removed.name}`);
    }
  }
  showNoteContextManager() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Manage Note Context");
    const container = modal.contentEl.createDiv({ cls: "stella-note-manager-container" });
    if (this.contextNotes.length === 0) {
      container.createEl("p", { text: "No notes are currently loaded in context." });
      const addButton = container.createEl("button", {
        text: "Add Notes",
        cls: "mod-cta"
      });
      addButton.addEventListener("click", () => {
        modal.close();
        this.showNoteSelector();
      });
    } else {
      container.createEl("p", { text: `${this.contextNotes.length} note(s) loaded in context:` });
      const notesList = container.createEl("div", { cls: "stella-notes-manager-list" });
      this.contextNotes.forEach((note, index) => {
        const noteItem = notesList.createDiv({ cls: "stella-note-manager-item" });
        const noteName = noteItem.createEl("span", {
          text: note.name,
          cls: "stella-note-name"
        });
        const removeButton = noteItem.createEl("button", {
          text: "\xD7",
          cls: "stella-note-remove-btn"
        });
        removeButton.addEventListener("click", () => {
          this.removeNoteContext(index);
          modal.close();
        });
      });
      const buttonContainer = container.createEl("div", { cls: "stella-note-manager-buttons" });
      const addMoreButton = buttonContainer.createEl("button", {
        text: "Add More Notes",
        cls: "mod-secondary"
      });
      addMoreButton.addEventListener("click", () => {
        modal.close();
        this.showNoteSelector();
      });
      const clearAllButton = buttonContainer.createEl("button", {
        text: "Clear All",
        cls: "mod-warning"
      });
      clearAllButton.addEventListener("click", () => {
        this.contextNotes = [];
        this.updateContextIndicator();
        modal.close();
      });
    }
    modal.open();
  }
  showHelpMessage() {
    const helpText = "Available Commands:\n\n" + this.availableCommands.map((cmd) => `${cmd.command.padEnd(12)} - ${cmd.description}`).join("\n");
    const messageEl = this.addMessage(helpText, "system");
    const contentEl = messageEl.querySelector(".stella-message-content");
    if (contentEl) {
      contentEl.style.fontFamily = "var(--font-monospace)";
      contentEl.style.whiteSpace = "pre-line";
      contentEl.style.backgroundColor = "var(--background-secondary)";
      contentEl.style.padding = "12px";
      contentEl.style.borderRadius = "4px";
      contentEl.style.fontSize = "13px";
    }
  }
  updateContextIndicator() {
    if (this.contextIndicator) {
      this.contextIndicator.style.display = "none";
    }
    this.updateNoteIndicator();
  }
  updateNoteIndicator() {
    var _a;
    if (!this.noteIndicator)
      return;
    const newNoteIndicator = this.noteIndicator.cloneNode(true);
    (_a = this.noteIndicator.parentNode) == null ? void 0 : _a.replaceChild(newNoteIndicator, this.noteIndicator);
    this.noteIndicator = newNoteIndicator;
    if (this.contextNotes.length > 0) {
      this.noteIndicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>';
      this.noteIndicator.style.display = "block";
      this.noteIndicator.addEventListener("click", (e) => {
        e.preventDefault();
        this.showNoteContextManager();
      });
      let tooltipElement = null;
      this.noteIndicator.addEventListener("mouseenter", (e) => {
        if (tooltipElement) {
          tooltipElement.remove();
        }
        const notesList = this.contextNotes.map((note) => `\u2022 ${note.name}`).join("\n");
        const tooltipText = `Loaded notes:
${notesList}`;
        tooltipElement = document.body.createEl("div", {
          cls: "stella-tooltip",
          text: tooltipText
        });
        const rect = this.noteIndicator.getBoundingClientRect();
        const tooltipRect = tooltipElement.getBoundingClientRect();
        const left = rect.left + rect.width / 2 - tooltipRect.width / 2;
        const top = rect.top - tooltipRect.height - 10;
        tooltipElement.style.position = "fixed";
        tooltipElement.style.left = `${Math.max(10, left)}px`;
        tooltipElement.style.top = `${Math.max(10, top)}px`;
        tooltipElement.style.zIndex = "10000";
      });
      this.noteIndicator.addEventListener("mouseleave", () => {
        if (tooltipElement) {
          tooltipElement.remove();
          tooltipElement = null;
        }
      });
    } else {
      this.noteIndicator.innerHTML = "";
      this.noteIndicator.style.display = "none";
    }
    this.updateIndicatorPositions();
  }
  buildSystemMessage() {
    let systemMessage = "";
    if (this.currentSystemPrompt) {
      systemMessage += this.currentSystemPrompt;
    }
    if (this.currentMentalModel) {
      if (systemMessage) {
        systemMessage += "\n\n";
      }
      systemMessage += this.currentMentalModel;
    }
    if (this.contextNotes.length > 0) {
      if (systemMessage) {
        systemMessage += "\n\n";
      }
      systemMessage += "Here are reference notes that may be relevant to the conversation:\n\n";
      systemMessage += this.contextNotes.map(
        (note) => `=== Note: ${note.name} ===
${note.content}
`
      ).join("\n");
    }
    try {
      if (this.activeMCPServers && Array.isArray(this.activeMCPServers) && this.activeMCPServers.length > 0) {
        console.log("buildSystemMessage: Adding MCP tools to system message", this.activeMCPServers);
        if (systemMessage) {
          systemMessage += "\n\n";
        }
        systemMessage += "You have access to the following MCP (Model Context Protocol) tools through Google's function calling system:\n\n";
        for (const serverInfo of this.activeMCPServers) {
          try {
            if (!serverInfo) {
              console.warn("buildSystemMessage: Skipping null/undefined server");
              continue;
            }
            console.log(`buildSystemMessage: Processing server ${serverInfo.name || "unknown"}`, serverInfo);
            const tools = Array.isArray(serverInfo.tools) ? serverInfo.tools : [];
            const prompts = Array.isArray(serverInfo.prompts) ? serverInfo.prompts : [];
            if (tools.length > 0) {
              systemMessage += `=== ${serverInfo.name} Server Tools ===
`;
              for (const tool of tools) {
                try {
                  if (tool && tool.name) {
                    const functionName = `${serverInfo.name}_${tool.name}`;
                    systemMessage += `\u2022 Function: ${functionName}`;
                    if (tool.description) {
                      systemMessage += ` - ${tool.description}`;
                    }
                    systemMessage += "\n";
                    if (tool.inputSchema && tool.inputSchema.properties) {
                      const properties = Object.keys(tool.inputSchema.properties);
                      if (properties.length > 0) {
                        systemMessage += `  Parameters: ${properties.join(", ")}
`;
                      }
                    }
                  }
                } catch (toolError) {
                  console.error("Error processing tool:", tool, toolError);
                }
              }
              systemMessage += "\n";
            }
            if (prompts.length > 0) {
              systemMessage += `=== ${serverInfo.name} Server Prompts ===
`;
              for (const prompt of prompts) {
                try {
                  if (prompt && prompt.name) {
                    systemMessage += `\u2022 ${prompt.name}`;
                    if (prompt.description) {
                      systemMessage += ` - ${prompt.description}`;
                    }
                    systemMessage += "\n";
                  }
                } catch (promptError) {
                  console.error("Error processing prompt:", prompt, promptError);
                }
              }
              systemMessage += "\n";
            }
          } catch (serverError) {
            console.error(`buildSystemMessage: Error processing server ${(serverInfo == null ? void 0 : serverInfo.name) || "unknown"}:`, serverError);
            systemMessage += `=== ${(serverInfo == null ? void 0 : serverInfo.name) || "Unknown Server"} Server ===
(Error loading tools/prompts)

`;
          }
        }
        systemMessage += "IMPORTANT: You can call these functions directly using Google's function calling capability. When you need to use a tool, call the corresponding function and I will automatically execute it and return the results to you. Do not ask the user to run tools - call them directly when needed.";
        console.log("buildSystemMessage: Final system message with MCP info:", systemMessage);
      }
    } catch (mcpError) {
      console.error("buildSystemMessage: Error processing MCP servers:", mcpError, this.activeMCPServers);
      if (systemMessage)
        systemMessage += "\n\n";
      systemMessage += "=== MCP Integration ===\n(Error loading MCP server information)\n\n";
    }
    return systemMessage;
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById("stella-mcp");
  }
  updateModelInfo(container) {
    const { provider, model } = this.plugin.settings;
    const providerName = provider === "anthropic" ? "claude" : provider === "openai" ? "openai" : provider === "google" ? "google" : provider === "ollama" ? "ollama" : provider === "lmstudio" ? "lm-studio" : "custom";
    if (!model || model.trim() === "") {
      container.textContent = `${providerName}: no model selected`;
    } else {
      container.textContent = `${providerName}: ${model}`;
    }
  }
  updateSystemPromptIndicator() {
    if (!this.systemPromptIndicator)
      return;
    if (this.currentSystemPrompt) {
      this.systemPromptIndicator.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M7 7l4 4-4 4"></path><path d="M13 15h4"></path></svg>';
      this.systemPromptIndicator.style.display = "block";
      const promptName = this.currentSystemPromptFilename || "System Prompt";
      this.systemPromptIndicator.setAttribute("title", promptName);
    } else {
      this.systemPromptIndicator.innerHTML = "";
      this.systemPromptIndicator.style.display = "none";
    }
    this.updateIndicatorPositions();
  }
  updateMentalModelIndicator() {
    if (!this.mentalModelIndicator)
      return;
    if (this.currentMentalModel) {
      this.mentalModelIndicator.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a7 7 0 1 0 10 10"/></svg>';
      this.mentalModelIndicator.style.display = "block";
      const modelName = this.currentMentalModelFilename || "Mental Model";
      this.mentalModelIndicator.setAttribute("title", modelName);
    } else {
      this.mentalModelIndicator.innerHTML = "";
      this.mentalModelIndicator.style.display = "none";
    }
    this.updateIndicatorPositions();
  }
  updateIndicatorPositions() {
    if (!this.systemPromptIndicator || !this.mentalModelIndicator || !this.mcpIndicator || !this.noteIndicator)
      return;
    const hasSystemPrompt = this.currentSystemPrompt !== null;
    const hasMentalModel = this.currentMentalModel !== null;
    const hasMCP = this.activeMCPServers && this.activeMCPServers.length > 0;
    const hasNotes = this.contextNotes.length > 0;
    this.systemPromptIndicator.style.right = "";
    this.mentalModelIndicator.style.right = "";
    this.mcpIndicator.style.right = "";
    this.noteIndicator.style.right = "";
    const activeIndicators = [];
    if (hasSystemPrompt)
      activeIndicators.push("system");
    if (hasMentalModel)
      activeIndicators.push("mental");
    if (hasMCP)
      activeIndicators.push("mcp");
    if (hasNotes)
      activeIndicators.push("note");
    activeIndicators.forEach((type, index) => {
      const rightPosition = 16 + index * 32;
      if (type === "system") {
        this.systemPromptIndicator.style.right = `${rightPosition}px`;
      } else if (type === "mental") {
        this.mentalModelIndicator.style.right = `${rightPosition}px`;
      } else if (type === "mcp") {
        this.mcpIndicator.style.right = `${rightPosition}px`;
      } else if (type === "note") {
        this.noteIndicator.style.right = `${rightPosition}px`;
      }
    });
  }
  async showMentalModelSelector() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Select Mental Model");
    modal.modalEl.style.width = "400px";
    modal.modalEl.style.height = "60vh";
    modal.modalEl.style.minWidth = "400px";
    const contentEl = modal.contentEl;
    contentEl.empty();
    modal.open();
    try {
      let mentalModelsPath = this.plugin.settings.mentalModelsPath;
      const isAbsolutePath = mentalModelsPath.startsWith("/") || /^[A-Za-z]:[\\/]/.test(mentalModelsPath);
      console.log("Mental Model Path check - Original:", mentalModelsPath, "Is absolute:", isAbsolutePath);
      if (mentalModelsPath && !isAbsolutePath) {
        console.log("Attempting to resolve vault-relative path:", mentalModelsPath);
        let vaultPath = null;
        const adapter = this.app.vault.adapter;
        if (adapter.path) {
          vaultPath = adapter.path;
        } else if (adapter.basePath) {
          vaultPath = adapter.basePath;
        } else if (adapter.getBasePath) {
          vaultPath = adapter.getBasePath();
        }
        console.log("Found vault path:", vaultPath, "type:", typeof vaultPath);
        if (vaultPath && typeof vaultPath === "string") {
          const path2 = require("path");
          mentalModelsPath = path2.join(vaultPath, mentalModelsPath);
          console.log("Resolved vault-relative path to:", mentalModelsPath);
        } else {
          console.log("Could not get vault path as string, trying vault name approach...");
          const vaultName = this.app.vault.getName();
          if (vaultName) {
            const path2 = require("path");
            const process2 = require("process");
            mentalModelsPath = path2.join(process2.cwd(), vaultName, mentalModelsPath);
            console.log("Fallback path resolution:", mentalModelsPath);
          }
        }
      }
      if (!mentalModelsPath) {
        contentEl.createEl("p", {
          text: "Mental models directory not configured. Please set it in plugin settings."
        });
        const settingsBtn = contentEl.createEl("button", {
          text: "Open Settings",
          cls: "mod-cta"
        });
        settingsBtn.onclick = () => {
          modal.close();
          this.openSettings();
        };
        return;
      }
      const fs = require("fs");
      const path = require("path");
      if (!fs.existsSync(mentalModelsPath)) {
        contentEl.createEl("p", {
          text: `Mental models directory not found: ${mentalModelsPath}`
        });
        contentEl.createEl("p", {
          text: "Please check the path in plugin settings."
        });
        return;
      }
      const files = fs.readdirSync(mentalModelsPath).filter((file) => file.endsWith(".md")).sort();
      if (files.length === 0) {
        contentEl.createEl("p", {
          text: "No .md files found in Mental Models directory."
        });
      } else {
        const mainContainer = contentEl.createDiv({ cls: "stella-modal-container" });
        const leftPanel = mainContainer.createDiv({ cls: "stella-modal-left-panel" });
        const rightPanel = mainContainer.createDiv({ cls: "stella-modal-right-panel" });
        const previewContainer = rightPanel.createDiv({ cls: "stella-preview-container" });
        const previewContent = previewContainer.createDiv({ cls: "stella-preview-content" });
        previewContent.textContent = "Select a mental model and press \u2192 to preview";
        const fileList = leftPanel.createDiv({ cls: "stella-mental-models-list" });
        let selectedIndex = 0;
        let previewVisible = false;
        const fixFileListHeight = () => {
          setTimeout(() => {
            const modalHeight = modal.modalEl.clientHeight;
            const titleHeight = modal.titleEl.offsetHeight;
            const padding = 40;
            const availableHeight = modalHeight - titleHeight - padding;
            fileList.style.height = `${availableHeight}px`;
            fileList.style.maxHeight = `${availableHeight}px`;
            fileList.style.overflow = "auto";
          }, 50);
        };
        files.forEach((filename, index) => {
          const fileItem = fileList.createDiv({
            cls: "stella-mental-model-item"
          });
          const titleEl = fileItem.createDiv({ cls: "stella-mental-model-title" });
          titleEl.textContent = filename.replace(".md", "");
          fileItem.addEventListener("click", async () => {
            await this.loadMentalModel(path.join(mentalModelsPath, filename));
            modal.close();
            setTimeout(() => {
              this.chatInput.focus();
            }, 100);
          });
          if (index === 0) {
            fileItem.classList.add("selected");
          }
        });
        const showPreview = async (filename) => {
          try {
            const fs2 = require("fs");
            const filePath = path.join(mentalModelsPath, filename);
            const content = fs2.readFileSync(filePath, "utf8");
            previewContent.empty();
            await this.renderMarkdown(previewContent, content);
            rightPanel.style.display = "block";
            previewVisible = true;
            modal.modalEl.style.width = "60vw";
            modal.modalEl.style.maxWidth = "980px";
            leftPanel.style.width = "50%";
            rightPanel.style.width = "50%";
            fixFileListHeight();
          } catch (error) {
            previewContent.textContent = `Error loading preview: ${error.message}`;
          }
        };
        const hidePreview = () => {
          rightPanel.style.display = "none";
          leftPanel.style.width = "100%";
          previewVisible = false;
          modal.modalEl.style.width = "400px";
          modal.modalEl.style.maxWidth = "none";
          fixFileListHeight();
        };
        const handleKeydown = (e) => {
          var _a, _b, _c, _d, _e, _f;
          const items = fileList.querySelectorAll(".stella-mental-model-item");
          if (e.key === "ArrowDown") {
            e.preventDefault();
            (_a = items[selectedIndex]) == null ? void 0 : _a.classList.remove("selected");
            selectedIndex = (selectedIndex + 1) % items.length;
            (_b = items[selectedIndex]) == null ? void 0 : _b.classList.add("selected");
            (_c = items[selectedIndex]) == null ? void 0 : _c.scrollIntoView({ behavior: "smooth", block: "nearest" });
            if (previewVisible) {
              showPreview(files[selectedIndex]);
            }
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            (_d = items[selectedIndex]) == null ? void 0 : _d.classList.remove("selected");
            selectedIndex = selectedIndex === 0 ? items.length - 1 : selectedIndex - 1;
            (_e = items[selectedIndex]) == null ? void 0 : _e.classList.add("selected");
            (_f = items[selectedIndex]) == null ? void 0 : _f.scrollIntoView({ behavior: "smooth", block: "nearest" });
            if (previewVisible) {
              showPreview(files[selectedIndex]);
            }
          } else if (e.key === "ArrowRight") {
            e.preventDefault();
            if (!previewVisible) {
              showPreview(files[selectedIndex]);
            }
          } else if (e.key === "ArrowLeft") {
            e.preventDefault();
            if (previewVisible) {
              hidePreview();
            }
          } else if (e.key === "Enter") {
            e.preventDefault();
            const selectedFilename = files[selectedIndex];
            if (selectedFilename) {
              this.loadMentalModel(path.join(mentalModelsPath, selectedFilename));
              modal.close();
              setTimeout(() => {
                this.chatInput.focus();
              }, 100);
            }
          } else if (e.key === "Escape") {
            e.preventDefault();
            modal.close();
          }
        };
        hidePreview();
        modal.containerEl.setAttribute("tabindex", "0");
        modal.containerEl.addEventListener("keydown", handleKeydown);
        setTimeout(() => modal.containerEl.focus(), 100);
        fixFileListHeight();
        const originalClose = modal.close.bind(modal);
        modal.close = () => {
          modal.containerEl.removeEventListener("keydown", handleKeydown);
          originalClose();
        };
      }
    } catch (error) {
      contentEl.createEl("p", {
        text: `Error reading mental models: ${error.message}`
      });
      console.error("Error reading mental models:", error);
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const closeBtn = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeBtn.onclick = () => {
      modal.close();
      setTimeout(() => {
        this.chatInput.focus();
      }, 100);
    };
    modal.onClose = () => {
      setTimeout(() => {
        this.chatInput.focus();
      }, 100);
    };
  }
  async loadMentalModel(filepath) {
    try {
      const fs = require("fs");
      const path = require("path");
      const content = fs.readFileSync(filepath, "utf8");
      const filename = path.basename(filepath, path.extname(filepath));
      this.currentMentalModel = content;
      this.currentMentalModelFilename = filename;
      console.log("Mental model loaded:", filename);
      if (this.currentConversationId) {
        const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
        if (conversation) {
          conversation.mentalModel = content;
          conversation.mentalModelFilename = filename;
          conversation.updatedAt = Date.now();
          this.plugin.saveSettings();
          console.log("Mental model saved to conversation:", filename);
        }
      }
      this.updateMentalModelIndicator();
    } catch (error) {
      this.addMessage(`Error loading mental model: ${error.message}`, "error");
    }
  }
  unloadMentalModel() {
    this.currentMentalModel = null;
    this.currentMentalModelFilename = null;
    console.log("Mental model unloaded");
    if (this.currentConversationId) {
      const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
      if (conversation) {
        conversation.mentalModel = void 0;
        conversation.mentalModelFilename = void 0;
        conversation.updatedAt = Date.now();
        this.plugin.saveSettings();
        console.log("Mental model removed from conversation");
      }
    }
    this.updateMentalModelIndicator();
  }
  async showMCPSelector() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Select MCP Server");
    modal.modalEl.style.width = "70vw";
    modal.modalEl.style.height = "70vh";
    modal.modalEl.style.maxWidth = "1000px";
    modal.modalEl.style.minWidth = "600px";
    const contentEl = modal.contentEl;
    contentEl.empty();
    modal.open();
    try {
      const mcpManager = this.plugin.mcpClientManager;
      if (!mcpManager) {
        contentEl.createEl("p", { text: "MCP is not enabled. Please enable it in settings." });
        const settingsBtn = contentEl.createEl("button", { text: "Open Settings", cls: "mod-cta" });
        settingsBtn.onclick = () => {
          modal.close();
          this.openSettings();
        };
        return;
      }
      const servers = Array.from(mcpManager.getServers().values());
      if (servers.length === 0) {
        contentEl.createEl("p", { text: "No MCP servers configured. Please add servers in settings." });
        const settingsBtn = contentEl.createEl("button", { text: "Open Settings", cls: "mod-cta" });
        settingsBtn.onclick = () => {
          modal.close();
          this.openSettings();
        };
        return;
      }
      for (const server of servers) {
        if (server.connected) {
          try {
            await mcpManager.refreshServerTools(server.id);
            await mcpManager.refreshServerPrompts(server.id);
          } catch (error) {
          }
        }
      }
      const mainContainer = contentEl.createDiv();
      mainContainer.style.display = "flex";
      mainContainer.style.height = "100%";
      mainContainer.style.gap = "16px";
      const leftPanel = mainContainer.createDiv();
      leftPanel.style.width = "40%";
      leftPanel.style.borderRight = "1px solid var(--background-modifier-border)";
      leftPanel.style.paddingRight = "16px";
      const rightPanel = mainContainer.createDiv();
      rightPanel.style.width = "60%";
      const serverList = leftPanel.createDiv();
      serverList.style.maxHeight = "calc(70vh - 100px)";
      serverList.style.overflowY = "auto";
      const previewContent = rightPanel.createDiv();
      previewContent.style.maxHeight = "calc(70vh - 100px)";
      previewContent.style.overflowY = "auto";
      previewContent.textContent = "Select a server to view tools & prompts";
      let selectedIndex = 0;
      const mcpServerItems = [];
      servers.forEach((server, index) => {
        const serverItem = serverList.createDiv();
        serverItem.style.padding = "12px";
        serverItem.style.marginBottom = "8px";
        serverItem.style.cursor = "pointer";
        serverItem.style.borderRadius = "4px";
        serverItem.style.border = "1px solid transparent";
        serverItem.style.backgroundColor = "var(--background-secondary)";
        if (index === 0) {
          serverItem.style.backgroundColor = "var(--background-modifier-hover)";
          serverItem.style.border = "1px solid var(--accent-color)";
          serverItem.classList.add("selected");
        }
        const nameEl = serverItem.createDiv();
        nameEl.textContent = server.name;
        nameEl.style.fontWeight = "500";
        nameEl.style.marginBottom = "4px";
        const statusEl = serverItem.createDiv();
        statusEl.textContent = server.connected ? "Connected" : "Disconnected";
        statusEl.style.fontSize = "12px";
        statusEl.style.color = server.connected ? "var(--text-success)" : "var(--text-error)";
        mcpServerItems.push(serverItem);
        serverItem.onclick = () => {
          mcpServerItems.forEach((el) => {
            el.style.backgroundColor = "var(--background-secondary)";
            el.style.border = "1px solid transparent";
            el.classList.remove("selected");
          });
          serverItem.style.backgroundColor = "var(--background-modifier-hover)";
          serverItem.style.border = "1px solid var(--accent-color)";
          serverItem.classList.add("selected");
          selectedIndex = index;
          showPreview(server);
        };
      });
      const showPreview = async (server) => {
        previewContent.innerHTML = "";
        const header = previewContent.createDiv();
        header.style.marginBottom = "16px";
        const title = header.createEl("h3");
        title.textContent = server.name;
        title.style.margin = "0 0 8px 0";
        const status = header.createDiv();
        status.textContent = server.connected ? "Connected" : "Disconnected";
        status.style.color = server.connected ? "var(--text-success)" : "var(--text-error)";
        status.style.fontSize = "14px";
        const tools = mcpManager.getTools().get(server.id) || [];
        const prompts = mcpManager.getPrompts().get(server.id) || [];
        if (tools.length > 0) {
          const toolsSection = previewContent.createDiv();
          toolsSection.style.marginBottom = "16px";
          const toolsTitle = toolsSection.createEl("h4");
          toolsTitle.textContent = `Tools (${tools.length})`;
          toolsTitle.style.margin = "0 0 8px 0";
          toolsTitle.style.fontSize = "16px";
          tools.forEach((tool) => {
            const toolItem = toolsSection.createDiv();
            toolItem.style.padding = "8px";
            toolItem.style.marginBottom = "4px";
            toolItem.style.backgroundColor = "var(--background-secondary)";
            toolItem.style.borderRadius = "4px";
            toolItem.style.cursor = "pointer";
            toolItem.style.border = "1px solid transparent";
            toolItem.addEventListener("mouseenter", () => {
              toolItem.style.backgroundColor = "var(--background-modifier-hover)";
              toolItem.style.border = "1px solid var(--accent-color)";
            });
            toolItem.addEventListener("mouseleave", () => {
              toolItem.style.backgroundColor = "var(--background-secondary)";
              toolItem.style.border = "1px solid transparent";
            });
            const toolName = toolItem.createDiv();
            toolName.textContent = tool.name;
            toolName.style.fontWeight = "500";
            if (tool.description) {
              const desc = toolItem.createDiv();
              desc.textContent = tool.description;
              desc.style.fontSize = "12px";
              desc.style.color = "var(--text-muted)";
              desc.style.marginTop = "4px";
            }
            toolItem.onclick = () => {
              this.activateMCPTool(server.name, tool);
              modal.close();
              setTimeout(() => this.chatInput.focus(), 100);
            };
          });
        }
        if (prompts.length > 0) {
          const promptsSection = previewContent.createDiv();
          const promptsTitle = promptsSection.createEl("h4");
          promptsTitle.textContent = `Prompts (${prompts.length})`;
          promptsTitle.style.margin = "0 0 8px 0";
          promptsTitle.style.fontSize = "16px";
          prompts.forEach((prompt) => {
            const promptItem = promptsSection.createDiv();
            promptItem.style.padding = "8px";
            promptItem.style.marginBottom = "4px";
            promptItem.style.backgroundColor = "var(--background-secondary)";
            promptItem.style.borderRadius = "4px";
            promptItem.style.cursor = "pointer";
            promptItem.style.border = "1px solid transparent";
            promptItem.addEventListener("mouseenter", () => {
              promptItem.style.backgroundColor = "var(--background-modifier-hover)";
              promptItem.style.border = "1px solid var(--accent-color)";
            });
            promptItem.addEventListener("mouseleave", () => {
              promptItem.style.backgroundColor = "var(--background-secondary)";
              promptItem.style.border = "1px solid transparent";
            });
            const promptName = promptItem.createDiv();
            promptName.textContent = prompt.name;
            promptName.style.fontWeight = "500";
            if (prompt.description) {
              const desc = promptItem.createDiv();
              desc.textContent = prompt.description;
              desc.style.fontSize = "12px";
              desc.style.color = "var(--text-muted)";
              desc.style.marginTop = "4px";
            }
            promptItem.onclick = () => {
              this.activateMCPPrompt(server.name, prompt);
              modal.close();
              setTimeout(() => this.chatInput.focus(), 100);
            };
          });
        }
        if (tools.length === 0 && prompts.length === 0) {
          const emptyMsg = previewContent.createDiv();
          emptyMsg.textContent = "No tools or prompts available for this server.";
          emptyMsg.style.color = "var(--text-muted)";
          emptyMsg.style.fontStyle = "italic";
        }
      };
      const handleKeydown = (e) => {
        if (e.key === "ArrowUp") {
          e.preventDefault();
          selectedIndex = selectedIndex === 0 ? servers.length - 1 : selectedIndex - 1;
          mcpServerItems.forEach((el) => {
            el.style.backgroundColor = "var(--background-secondary)";
            el.style.border = "1px solid transparent";
            el.classList.remove("selected");
          });
          mcpServerItems[selectedIndex].style.backgroundColor = "var(--background-modifier-hover)";
          mcpServerItems[selectedIndex].style.border = "1px solid var(--accent-color)";
          mcpServerItems[selectedIndex].classList.add("selected");
          showPreview(servers[selectedIndex]);
          mcpServerItems[selectedIndex].scrollIntoView({ behavior: "smooth", block: "nearest" });
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          selectedIndex = (selectedIndex + 1) % servers.length;
          mcpServerItems.forEach((el) => {
            el.style.backgroundColor = "var(--background-secondary)";
            el.style.border = "1px solid transparent";
            el.classList.remove("selected");
          });
          mcpServerItems[selectedIndex].style.backgroundColor = "var(--background-modifier-hover)";
          mcpServerItems[selectedIndex].style.border = "1px solid var(--accent-color)";
          mcpServerItems[selectedIndex].classList.add("selected");
          showPreview(servers[selectedIndex]);
          mcpServerItems[selectedIndex].scrollIntoView({ behavior: "smooth", block: "nearest" });
        } else if (e.key === "Enter") {
          e.preventDefault();
          this.activateMCPServer(servers[selectedIndex]);
          modal.close();
          setTimeout(() => this.chatInput.focus(), 100);
        } else if (e.key === "Escape") {
          modal.close();
        }
      };
      modal.modalEl.addEventListener("keydown", handleKeydown);
      modal.onClose = () => {
        modal.modalEl.removeEventListener("keydown", handleKeydown);
      };
      modal.modalEl.setAttribute("tabindex", "-1");
      modal.modalEl.focus();
      if (servers.length > 0) {
        showPreview(servers[0]);
      }
    } catch (error) {
      console.error("Error in MCP selector:", error);
      contentEl.createEl("p", { text: `Error loading MCP data: ${error.message}` });
    }
  }
  activateMCPServer(server) {
    try {
      if (!this.activeMCPServers || !Array.isArray(this.activeMCPServers)) {
        this.activeMCPServers = [];
      }
      const existingIndex = this.activeMCPServers.findIndex((s) => s.name === server.name);
      if (existingIndex >= 0) {
        this.addMessage(`MCP server "${server.name}" is already active.`, "system");
        return;
      }
    } catch (error) {
      console.error("Error checking existing MCP servers:", error);
      this.activeMCPServers = [];
    }
    try {
      const mcpManager = this.plugin.mcpClientManager;
      const tools = (mcpManager == null ? void 0 : mcpManager.getTools().get(server.id)) || [];
      const prompts = (mcpManager == null ? void 0 : mcpManager.getPrompts().get(server.id)) || [];
      console.log(`MCP Debug - Activating server ${server.name} with ${tools.length} tools and ${prompts.length} prompts`);
      this.activeMCPServers.push({
        name: server.name,
        tools: tools || [],
        prompts: prompts || []
      });
    } catch (error) {
      console.error("Error activating MCP server:", server.name, error);
      this.activeMCPServers.push({
        name: server.name,
        tools: [],
        prompts: []
      });
    }
    this.updateMCPIndicator();
  }
  async executeMCPTool(functionName, args) {
    try {
      console.log(`executeMCPTool called with function: ${functionName}, args:`, args);
      if (!functionName || typeof functionName !== "string") {
        throw new Error(`Invalid function name: ${functionName}`);
      }
      const parts = functionName.split("_");
      if (!parts || !Array.isArray(parts) || parts.length < 2) {
        const error = `Invalid function name format: ${functionName}`;
        console.error(error);
        throw new Error(error);
      }
      const serverName = parts[0];
      const toolName = parts.slice(1).join("_");
      console.log(`Parsed server: ${serverName}, tool: ${toolName}`);
      const mcpManager = this.plugin.mcpClientManager;
      if (!mcpManager) {
        const error = "MCP manager not available";
        console.error(error);
        throw new Error(error);
      }
      const servers = Array.from(mcpManager.getServers().values());
      console.log("Available MCP servers:", servers.map((s) => ({ name: s.name, id: s.id, connected: s.connected })));
      const server = servers.find((s) => s.name === serverName);
      if (!server) {
        const error = `MCP server not found: ${serverName}`;
        console.error(error, "Available servers:", servers.map((s) => s.name));
        throw new Error(error);
      }
      console.log(`Found server: ${server.name} (${server.id}), connected: ${server.connected}`);
      console.log(`Executing MCP tool: ${toolName} on server: ${serverName} (${server.id}) with args:`, args);
      const result = await mcpManager.executeTool(server.id, toolName, args);
      console.log(`MCP tool execution result:`, result);
      return result;
    } catch (error) {
      console.error(`MCP executeMCPTool: Comprehensive error handler caught:`, error);
      console.error(`MCP executeMCPTool: Error stack:`, error.stack);
      console.error(`MCP executeMCPTool: Function name: ${functionName}, args:`, args);
      throw new Error(`MCP Tool Execution Failed [${functionName}]: ${error.message}`);
    }
  }
  activateMCPTool(serverName, tool) {
    try {
      if (!this.activeMCPServers || !Array.isArray(this.activeMCPServers)) {
        this.activeMCPServers = [];
      }
      let serverEntry = this.activeMCPServers.find((s) => s.name === serverName);
      if (!serverEntry) {
        const mcpManager = this.plugin.mcpClientManager;
        const server = Array.from((mcpManager == null ? void 0 : mcpManager.getServers().values()) || []).find((s) => s.name === serverName);
        if (server)
          this.activateMCPServer(server);
        serverEntry = this.activeMCPServers.find((s) => s.name === serverName);
      }
    } catch (error) {
      console.error("Error activating MCP tool:", serverName, tool.name, error);
    }
  }
  activateMCPPrompt(serverName, prompt) {
    const currentInput = this.chatInput.value;
    const promptText = `[MCP Prompt: ${prompt.name}]
${prompt.description || ""}`;
    this.chatInput.value = currentInput + (currentInput ? "\n\n" : "") + promptText;
  }
  updateMCPIndicator() {
    if (!this.mcpIndicator)
      return;
    if (this.activeMCPServers && this.activeMCPServers.length > 0) {
      this.mcpIndicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bow-arrow-icon lucide-bow-arrow"><path d="M17 3h4v4"/><path d="M18.575 11.082a13 13 0 0 1 1.048 9.027 1.17 1.17 0 0 1-1.914.597L14 17"/><path d="M7 10 3.29 6.29a1.17 1.17 0 0 1 .6-1.91 13 13 0 0 1 9.03 1.05"/><path d="M7 14a1.7 1.7 0 0 0-1.207.5l-2.646 2.646A.5.5 0 0 0 3.5 18H5a1 1 0 0 1 1 1v1.5a.5.5 0 0 0 .854.354L9.5 18.207A1.7 1.7 0 0 0 10 17v-2a1 1 0 0 0-1-1z"/><path d="M9.707 14.293 21 3"/></svg>';
      this.mcpIndicator.style.display = "flex";
      const tooltipLines = [];
      for (const activeServer of this.activeMCPServers) {
        try {
          const serverLine = `${activeServer.name}:`;
          tooltipLines.push(serverLine);
          const tools = activeServer.tools || [];
          const prompts = activeServer.prompts || [];
          if (tools.length > 0) {
            const toolNames = tools.map((t) => `  \u2022 ${t.name}`).join("\n");
            tooltipLines.push(toolNames);
          }
          if (prompts.length > 0) {
            const promptNames = prompts.map((p) => `  \u2022 ${p.name} (prompt)`).join("\n");
            tooltipLines.push(promptNames);
          }
          if (tools.length === 0 && prompts.length === 0) {
            tooltipLines.push("  \u2022 (server only)");
          }
        } catch (error) {
          console.error("Error processing MCP server for tooltip:", activeServer, error);
          tooltipLines.push(`${activeServer.name || "Unknown Server"}: (error loading tools/prompts)`);
        }
      }
      this.mcpIndicator.removeAttribute("title");
      this.mcpIndicator.removeAttribute("aria-label");
      let tooltipElement = null;
      this.mcpIndicator.addEventListener("mouseenter", (e) => {
        if (tooltipElement) {
          tooltipElement.remove();
        }
        tooltipElement = document.createElement("div");
        tooltipElement.className = "stella-mcp-tooltip";
        tooltipElement.style.position = "fixed";
        tooltipElement.style.backgroundColor = "var(--background-primary)";
        tooltipElement.style.color = "var(--text-normal)";
        tooltipElement.style.padding = "8px 12px";
        tooltipElement.style.borderRadius = "6px";
        tooltipElement.style.border = "1px solid var(--background-modifier-border)";
        tooltipElement.style.fontSize = "13px";
        tooltipElement.style.zIndex = "10000";
        tooltipElement.style.pointerEvents = "none";
        tooltipElement.style.whiteSpace = "pre-line";
        tooltipElement.style.minWidth = "200px";
        tooltipElement.style.maxWidth = "400px";
        tooltipElement.style.lineHeight = "1.4";
        tooltipElement.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.15)";
        const tooltipText = tooltipLines.join("\n");
        tooltipElement.textContent = tooltipText;
        tooltipElement.style.visibility = "hidden";
        document.body.appendChild(tooltipElement);
        const tooltipRect = tooltipElement.getBoundingClientRect();
        const rect = this.mcpIndicator.getBoundingClientRect();
        const left = rect.left + rect.width / 2 - tooltipRect.width / 2;
        const top = rect.top - tooltipRect.height - 10;
        const finalLeft = Math.max(10, Math.min(left, window.innerWidth - tooltipRect.width - 10));
        const finalTop = Math.max(10, top);
        tooltipElement.style.left = `${finalLeft}px`;
        tooltipElement.style.top = `${finalTop}px`;
        tooltipElement.style.visibility = "visible";
        document.body.appendChild(tooltipElement);
      });
      this.mcpIndicator.addEventListener("mouseleave", () => {
        if (tooltipElement) {
          tooltipElement.remove();
          tooltipElement = null;
        }
      });
    } else {
      this.mcpIndicator.innerHTML = "";
      this.mcpIndicator.style.display = "none";
    }
    this.updateIndicatorPositions();
  }
  clearMCPContext() {
    this.activeMCPServers = [];
    console.log("MCP context cleared");
    if (this.currentConversationId) {
      const conversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
      if (conversation) {
        conversation.mcpServers = [];
        conversation.updatedAt = Date.now();
        this.plugin.saveSettings();
        console.log("MCP context removed from conversation");
      }
    }
    this.updateMCPIndicator();
  }
  clearAllContext() {
    this.unloadSystemPrompt();
    this.unloadMentalModel();
    this.activeMCPServers = [];
    this.contextNotes = [];
    this.startNewConversation();
    console.log("All context cleared and new conversation started");
    this.updateSystemPromptIndicator();
    this.updateMentalModelIndicator();
    this.updateMCPIndicator();
    this.updateContextIndicator();
  }
  async detectAndActivateMCP(message) {
    if (!this.plugin.mcpClientManager)
      return;
    const mcpManager = this.plugin.mcpClientManager;
    const servers = Array.from(mcpManager.getServers().values());
    for (const server of servers) {
      const tools = mcpManager.getTools().get(server.id) || [];
      const prompts = mcpManager.getPrompts().get(server.id) || [];
      for (const tool of tools) {
        const toolNameRegex = new RegExp(`\\b${tool.name}\\b`, "i");
        if (toolNameRegex.test(message)) {
          this.activateMCPTool(server.name, tool);
        }
      }
      for (const prompt of prompts) {
        const promptNameRegex = new RegExp(`\\b${prompt.name}\\b`, "i");
        if (promptNameRegex.test(message)) {
          this.activateMCPPrompt(server.name, prompt);
        }
      }
      const serverNameRegex = new RegExp(`\\b${server.name}\\b`, "i");
      if (serverNameRegex.test(message)) {
        this.activateMCPServer(server);
      }
    }
    const mcpKeywords = ["file system", "filesystem", "directory", "folders", "github", "git repo", "database", "sql", "api", "weather", "calendar"];
    const messageLower = message.toLowerCase();
    for (const keyword of mcpKeywords) {
      if (messageLower.includes(keyword)) {
        const relevantServer = servers.find((s) => {
          if (keyword.includes("file") || keyword.includes("directory") || keyword.includes("folder")) {
            return s.name.toLowerCase().includes("file") || s.name.toLowerCase().includes("fs");
          }
          if (keyword.includes("github") || keyword.includes("git")) {
            return s.name.toLowerCase().includes("github") || s.name.toLowerCase().includes("git");
          }
          if (keyword.includes("database") || keyword.includes("sql")) {
            return s.name.toLowerCase().includes("database") || s.name.toLowerCase().includes("sql");
          }
          if (keyword.includes("weather")) {
            return s.name.toLowerCase().includes("weather");
          }
          if (keyword.includes("calendar")) {
            return s.name.toLowerCase().includes("calendar");
          }
          return false;
        });
        if (relevantServer && !this.activeMCPServers.find((s) => s.name === relevantServer.name)) {
          this.activateMCPServer(relevantServer);
        }
        break;
      }
    }
  }
  updateBackgroundImage() {
    var _a;
    console.log("updateBackgroundImage called");
    if (!this.chatContainer) {
      console.log("No chatContainer found");
      return;
    }
    const { backgroundImage, backgroundMode, backgroundOpacity } = this.plugin.settings;
    console.log("Background settings:", { backgroundImage, backgroundMode, backgroundOpacity });
    if (!backgroundImage) {
      console.log("No background image set, clearing styles");
      this.chatContainer.style.setProperty("--bg-image", "none");
      this.chatContainer.style.setProperty("--bg-size", "auto");
      this.chatContainer.style.setProperty("--bg-opacity", "1");
      return;
    }
    try {
      let imageUrl = backgroundImage;
      const isLocalPath = !backgroundImage.startsWith("http") && (backgroundImage.includes("\\") || backgroundImage.startsWith("/") || /^[A-Za-z]:/.test(backgroundImage));
      console.log("isLocalPath:", isLocalPath);
      if (isLocalPath) {
        try {
          const fs = require("fs");
          const fileBuffer = fs.readFileSync(backgroundImage);
          const base64 = fileBuffer.toString("base64");
          const fileExt = (_a = backgroundImage.split(".").pop()) == null ? void 0 : _a.toLowerCase();
          const mimeType = fileExt === "webp" ? "image/webp" : fileExt === "png" ? "image/png" : fileExt === "jpg" || fileExt === "jpeg" ? "image/jpeg" : fileExt === "gif" ? "image/gif" : "image/*";
          imageUrl = `data:${mimeType};base64,${base64}`;
          console.log("Using base64 data URL for local file (size: ~" + Math.round(base64.length / 1024) + "KB)");
        } catch (fsError) {
          console.log("Failed to read file as base64:", fsError);
          try {
            const adapter = this.app.vault.adapter;
            if (adapter && adapter.getResourcePath) {
              const cleanPath = backgroundImage.replace(/\\/g, "/");
              imageUrl = adapter.getResourcePath(cleanPath);
              console.log("Fallback: Using Obsidian resource path:", imageUrl);
            } else {
              imageUrl = backgroundImage.replace(/\\/g, "/");
              console.log("Final fallback: Using direct path:", imageUrl);
            }
          } catch (e2) {
            console.log("All methods failed:", e2);
            imageUrl = backgroundImage.replace(/\\/g, "/");
          }
        }
      }
      console.log("Setting background image to:", imageUrl);
      this.chatContainer.style.setProperty("--bg-image", `url("${imageUrl}")`);
      console.log("Setting background mode to:", backgroundMode);
      let backgroundSize;
      switch (backgroundMode) {
        case "centered":
          backgroundSize = "auto";
          break;
        case "fill":
          backgroundSize = "cover";
          break;
        case "stretch":
          backgroundSize = "100% 100%";
          break;
        default:
          backgroundSize = "cover";
      }
      this.chatContainer.style.setProperty("--bg-size", backgroundSize);
      console.log("Setting opacity to:", backgroundOpacity);
      this.chatContainer.style.setProperty("--bg-opacity", backgroundOpacity.toString());
      console.log("Background image applied successfully");
    } catch (error) {
      console.error("Error setting background image:", error);
      this.messagesContainer.style.backgroundImage = "";
    }
  }
  updateHeaderVisibility() {
    if (!this.headerContainer) {
      return;
    }
    const shouldHide = this.plugin.settings.autoHideHeader;
    if (shouldHide) {
      this.headerContainer.style.display = "none";
    } else {
      this.headerContainer.style.display = "flex";
    }
  }
  toggleHeader() {
    if (!this.headerContainer) {
      return;
    }
    this.plugin.settings.autoHideHeader = !this.plugin.settings.autoHideHeader;
    this.plugin.saveSettings();
    const isHiding = this.plugin.settings.autoHideHeader;
    if (isHiding) {
      this.headerContainer.style.opacity = "0";
      this.headerContainer.style.transform = "translateY(-100%)";
      setTimeout(() => {
        this.headerContainer.style.display = "none";
      }, 300);
    } else {
      this.headerContainer.style.display = "flex";
      this.headerContainer.style.opacity = "0";
      this.headerContainer.style.transform = "translateY(-100%)";
      this.headerContainer.offsetHeight;
      this.headerContainer.style.opacity = "1";
      this.headerContainer.style.transform = "translateY(0)";
    }
  }
  showNameInput() {
    const modal = new import_obsidian.Modal(this.app);
    modal.setTitle("Rename Conversation");
    const currentConversation = this.plugin.settings.conversations.find((c) => c.id === this.currentConversationId);
    const currentName = currentConversation ? currentConversation.title : "";
    const input = modal.contentEl.createEl("input", {
      type: "text",
      placeholder: "Enter conversation name...",
      value: currentName
    });
    input.style.width = "100%";
    input.style.marginBottom = "16px";
    input.style.padding = "8px";
    input.style.fontSize = "14px";
    input.style.border = "1px solid var(--background-modifier-border)";
    input.style.borderRadius = "4px";
    input.style.background = "var(--background-primary)";
    input.style.color = "var(--text-normal)";
    const buttonContainer = modal.contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.style.padding = "8px 16px";
    cancelButton.style.border = "1px solid var(--background-modifier-border)";
    cancelButton.style.borderRadius = "4px";
    cancelButton.style.background = "var(--background-secondary)";
    cancelButton.style.color = "var(--text-normal)";
    cancelButton.style.cursor = "pointer";
    const saveButton = buttonContainer.createEl("button", { text: "Save" });
    saveButton.style.padding = "8px 16px";
    saveButton.style.border = "1px solid var(--interactive-accent)";
    saveButton.style.borderRadius = "4px";
    saveButton.style.background = "var(--interactive-accent)";
    saveButton.style.color = "var(--text-on-accent)";
    saveButton.style.cursor = "pointer";
    const saveName = async () => {
      const newName = input.value.trim();
      if (newName && currentConversation) {
        currentConversation.title = newName;
        await this.plugin.saveSettings();
        this.conversationNameInput.value = newName;
        modal.close();
      }
    };
    cancelButton.addEventListener("click", () => modal.close());
    saveButton.addEventListener("click", saveName);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        saveName();
      } else if (e.key === "Escape") {
        e.preventDefault();
        modal.close();
      }
    });
    modal.open();
    setTimeout(() => {
      input.focus();
      input.select();
    }, 100);
  }
  openPluginSettings() {
    const app = this.app;
    app.setting.open();
    app.setting.openTabById("stella");
  }
  async onClose() {
    if (this.logger) {
      this.logger.destroy();
    }
  }
};
var StellaSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc("Select your AI provider").addDropdown((dropdown) => dropdown.addOption("anthropic", "Anthropic (Claude)").addOption("openai", "OpenAI (GPT)").addOption("google", "Google (Gemini)").addOption("ollama", "Ollama (Local)").addOption("lmstudio", "LM Studio (Local)").addOption("custom", "Custom API").setValue(this.plugin.settings.provider).onChange(async (value) => {
      this.plugin.settings.provider = value;
      this.plugin.settings.model = "";
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateModelInfo) {
          chatView.updateModelInfo(chatView.modelInfoContainer);
        }
      });
      this.display();
    }));
    if (this.plugin.settings.provider === "openai") {
      new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "anthropic") {
      new import_obsidian.Setting(containerEl).setName("Anthropic API Key").setDesc("Enter your Anthropic API key").addText((text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "google") {
      new import_obsidian.Setting(containerEl).setName("Google API Key").setDesc("Enter your Google AI API key").addText((text) => text.setPlaceholder("AI...").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "ollama") {
      new import_obsidian.Setting(containerEl).setName("Ollama Base URL").setDesc("Ollama server URL").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaBaseUrl).onChange(async (value) => {
        this.plugin.settings.ollamaBaseUrl = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "lmstudio") {
      new import_obsidian.Setting(containerEl).setName("LM Studio Base URL").setDesc("LM Studio server URL").addText((text) => text.setPlaceholder("http://localhost:1234").setValue(this.plugin.settings.lmStudioBaseUrl).onChange(async (value) => {
        this.plugin.settings.lmStudioBaseUrl = value;
        await this.plugin.saveSettings();
        this.refreshModelDropdown();
      }));
    }
    if (this.plugin.settings.provider === "custom") {
      new import_obsidian.Setting(containerEl).setName("Custom API URL").setDesc("Your custom API endpoint URL").addText((text) => text.setPlaceholder("https://your-api.com/v1/chat/completions").setValue(this.plugin.settings.customApiUrl).onChange(async (value) => {
        this.plugin.settings.customApiUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Custom API Key").setDesc("API key for your custom endpoint (optional)").addText((text) => text.setPlaceholder("your-api-key").setValue(this.plugin.settings.customApiKey).onChange(async (value) => {
        this.plugin.settings.customApiKey = value;
        await this.plugin.saveSettings();
      }));
    }
    this.modelSetting = new import_obsidian.Setting(containerEl).setName("Model").setDesc("Select the model to use (fetched from API)").addButton((button) => button.setButtonText("Refresh Models").onClick(() => this.refreshModelDropdown()));
    this.modelDropdown = this.modelSetting.addDropdown((dropdown) => {
      dropdown.setValue(this.plugin.settings.model);
      dropdown.onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
        this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
          const chatView = leaf.view;
          if (chatView && chatView.updateModelInfo) {
            chatView.updateModelInfo(chatView.modelInfoContainer);
          }
        });
      });
      return dropdown;
    });
    setTimeout(() => {
      console.log("Settings tab displayed, refreshing model dropdown...");
      this.refreshModelDropdown();
    }, 100);
    new import_obsidian.Setting(containerEl).setName("Max Tokens").setDesc("Maximum tokens per response").addText((text) => text.setValue(this.plugin.settings.maxTokens.toString()).onChange(async (value) => {
      this.plugin.settings.maxTokens = parseInt(value) || 4e3;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Temperature").setDesc("Creativity level (0-1)").addText((text) => text.setValue(this.plugin.settings.temperature.toString()).onChange(async (value) => {
      this.plugin.settings.temperature = parseFloat(value) || 0.7;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("System Prompts Directory").setDesc("Path to directory containing your system prompt .md files (for /sys command)").addText((text) => text.setPlaceholder("/path/to/your/system-prompts").setValue(this.plugin.settings.systemPromptsPath).onChange(async (value) => {
      this.plugin.settings.systemPromptsPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Mental Models Directory").setDesc("Path to directory containing your mental model .md files (for /model command)").addText((text) => text.setPlaceholder("/path/to/your/mental-models").setValue(this.plugin.settings.mentalModelsPath).onChange(async (value) => {
      this.plugin.settings.mentalModelsPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Background Image URL/Path").setDesc("URL or local file path to background image for chat area").addText((text) => text.setPlaceholder("https://example.com/image.jpg or /path/to/image.png").setValue(this.plugin.settings.backgroundImage).onChange(async (value) => {
      this.plugin.settings.backgroundImage = value;
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateBackgroundImage) {
          chatView.updateBackgroundImage();
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Background Display Mode").setDesc("How the background image should be displayed").addDropdown((dropdown) => dropdown.addOption("centered", "Centered").addOption("fill", "Fill").addOption("stretch", "Stretch").setValue(this.plugin.settings.backgroundMode).onChange(async (value) => {
      this.plugin.settings.backgroundMode = value;
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateBackgroundImage) {
          chatView.updateBackgroundImage();
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Background Opacity").setDesc("Opacity of the background image (0.0 to 1.0)").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.backgroundOpacity).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.backgroundOpacity = value;
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateBackgroundImage) {
          chatView.updateBackgroundImage();
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-hide header").setDesc("Automatically hide the header bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoHideHeader).onChange(async (value) => {
      this.plugin.settings.autoHideHeader = value;
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
        const chatView = leaf.view;
        if (chatView && chatView.updateHeaderVisibility) {
          chatView.updateHeaderVisibility();
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Show Token Count").setDesc("Display estimated token usage during and after response generation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTokenCount).onChange(async (value) => {
      this.plugin.settings.showTokenCount = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("QuickAdd Commands").setDesc("Configure right-click context menu options that trigger QuickAdd commands").addButton((button) => button.setButtonText("Show Available Commands").onClick(() => {
      this.showAvailableQuickAddCommands();
    })).addButton((button) => button.setButtonText("Add Command").onClick(() => {
      this.plugin.settings.quickAddCommands.push({
        id: `command-${Date.now()}`,
        name: "New Command",
        description: "Description for new command"
      });
      this.plugin.saveSettings();
      this.display();
    }));
    this.plugin.settings.quickAddCommands.forEach((command, index) => {
      const commandContainer = containerEl.createDiv("quickadd-command-item");
      new import_obsidian.Setting(commandContainer).setName(`Command ${index + 1}`).addText((text) => text.setPlaceholder("Command Name").setValue(command.name).onChange(async (value) => {
        this.plugin.settings.quickAddCommands[index].name = value;
        await this.plugin.saveSettings();
      })).addText((text) => text.setPlaceholder('QuickAdd Command ID (click "Show Available Commands" for help)').setValue(command.id).onChange(async (value) => {
        this.plugin.settings.quickAddCommands[index].id = value;
        await this.plugin.saveSettings();
      })).addTextArea((text) => text.setPlaceholder("Description").setValue(command.description).onChange(async (value) => {
        this.plugin.settings.quickAddCommands[index].description = value;
        await this.plugin.saveSettings();
      })).addButton((button) => button.setButtonText("Remove").setWarning().onClick(async () => {
        this.plugin.settings.quickAddCommands.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      }));
    });
    containerEl.createEl("h2", { text: "MCP (Model Context Protocol)" });
    new import_obsidian.Setting(containerEl).setName("Enable MCP").setDesc("Enable Model Context Protocol for connecting to external tools and data sources").addToggle((toggle) => toggle.setValue(this.plugin.settings.mcpEnabled).onChange(async (value) => {
      this.plugin.settings.mcpEnabled = value;
      await this.plugin.saveSettings();
      if (value && this.plugin.settings.mcpServers.length > 0) {
        await this.plugin.initializeMCPServers();
      }
      this.display();
    }));
    if (this.plugin.settings.mcpEnabled) {
      new import_obsidian.Setting(containerEl).setName("Auto-discovery").setDesc("Automatically discover MCP servers on the network").addToggle((toggle) => toggle.setValue(this.plugin.settings.mcpAutoDiscovery).onChange(async (value) => {
        this.plugin.settings.mcpAutoDiscovery = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Add MCP Server").setDesc("Configure connections to MCP servers").addButton((button) => button.setButtonText("Add Server").onClick(() => {
        this.showMCPServerModal();
      }));
      this.plugin.settings.mcpServers.forEach((server, index) => {
        const serverSetting = new import_obsidian.Setting(containerEl);
        const serverInfo = serverSetting.settingEl.createDiv("mcp-server-info");
        serverInfo.style.display = "flex";
        serverInfo.style.alignItems = "center";
        serverInfo.style.gap = "10px";
        serverInfo.style.width = "100%";
        const statusDot = serverInfo.createSpan("mcp-status-dot");
        statusDot.style.width = "8px";
        statusDot.style.height = "8px";
        statusDot.style.borderRadius = "50%";
        statusDot.style.backgroundColor = server.connected ? "#4ade80" : "#ef4444";
        const serverDetails = serverInfo.createDiv();
        serverDetails.createEl("strong", { text: server.name });
        serverDetails.createEl("br");
        serverDetails.createEl("small", {
          text: `${server.transport} - ${server.endpoint || server.command}`,
          attr: { style: "color: var(--text-muted);" }
        });
        const actions = serverInfo.createDiv();
        actions.style.marginLeft = "auto";
        actions.style.display = "flex";
        actions.style.gap = "8px";
        const connectBtn = actions.createEl("button", {
          text: server.connected ? "Disconnect" : "Connect",
          cls: "mod-cta"
        });
        connectBtn.onclick = async () => {
          if (server.connected) {
            await this.plugin.mcp.removeServer(server.id);
          } else {
            await this.plugin.mcp.addServer(server);
          }
          this.display();
        };
        const editBtn = actions.createEl("button", { text: "Edit" });
        editBtn.onclick = () => {
          this.showMCPServerModal(server, index);
        };
        const removeBtn = actions.createEl("button", {
          text: "Remove",
          cls: "mod-warning"
        });
        removeBtn.onclick = async () => {
          await this.plugin.mcp.removeServer(server.id);
          this.plugin.settings.mcpServers.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        };
      });
      if (this.plugin.settings.mcpServers.length > 0) {
        const connectedServers = this.plugin.mcp.getConnectedServers();
        const totalTools = this.plugin.mcp.getAllTools().length;
        const totalResources = this.plugin.mcp.getAllResources().length;
        const statusSetting = new import_obsidian.Setting(containerEl);
        const statusDiv = statusSetting.settingEl.createDiv("mcp-status");
        statusDiv.innerHTML = `
                    <strong>MCP Status:</strong><br>
                    Connected Servers: ${connectedServers.length}/${this.plugin.settings.mcpServers.length}<br>
                    Available Tools: ${totalTools}<br>
                    Available Resources: ${totalResources}
                `;
      }
    }
  }
  async fetchModelsForProvider(provider) {
    try {
      switch (provider) {
        case "openai":
          return await this.fetchOpenAIModels();
        case "anthropic":
          return await this.fetchAnthropicModels();
        case "google":
          return await this.fetchGoogleModels();
        case "ollama":
          return await this.fetchOllamaModels();
        case "lmstudio":
          return await this.fetchLMStudioModels();
        default:
          return [];
      }
    } catch (error) {
      console.error(`Failed to fetch models for ${provider}:`, error);
      return [];
    }
  }
  async fetchOpenAIModels() {
    if (!this.plugin.settings.openaiApiKey)
      return [];
    try {
      const response = await fetch("https://api.openai.com/v1/models", {
        headers: {
          "Authorization": `Bearer ${this.plugin.settings.openaiApiKey}`,
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        console.error("OpenAI API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("OpenAI API response:", data);
      if (!data.data)
        return [];
      return data.data.filter((model) => {
        return model.id.includes("gpt") || model.id.includes("o1") || model.id.includes("o3");
      }).map((model) => model.id).sort();
    } catch (error) {
      console.error("Error fetching OpenAI models:", error);
      return [];
    }
  }
  async fetchAnthropicModels() {
    if (!this.plugin.settings.anthropicApiKey)
      return [];
    try {
      const response = await FetchManager.enhancedFetch("https://api.anthropic.com/v1/models", {
        headers: {
          "x-api-key": this.plugin.settings.anthropicApiKey,
          "anthropic-version": "2023-06-01"
        }
      });
      if (!response.ok) {
        console.error("Anthropic API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("Anthropic API response:", data);
      if (!data.data)
        return [];
      return data.data.map((model) => model.id).sort();
    } catch (error) {
      console.error("Error fetching Anthropic models:", error);
      return [];
    }
  }
  async fetchGoogleModels() {
    if (!this.plugin.settings.googleApiKey)
      return [];
    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${this.plugin.settings.googleApiKey}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        console.error("Google API error:", response.status, response.statusText);
        return [];
      }
      const data = await response.json();
      console.log("Google API response:", data);
      if (!data.models)
        return [];
      return data.models.filter((model) => {
        var _a;
        return (_a = model.supportedGenerationMethods) == null ? void 0 : _a.includes("generateContent");
      }).map((model) => {
        return model.name.replace("models/", "");
      }).sort();
    } catch (error) {
      console.error("Error fetching Google models:", error);
      return [];
    }
  }
  async fetchOllamaModels() {
    var _a;
    try {
      const response = await fetch(`${this.plugin.settings.ollamaBaseUrl}/api/tags`);
      if (!response.ok)
        return [];
      const data = await response.json();
      return ((_a = data.models) == null ? void 0 : _a.map((model) => model.name)) || [];
    } catch (error) {
      console.error("Error fetching Ollama models:", error);
      return [];
    }
  }
  async fetchLMStudioModels() {
    var _a;
    try {
      const response = await fetch(`${this.plugin.settings.lmStudioBaseUrl}/v1/models`);
      if (!response.ok)
        return [];
      const data = await response.json();
      return ((_a = data.data) == null ? void 0 : _a.map((model) => model.id)) || [];
    } catch (error) {
      console.error("Error fetching LM Studio models:", error);
      return [];
    }
  }
  async refreshModelDropdown() {
    if (!this.modelDropdown) {
      console.log("No model dropdown found");
      return;
    }
    console.log(`Refreshing models for provider: ${this.plugin.settings.provider}`);
    console.log("Dropdown object:", this.modelDropdown);
    console.log("Dropdown keys:", Object.keys(this.modelDropdown));
    try {
      const models = await this.fetchModelsForProvider(this.plugin.settings.provider);
      console.log(`Fetched ${models.length} models for ${this.plugin.settings.provider}:`, models);
      const dropdown = this.modelDropdown;
      if (dropdown.selectEl) {
        console.log("Using selectEl method");
        dropdown.selectEl.empty();
        if (models.length === 0) {
          dropdown.addOption("", `No ${this.plugin.settings.provider} models found`);
        } else {
          models.forEach((model) => {
            console.log(`Adding model option: ${model}`);
            dropdown.addOption(model, model);
          });
        }
        dropdown.setValue(this.plugin.settings.model);
        console.log(`Set dropdown value to: ${this.plugin.settings.model}`);
      } else if (dropdown.dropdownEl) {
        console.log("Using dropdownEl method");
        const select = dropdown.dropdownEl;
        select.empty();
        if (models.length === 0) {
          select.createEl("option", { text: `No ${this.plugin.settings.provider} models found`, value: "" });
        } else {
          models.forEach((model) => {
            console.log(`Adding model option: ${model}`);
            select.createEl("option", { text: model, value: model });
          });
        }
        dropdown.setValue(this.plugin.settings.model);
        console.log(`Set dropdown value to: ${this.plugin.settings.model}`);
      } else {
        console.log("Recreating dropdown");
        this.createModelDropdown(models);
      }
    } catch (error) {
      console.error("Error refreshing models:", error);
    }
  }
  createModelDropdown(models) {
    if (!this.modelSetting) {
      console.error("No model setting found for dropdown creation");
      return;
    }
    console.log("Creating model dropdown, current components:", this.modelSetting.components.length);
    this.modelSetting.controlEl.empty();
    this.modelSetting.components = [];
    this.modelDropdown = this.modelSetting.addDropdown((dropdown) => {
      if (models.length === 0) {
        dropdown.addOption("", `No ${this.plugin.settings.provider} models found`);
      } else {
        models.forEach((model) => {
          dropdown.addOption(model, model);
        });
      }
      dropdown.setValue(this.plugin.settings.model);
      dropdown.onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
        this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE).forEach((leaf) => {
          const chatView = leaf.view;
          if (chatView && chatView.updateModelInfo) {
            chatView.updateModelInfo(chatView.modelInfoContainer);
          }
        });
      });
      return dropdown;
    });
    console.log(`Created new dropdown with ${models.length} models, components now:`, this.modelSetting.components.length);
  }
  showAvailableQuickAddCommands() {
    try {
      const commands = this.app.commands;
      if (!commands) {
        new import_obsidian.Notice("Commands system not available");
        return;
      }
      const allCommands = commands.listCommands();
      const quickAddCommands = allCommands.filter((cmd) => cmd.id.includes("quickadd"));
      if (quickAddCommands.length === 0) {
        new import_obsidian.Notice("No QuickAdd commands found. Make sure QuickAdd plugin is installed and configured.");
        return;
      }
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Available QuickAdd Commands");
      const content = modal.contentEl;
      content.createEl("p", { text: "Copy the Command ID to use in Stella settings:" });
      const container = content.createDiv("quickadd-commands-list");
      quickAddCommands.forEach((cmd) => {
        const cmdItem = container.createDiv("quickadd-command-item");
        cmdItem.style.marginBottom = "10px";
        cmdItem.style.padding = "8px";
        cmdItem.style.border = "1px solid var(--background-modifier-border)";
        cmdItem.style.borderRadius = "4px";
        const nameEl = cmdItem.createEl("strong", { text: cmd.name });
        nameEl.style.display = "block";
        const idEl = cmdItem.createEl("code", { text: cmd.id });
        idEl.style.display = "block";
        idEl.style.marginTop = "4px";
        idEl.style.fontSize = "12px";
        idEl.style.color = "var(--text-muted)";
        idEl.style.cursor = "pointer";
        idEl.addEventListener("click", () => {
          navigator.clipboard.writeText(cmd.id);
          new import_obsidian.Notice(`Copied: ${cmd.id}`);
        });
      });
      const buttonContainer = content.createDiv();
      buttonContainer.style.marginTop = "16px";
      buttonContainer.style.textAlign = "right";
      const closeBtn = buttonContainer.createEl("button", { text: "Close" });
      closeBtn.onclick = () => modal.close();
      modal.open();
    } catch (error) {
      new import_obsidian.Notice("Failed to retrieve QuickAdd commands");
      console.error("Error showing QuickAdd commands:", error);
    }
  }
  showMCPServerModal(server, index) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText(server ? "Edit MCP Server" : "Add MCP Server");
    const content = modal.contentEl;
    let selectedTransport = (server == null ? void 0 : server.transport) || "stdio";
    let nameInput;
    let commandInput;
    let argsInput;
    let endpointInput;
    let envContainer;
    const nameContainer = content.createDiv();
    nameContainer.createEl("label", { text: "Server Name" });
    nameInput = nameContainer.createEl("input", {
      type: "text",
      value: (server == null ? void 0 : server.name) || "",
      attr: { placeholder: "e.g., My Custom MCP Server" }
    });
    nameInput.style.width = "100%";
    nameInput.style.marginTop = "4px";
    const transportContainer = content.createDiv();
    transportContainer.style.marginTop = "16px";
    transportContainer.createEl("label", { text: "Server Type" });
    const transportToggle = transportContainer.createDiv();
    transportToggle.style.marginTop = "8px";
    transportToggle.style.display = "flex";
    transportToggle.style.gap = "12px";
    const stdioOption = transportToggle.createEl("label");
    stdioOption.style.cursor = "pointer";
    stdioOption.style.display = "flex";
    stdioOption.style.alignItems = "center";
    stdioOption.style.gap = "6px";
    const stdioRadio = stdioOption.createEl("input", { type: "radio", value: "stdio" });
    stdioRadio.name = "transport";
    stdioRadio.checked = selectedTransport === "stdio";
    stdioOption.createSpan({ text: "Local Server (like Claude Desktop)" });
    const httpOption = transportToggle.createEl("label");
    httpOption.style.cursor = "pointer";
    httpOption.style.display = "flex";
    httpOption.style.alignItems = "center";
    httpOption.style.gap = "6px";
    const httpRadio = httpOption.createEl("input", { type: "radio", value: "http" });
    httpRadio.name = "transport";
    httpRadio.checked = selectedTransport === "http";
    httpOption.createSpan({ text: "Remote Server (WebSocket)" });
    const configContainer = content.createDiv();
    configContainer.style.marginTop = "16px";
    const updateConfig = () => {
      var _a;
      configContainer.empty();
      if (selectedTransport === "stdio") {
        configContainer.createEl("label", { text: "Command" });
        commandInput = configContainer.createEl("input", {
          type: "text",
          value: (server == null ? void 0 : server.command) || "npx",
          attr: { placeholder: "npx" }
        });
        commandInput.style.width = "100%";
        commandInput.style.marginTop = "4px";
        const argsLabel = configContainer.createEl("label", { text: "Arguments" });
        argsLabel.style.marginTop = "12px";
        argsLabel.style.display = "block";
        argsInput = configContainer.createEl("input", {
          type: "text",
          value: ((_a = server == null ? void 0 : server.args) == null ? void 0 : _a.join(" ")) || "",
          attr: { placeholder: "-y @modelcontextprotocol/server-filesystem /path/to/files" }
        });
        argsInput.style.width = "100%";
        argsInput.style.marginTop = "4px";
        const envLabel = configContainer.createEl("label", { text: "Environment Variables (optional)" });
        envLabel.style.marginTop = "12px";
        envLabel.style.display = "block";
        envContainer = configContainer.createDiv();
        envContainer.style.marginTop = "8px";
        if (server == null ? void 0 : server.env) {
          Object.entries(server.env).forEach(([key, value]) => {
            addEnvVar(key, value);
          });
        }
        const addEnvBtn = configContainer.createEl("button", { text: "+ Add Environment Variable" });
        addEnvBtn.style.marginTop = "8px";
        addEnvBtn.onclick = (e) => {
          e.preventDefault();
          addEnvVar();
        };
      } else {
        configContainer.createEl("label", { text: "WebSocket Endpoint" });
        endpointInput = configContainer.createEl("input", {
          type: "url",
          value: (server == null ? void 0 : server.endpoint) || "",
          attr: { placeholder: "wss://your-mcp-server.com/mcp" }
        });
        endpointInput.style.width = "100%";
        endpointInput.style.marginTop = "4px";
      }
    };
    const addEnvVar = (key = "", value = "") => {
      const envRow = envContainer.createDiv();
      envRow.style.display = "flex";
      envRow.style.gap = "8px";
      envRow.style.marginBottom = "8px";
      envRow.style.alignItems = "center";
      const keyInput = envRow.createEl("input", {
        type: "text",
        value: key,
        attr: { placeholder: "VARIABLE_NAME" }
      });
      keyInput.style.flex = "1";
      keyInput.dataset.envKey = "true";
      const valueInput = envRow.createEl("input", {
        type: "text",
        value,
        attr: { placeholder: "value" }
      });
      valueInput.style.flex = "2";
      valueInput.dataset.envValue = "true";
      const removeBtn = envRow.createEl("button", { text: "\xD7" });
      removeBtn.style.width = "30px";
      removeBtn.style.height = "30px";
      removeBtn.style.borderRadius = "4px";
      removeBtn.onclick = (e) => {
        e.preventDefault();
        envRow.remove();
      };
    };
    stdioRadio.onchange = () => {
      selectedTransport = "stdio";
      updateConfig();
    };
    httpRadio.onchange = () => {
      selectedTransport = "http";
      updateConfig();
    };
    updateConfig();
    const buttonContainer = content.createDiv();
    buttonContainer.style.marginTop = "24px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const saveBtn = buttonContainer.createEl("button", {
      text: server ? "Update" : "Add",
      cls: "mod-cta"
    });
    saveBtn.onclick = async () => {
      const name = nameInput.value.trim();
      if (!name) {
        new import_obsidian.Notice("Server name is required");
        return;
      }
      const newServer = {
        id: (server == null ? void 0 : server.id) || `mcp-${Date.now()}`,
        name,
        transport: selectedTransport,
        connected: false
      };
      if (selectedTransport === "stdio") {
        newServer.command = commandInput.value.trim() || "npx";
        newServer.args = argsInput.value.trim() ? argsInput.value.trim().split(" ").filter((arg) => arg.length > 0) : [];
        const envVars = {};
        const keyInputs = envContainer.querySelectorAll("[data-env-key]");
        const valueInputs = envContainer.querySelectorAll("[data-env-value]");
        keyInputs.forEach((keyInput, i) => {
          var _a;
          const key = keyInput.value.trim();
          const value = (_a = valueInputs[i]) == null ? void 0 : _a.value.trim();
          if (key && value) {
            envVars[key] = value;
          }
        });
        if (Object.keys(envVars).length > 0) {
          newServer.env = envVars;
        }
      } else {
        const endpoint = endpointInput.value.trim();
        if (!endpoint) {
          new import_obsidian.Notice("WebSocket endpoint is required");
          return;
        }
        newServer.endpoint = endpoint;
      }
      try {
        if (server && typeof index === "number") {
          this.plugin.settings.mcpServers[index] = newServer;
        } else {
          this.plugin.settings.mcpServers.push(newServer);
        }
        await this.plugin.saveSettings();
        if (this.plugin.settings.mcpEnabled) {
          await this.plugin.mcp.addServer(newServer);
        }
        new import_obsidian.Notice(`MCP server ${server ? "updated" : "added"}: ${name}`);
        modal.close();
        this.display();
      } catch (error) {
        new import_obsidian.Notice(`Failed to ${server ? "update" : "add"} MCP server`);
        console.error("MCP server error:", error);
      }
    };
    modal.open();
  }
  showMCPTemplateConfigModal(template) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText(`Configure ${template.name} Server`);
    const content = modal.contentEl;
    content.createEl("p", {
      text: template.description,
      attr: { style: "color: var(--text-muted); margin-bottom: 16px;" }
    });
    const commandInfo = content.createDiv();
    commandInfo.style.marginBottom = "20px";
    commandInfo.style.padding = "12px";
    commandInfo.style.backgroundColor = "var(--background-secondary)";
    commandInfo.style.borderRadius = "8px";
    commandInfo.createEl("strong", { text: "Command:" }).style.display = "block";
    commandInfo.createEl("code", { text: `${template.command} ${template.args.join(" ")}` });
    const envInputs = {};
    if (template.envVariables.length > 0) {
      content.createEl("h4", { text: "Configuration" });
      template.envVariables.forEach((envVar) => {
        const container = content.createDiv();
        container.style.marginBottom = "16px";
        const label = container.createEl("label", { text: envVar.description });
        if (envVar.required) {
          label.createSpan({ text: " *", attr: { style: "color: var(--text-error);" } });
        }
        const input = container.createEl("input", {
          type: envVar.key.toLowerCase().includes("token") || envVar.key.toLowerCase().includes("key") ? "password" : "text",
          attr: { placeholder: envVar.placeholder || "" }
        });
        input.style.width = "100%";
        input.style.marginTop = "4px";
        envInputs[envVar.key] = input;
      });
    }
    const buttonContainer = content.createDiv();
    buttonContainer.style.marginTop = "24px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    const addBtn = buttonContainer.createEl("button", {
      text: "Add Server",
      cls: "mod-cta"
    });
    addBtn.onclick = async () => {
      for (const envVar of template.envVariables) {
        if (envVar.required && !envInputs[envVar.key].value.trim()) {
          new import_obsidian.Notice(`${envVar.description} is required`);
          return;
        }
      }
      const newServer = {
        id: `mcp-${Date.now()}`,
        name: template.name,
        transport: "stdio",
        command: template.command,
        args: [...template.args],
        connected: false
      };
      const env = {};
      Object.entries(envInputs).forEach(([key, input]) => {
        const value = input.value.trim();
        if (value) {
          env[key] = value;
        }
      });
      if (Object.keys(env).length > 0) {
        newServer.env = env;
      }
      try {
        this.plugin.settings.mcpServers.push(newServer);
        await this.plugin.saveSettings();
        if (this.plugin.settings.mcpEnabled) {
          await this.plugin.mcp.addServer(newServer);
        }
        new import_obsidian.Notice(`Added ${template.name} MCP server`);
        modal.close();
        this.display();
      } catch (error) {
        new import_obsidian.Notice(`Failed to add ${template.name} server`);
        console.error("Template server error:", error);
      }
    };
    modal.open();
  }
};
